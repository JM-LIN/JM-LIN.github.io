<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2.CentOS环境搭建Hadoop集群]]></title>
    <url>%2Fposts%2F2-CentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAHadoop%E9%9B%86%E7%BE%A4.html</url>
    <content type="text"><![CDATA[.注：本文在已经使用VMware虚拟机安装了CentOS6.5_64位镜像基础下进行操作（如还未安装，可参考该链接）；以下所有关于命令行操作均以root用户操作，其设计相关的文件名称和目录名称不一定全部相同，请按照实际情况修改。1. 基础配置基础软件安装1yum install vim -y共享目录配置在VMware顶栏点击虚拟机-&gt;安装VMWare Tools此时虚拟机弹出一个光盘镜像，以下命令行操作123tar -zxvf /media/VMware\ Tools/VMwareTools-10.1.6-5214329.tar.gz -C /home/jmlin/cd /home/jmlin/vmware-tools-distribsudo ./vmware-install.pl之后一直按回车，默认设置在VMware顶栏点击虚拟机-&gt;设置-&gt;选项-&gt;共享文件夹-&gt;总是启用在右边框选择添加-&gt;下一步-&gt;选择自己要共享的文件夹的路径-&gt;一路确定命令行reboot重启虚拟机设置静态IPa. 图形界面操作b. 命令行操作1234567891011121314vi /etc/sysconfig/network-scripts/ifcfg-eth------DEVICE=eth0 # 网卡设备名BOOTPROTO=static # 获取静态IP# BOOTPROTO=dhcp # 通过DHCP协议获取IP# BOOTPROTO=bootp # 通过BOOTP协议获取IPONBOOT=yes # 自动联网NM_CONTROLLED=yesIPADDR=192.168.0.110 NETMASK=255.255.255.0 GATEWAY=192.168.0.1 DNS1=192.168.0.1 # 设置为路由器IP------service network restartDNS解析、修改主机名1234567891011121314151617vi /etc/hosts------192.168.0.110 master192.168.0.111 slave1192.168.0.112 slave2 · (设置从机名) · ·------source /etc/hostsvi /etc/sysconfig/network将`HOSTNAME=localhost.localdomain`改为------HOSTNAME=master------hostname master # 令修改立即生效关闭防火墙123service iptables stopchkconfig iptables offservice iptables status系统自动登录123456vi /etc/gdm/custom.conf------[daemon]AutomaticLoginEnable=trueAutomaticLogin=jmlin------设置root弱密码1234vi /etc/pam.d/system-auth------password requisite pam_cracklib.so try_first_pass retry=3 type= minlen=5------由于是本地操作，所以就设置一个短的密码，一般生产环境不建议设置太短配置SSH免密登录123456yum install openssh-server -yssh-keygen -t rsa三次回车cd ~/.ssh/cp id_rsa.pub authorized_keyschkconfig sshd on # 配置sshd自启动创建hadoop用户123mkdir /home/hadoopuseradd -d /home/hadoop -m hadooppasswd hadoop2. JDK12345678910rpm -ivh jdk-8u51-linux-x64.rpmmv /usr/java/jdk1.8.0_51 /usr/local/jdkvi ~/.bashrc------# 在文件最后添加export JAVA_HOME=/usr/local/jdkexport PATH=$JAVA_HOME/bin:$PATH------source ~/.bashrcjava -version3. Hadoop伪分布式安装12345678910tar zxvf hadoop-2.6.2.tar.gz -C /usr/local/cd !$mv hadoop-2.6.2 hadoopvi ~/.bashrc------alias cdha=&apos;cd /usr/local/hadoop&apos;export HADOOP_HOME=/usr/local/hadoopexport PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH------source !$文件配置hadoop-env.sh1234567cdhacd etc/hadoopvi hadoop-env.sh将`export JAVA_HOME=$&#123;JAVA_HOME&#125;`替换为------export JAVA_HOME=/usr/local/jdk------yarn-env.sh12345vi yarn-env.sh将`23行`替换为------export JAVA_HOME=/usr/local/jdk------core-site.xml123456789101112131415161718vi core-site.xml------&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.native.lib&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;description&gt;Should native hadoop libraries, if present, be used.&lt;/description&gt; &lt;/property&gt;&lt;/configuration&gt;------hdfs-site.xml1234567891011121314151617vi hdfs-site.xml------&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;3&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/hdfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/hdfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;------yarn-site.xml1234567891011121314151617181920vi yarn-site.xml------&lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;master:18088&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;------mapred-site.xml123456789101112131415161718cp mapred-site.xml.template mapred-site.xmlvi !$------&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;master:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;master:19888&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;------At Last123hdfs namenode –format # 格式化文件系统start-all.shjps # 查看Java进程状态出现警告1WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable解决12345vi /usr/local/hadoop/etc/hadoop/log4j.properties添加一行，用于消除因hadoop希望glibc版本为2.14以上的警告信息------log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR------MapReduce使用123456789101112cd /usr/local/hadoop/share/hadoop/mapreducehadoop jar hadoop-mapreduce-example-2.6.2.jar # 查看包中的功能# 统计文件中单词重复的次数hadoop jar hadoop-mapreduce-example-2.6.2.jar wordcount # 查看wordcount用法cd touch ReadMe.txtecho &apos;Hello World&apos; &gt; ReadMe.txthadoop fs -put ./ReadMe.txt /cd -hadoop jar hadoop-mapreduce-example-2.6.2.jar wordcount /ReadMe.txt /wordcount_outputhadoop fs -text /wordcount_output/part-r-000004. 分布式安装以下操作，想要使用多少台从机就设置多少次导出虚拟机先把要复制的虚拟机关机VMware状态栏-&gt;文件-&gt;导出为OVF设置静态IPDNS解析、修改主机名12345678910111213141516[root@slave1 hadoop]# vi /etc/hosts------192.168.0.110 master192.168.0.111 slave1192.168.0.112 slave2 · (设置从机名) · ·------[root@slave1 hadoop]# vi /etc/sysconfig/network将`HOSTNAME=master`改为------HOSTNAME=slave1------[root@slave1 hadoop]# hostname slave1 # 令修改立即生效5. 集群间SSH免密登录12345# 主节点[root@master hadoop]# ssh-copy-id -i ~/.ssh/id_rsa.pub slave1# 从节点[root@slave1 hadoop]# ssh-copy-id -i ~/.ssh/id_rsa.pub master6. 格式化文件系统1234567891011# 从节点[root@slave1 hadoop]# rm -rf /home/hadoop/tmp/*[root@slave1 hadoop]# rm -rf /home/hadoop/hdfs/name/*[root@slave1 hadoop]# rm -rf /home/hadoop/hdfs/data/*# 主节点[root@master hadoop]# rm -rf /home/hadoop/tmp/*[root@master hadoop]# rm -rf /home/hadoop/hdfs/name/*[root@master hadoop]# rm -rf /home/hadoop/hdfs/data/*[root@master hadoop]# hdfs namenode -format7. 启动集群1234567# 主机[root@master hadoop]# start-all.sh[root@master hadoop]# jps[root@master hadoop]# hdfs dfsadmin -report # 查看结点状态报告# 从机[root@slave1 hadoop]# jpsWeb UI 查看集群是否启动成功浏览器打开http://master:50070http://master:18088参考链接在树莓派上通过 Apache Spark on YARN 搭建 Hadoop 集群注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>云计算与物联网</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>分布式云计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.话说大数据]]></title>
    <url>%2Fposts%2F1-%E8%AF%9D%E8%AF%B4%E5%A4%A7%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[一些简单的关于云计算的基础概念总结特征：大量化、快速化、多样化、价值化IT基础设施1.云计算2.虚拟化3.大数据4.Hadoop生态圈(分布式存储与并行计算及其框架)1. 关键技术1.1 数据采集利用ETL工具将分布的、异构数据源中的数据(如关系数据、平面数据文件)，抽取到临时中间层后进行清洗、转换、集成最后加载到数据仓库或数据集市中，成为联机分析处理、数据挖掘的基础或者可以把实时采集的数据作为流计算系统的输入，进行实时处理分析1.2 数据存储和管理利用分布式文件系统、数据仓库、关系数据库、NoSQL、云数据库等实现对结构化、半结构化和非结构化海量数据的存储和管理1.3 数据处理与分析利用分布式并行编程模型和计算框架，结合机器学习和数据挖掘算法实现对海量数据的处理和分析(对分析结果进行可视化呈现，帮助人们更好地理解数据、分析数据)1.4 数据隐私和安全在从大数据中挖掘潜在的巨大商业价值和学术价值的同时，构建隐私数据保护体系和数据安全体系，有效保护个人隐私和数据安全2. Hadoop生态圈资源HDFS存储MapReduce框架服务HDFS操作HDFS编程MapReduce提供分布式并行计算HBase数据库Hive数据仓库数据库与数据仓库对比数据仓库的数据一般由数据库的数据经过一定的规则转换得到数据仓库主要用来分析数据，一般是TB级数据(如决策支持系统、数据挖掘)数据仓库数据库面向分析面向事务处理数据基本不变根据日常业务而更新3. 大数据计算模式典型大数据计算模式典型系统批处理计算Hadoop MapReduce，Spark等流式计算Scribe，Flume，Storm，S4, Spark Steaming等迭代计算HaLoop，iMapReduce，Twister，Spark等图计算Pregel，Giraph，Trinity，PowerGraph，GraphX等内存计算Dremel，Hana，Spark等大数据查询分析计算HBase，Hive，Cassandra，Impala，Shark，Hana等注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>云计算与物联网</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[话说字符设备驱动]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.html</url>
    <content type="text"><![CDATA[最近在学习字符设备驱动，涉及到很多框架层面的东西，这里就来记录一下。概述开始，就先把框架图放出来。在用户空间通过insmod调用module_init模块加载函数激活相应的设备驱动初始化函数接着就是添加字符设备驱动在字符设备驱动初始化前，先要分配主次设备号在对应目录中创建相应的类文件和设备文件并填充file_operations结构体字符设备驱动注册到内核后就可以使用之前应用层的read、write、ioctl等函数应用层所使用的对文件进行读写操作的函数都绑定了file_operations中的方法应用层调用接口常用方法：open打开设备文件read读取设备文件内容write写入设备文件内容ioctl进行IO操作close关闭设备文件设备类struct kobject数据结构在sysfs中代表一个目录struct driver、struct device、struct class均由kobject派生struct driver_attribute、struct device_attribute、struct class_attribute代表普通文件struct kset是struct kobject的容器，可以成为同一类struct kobject的父亲，而其自身也有struct kobject成员，因此其又可以和其他struct kobject成为上一级struct kset的子成员数据结构cdev这个是存放字符设备驱动的相关数据的结构体12345678struct cdev &#123; struct kobject kobj; struct module *owner; // 指向实现驱动的模块 const struct file_operations *ops; // 操纵该字符设备文件的方法 struct list_head list; // 对应字符设备文件的inode-&gt;i_devices的链表头 dev_t dev; // 设备号 unsigned int count; // 次设备个数&#125;;file_operation定义字符设备驱动提供给VFS的接口函数集12345678910111213141516171819202122232425262728struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t); ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t); int (*readdir) (struct file *, void *, filldir_t); unsigned int (*poll) (struct file *, struct poll_table_struct *); int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); int (*open) (struct inode *, struct file *); int (*flush) (struct file *, fl_owner_t id); int (*release) (struct inode *, struct file *); int (*fsync) (struct file *, int datasync); int (*aio_fsync) (struct kiocb *, int datasync); int (*fasync) (int, struct file *, int); int (*lock) (struct file *, int, struct file_lock *); ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); int (*check_flags)(int); int (*flock) (struct file *, int, struct file_lock *); ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); int (*setlease)(struct file *, long, struct file_lock **);&#125;;创建过程由于年代的变迁，字符设备号的分配接口有新的和旧的，不过它们的底层还是调用了相同的函数1. 分配字符设备号(旧接口)① 分配12static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)传入参数分别为主设备号、设备名称、文件操作集② 释放1static inline void unregister_chrdev(unsigned int major, const char *name)传入参数分别为主设备号、设备名称2. 分配字符设备号(新接口)① 静态分配1int register_chrdev_region(dev_t from, unsigned count, const char *name)传入参数分别为设备号、设备数量、设备名称② 动态分配12int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)传入参数分别为设备号、次设备号基址、设备数量、设备名称③ 释放1void unregister_chrdev_region(dev_t from, unsigned count)传入参数分别为设备号、设备个数3. 创建设备文件可以在应用层使用命令行cat /proc/devices查看所有设备的设备名、以及主次设备号① 手工创建mknod filename type major minor② 自动创建⑴ class_create首先创建一个设备类12345#define class_create(owner, name) \(&#123; \ static struct lock_class_key __key; \ __class_create(owner, name, &amp;__key); \&#125;)⑵ device_create接着创建一个设备1234567891011struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)&#123; va_list vargs; struct device *dev; va_start(vargs, fmt); dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs); va_end(vargs); return dev;&#125;在驱动代码中调用class_create()为设备创建一个设备类，再为每个设备调用device_create()创建对应的设备，udev(mdev)会自动创建一个设备文件原理：利用udev(mdev)来实现设备文件的自动创建，由busybox配置。在加载模块的时候，用户空间的mdev会自动去/sysfs下相应的目录寻找对应的类从而创建设备结点12345678// /etc/init.d/rcS#!/bin/shPATH=/sbin:/bin:/usr/sbin:/usr/bin ···中间省略···echo /sbin/mdev &gt; /proc/sys/kernel/hotplug // 与这个运行脚本有关mdev -s ···中间省略···⑶ class_destroy删除设备类123456void class_destroy(struct class *cls)&#123; if ((cls == NULL) || (IS_ERR(cls))) return; class_unregister(cls);&#125;⑷ device_destroy删除设备123456789void device_destroy(struct class *class, dev_t devt)&#123; struct device *dev; dev = class_find_device(class, NULL, &amp;devt, __match_devt); if (dev) &#123; put_device(dev); device_unregister(dev); &#125;&#125;4. 注册/注销字符设备驱动① cdev_alloc获取一个字符设备结构体12static struct cdev *pcdev = NULL;pcdev = cdev_alloc();② cdev_init字符设备驱动初始化绑定字符设备结构体(cdev)与文件操作集(fops)void cdev_init(struct cdev *cdev, const struct file_operations *fops)③ cdev_add添加字符设备驱动绑定字符设备驱动(cdev)与设备号(dev)int cdev_add(struct cdev *p, dev_t dev, unsigned count)④ cdev_del注销字符设备驱动void cdev_del(struct cdev *p)5. 内核的虚拟地址映射若需要用到gpio等资源就需要虚拟地址映射① request_mem_region向内核请求需要映射的内存资源request_mem_region(start,n,name)② ioremap映射传入的物理地址返回一个虚拟地址ioremap(cookie,size)③ iounmap传入虚拟地址，取消地址映射iounmap(cookie)④ release_mem_region释放内核请求需要映射的内存资源release_mem_region(start,n)6. Others① printk内核信息打印函数12345678910111213#define KERN_EMERG &quot;&lt;0&gt;&quot; /* system is unusable */#define KERN_ALERT &quot;&lt;1&gt;&quot; /* action must be taken immediately */#define KERN_CRIT &quot;&lt;2&gt;&quot; /* critical conditions */#define KERN_ERR &quot;&lt;3&gt;&quot; /* error conditions */#define KERN_WARNING &quot;&lt;4&gt;&quot; /* warning conditions */#define KERN_NOTICE &quot;&lt;5&gt;&quot; /* normal but significant */#define KERN_INFO &quot;&lt;6&gt;&quot; /* informational */#define KERN_DEBUG &quot;&lt;7&gt;&quot; /* debug-level messages */#define DEFAULT_MESSAGE_LOGLEVEL 4 /* KERN_WARNING */// 未指定日志级别的printk的默认级别为DEFAULT_MESSAGE_LOGLEVELprintk(KERN_INFO &quot;Hello, world!/n&quot;);使用命令行cat /proc/sys/kernel/printk显示： 4 4 1 7分别表示当前控制台日志级别未明确指定日志级别的默认信息日志级别最高允许设置的控制台日志级别引导时默认的日志级别dmesg可查看printk打印的信息② copy_from_user使用file_operations中的方法集 write函数将数据从用户空间复制到内核空间`static inline unsigned long __must_check copy_from_user(void *to,const void __user *from, unsigned long n)` ③ copy_to_user使用file_operations中的方法集 read函数将数据从内核空间复制到用户空间`static inline unsigned long must_check copy_to_user(void user *to,const void *from, unsigned long n)` 参考文章Linux字符设备驱动剖析深入理解Linux字符设备驱动注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Linux驱动架构</category>
      </categories>
      <tags>
        <tag>driver</tag>
        <tag>device</tag>
        <tag>驱动</tag>
        <tag>设备</tag>
        <tag>字符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARM处理器概述]]></title>
    <url>%2Fposts%2FARM%E5%A4%84%E7%90%86%E5%99%A8.html</url>
    <content type="text"><![CDATA[简单总结一下ARM处理器工作模式及其寄存器！一. 异常与中断的理解Insight One中断描述的主体是外设(向CPU发送信号)，异常描述的主体是CPU(接收信号)中断是一个过程，是CPU在执行当前的程序的过程中因硬件或软件的原因插入了另一段程序运行的过程Insight Two中断是异常的一种，异常分为中断异常(IRQ/FIQ)和非中断异常(SVC/Undefine/Abort)二. 7个工作模式7个工作模式分别为：User, FIQ, IRQ, SVC, Abort, Undefine, SystemA. Normal Mode1.User用户模式用户程序运行模式，运行在操作系统的用户态，没有权限去操作其他硬件资源，不能切换到其它模式下，只能执行处理自己的数据，要想访问硬件资源或切换其它模式只能通过软中断或产生异常B. Privileged Modes特权模式该组模式下可以任意访问系统资源其特权：MRS(把状态寄存器的内容放到通用寄存器)MSR(把通用寄存器的内容放到状态寄存器)由于状态寄存器的内容不能够改变，因此先把内容复制到通用寄存器中，然后修改通用寄存器中的内容，再把通用寄存器中的内容复制给状态寄存器中，即可完成“修改状态寄存器”的任务异常模式2.FIQ快速中断模式一个高优先级（fast）中断产生3.IRQ普通中断模式一个低优先级(normal)中断产生4.Supervisor/SVC管理模式操作系统的保护模式，系统开机、复位或软中断指令执行时响应CPU上电后默认模式，该模式主要用来做系统初始化，软中断处理也在该模式下，当用户模式下的用户程序请求使用硬件资源是，通过软件中断进入该模式5.Abort中止模式虚拟内存和存储器的保护模式，指令预取中止和数据访问中止时响应当用户程序访问非法地址，没有权限读取的内存地址时，会进入该模式。Linux下编程出现的segment fault通常都是在该模式下抛出返回的6.Undefine未定义模式用于软件仿真，CPU在指令的译码阶段不能识别某指令操作时响应非异常模式7.System系统模式共用User模式下相同寄存器集的特权模式，运行操作系统任务，可以访问所有系统资源地址偏移量各种异常模式的地址偏移量 三. 37个寄存器1. 30个通用寄存器1.1. 8个不分组寄存器8个(R0-R7)[x] R0-R71.2. 22个分组寄存器10个(R8-R12)[x] 5个FIQ模式的分组寄存器[x] 5个非FIQ模式的分组寄存器12个(R13-R14)[x] 6个SP(Stack Pointer Register)[x] 6个LR(Link Register)2. 7个特殊功能寄存器2.1.1个(R15)[x] PC指针(Program Control register)PC指向哪里，CPU就会执行哪条代码，所以程序跳转就是把目标地址代码放到PC中1个[x] CPSR(Current program status register/当前程序状态寄存器)5个[x] SPSR(Saved program status register/保存程序状态寄存器)异常模式下使用mode位(bit4~bit0)决定了CPU的工作模式，uboot代码中使用汇编设置 四. 异常产生及其返回五. ARM的基本设定ARM约定Byte : 8bits Halfword : 16bits Word : 32bits 大部分ARM core提供ARM指令集（32 bit） Thumb指令集（16 bit） Thumb2指令集（16 &amp; 32 bit） 注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>ARM_Linux</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>异常</tag>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mini嵌入式web服务器搭建]]></title>
    <url>%2Fposts%2Fmini%E5%B5%8C%E5%85%A5%E5%BC%8Fweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[.前期准备Windows系统下安装虚拟机安装以Linux为内核的操作系统(如Ubuntu)安装secureCRT超级终端用于查看开发板输出的调试信息并与开发板交互安装DNW安装Source Insight在Windows下查看及其修改代码虚拟机系统下设置文件共享安装交叉编译工具链，并导入环境变量解压mkdir /usr/local/arm/ 创建一个新文件夹，用于存放编译链工具mv /mnt/hgfs/Winshare/arm-2009q3.tar.bz2 /usr/local/arm/把下载到的编译工具链压缩包移动到上面的文件夹cd /usr/local/arm/tar -jxvf arm-2009q3.tar.bz2安装mv /mnt/hgfs/Winshare/mk-arm-linux.sh /usr/local/arm/arm-2009q3/bin 根据自己的共享目录名字改动cd /usr/local/arm/arm-2009q3/binsource mk-arm-linux.sh导入环境变量gedit ~/.bashrc打开这个文件，在最下面添加以下一行export PATH=/usr/local/arm/arm-2009q3/bin:$PATHsource ~/.bashrc64位兼容32位如果Ubuntu是64位的1234sudo dpkg --add-architecture i386sudo apt-get updatesudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386sudo ./adb测试在任意路径下敲arm-linux-gcc -v返回信息gcc version 4.4.1表示你已经安装成功了安装NFS安装sudo apt-get install nfs-kernel-server -y重启service rpcbind restartservice nfs-kernel-server restart建立文件目录mkdir /opt/Rootfs_TQ210 # 建立根文件目录chmod 777 -R /opt/Rootfs_TQ210mkdir /opt1 #建立访问目录，位置不固定配置sudo vi /etc/exports/opt/Rootfs_TQ210 *(rw,sync,no_root_squash,no_subtree_check) #在文本最后加上/opt/Rootfs_TQ210目录是与nfs服务客户端共享的目录，*代表允许所有的网段访问rw：挂载此目录的客户端对该共享目录具有读写权限sync：资料同步写入内存和硬盘no_root_squash：客户机用root访问该共享文件夹时，不映射root用户(root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户)no_subtree_check：不检查父目录的权限测试sudo exportfs -r #更新文件sudo showmount localhost -e #下面是显示信息Export list for Ubuntu2jmlin:/opt/Rootfs_TQ210 *本地挂载mount -t nfs -o nolock localhost:/opt/Rootfs_TQ210 /opt1 #挂载Rootfs_TQ210目录到/opt1目录下Uboot获取源码开发板光盘/bootloader/uboot_TQ210_1.3.4_V1.7.tar.bz2复制到Ubuntu/opt/目录下解压tar -jxvf uboot_TQ210_1.3.4_V1.7.tar.bz2源码检查清理make distclean修改交叉编译工具链路径vi Makefile # 在相应地方(149)添加CROSS_COMPILE = arm-linux-编译前配置make TQ210_config编译make -j8烧录使用DNW烧录进入Uboot命令命令行开发板开机按下空格键，进入天嵌制作的操作菜单按下字母q退出天嵌的操作菜单，进入uboot命令行设置uboot环境变量本地IP地址和服务器IP地址要在同一网段123456789set ipaddr 192.168.0.105 # 设置本地IP地址set gatewayip 192.168.0.1 # 设置网关set serverip 192.168.0.101 # 设置服务器IP地址set nfsipaddr 192.168.0.105 # 设置NFS IP地址set nfsserverip 192.168.0.101 # 设置NFS 服务器IP地址set nfs_dir /opt/rootfs_TQ210 # 设置NFS 文件夹set bootargs root=/dev/nfs nfsroot=192.168.0.101:/opt/rootfs_TQ210 ip=192.168.0.105:192.168.0.101:192.168.0.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200saveKernel获取源码开发板光盘/Linux资源/Linux源码包/3.0.8/Kernel_3.0.8_TQ210_for_Linux_v2.2.tar.bz2复制到Ubuntu /opt/ 目录下解压tar -jxvf Kernel_3.0.8_TQ210_for_Linux_v2.2.tar.bz2源码检查清理make distclean编译前配置cp config_for_TQ210_Linux_v2.1_CoreB .config检查Makefile所配置的交叉编译链、是否为arm架构配置生成默认文件cp config_for_TQ210_Linux_v2.1_CoreB .config #直接使用天嵌已经给的默认配置文件kernel 裁剪make menuconfig如果是第一次使用的话，可能会出现错误根据错误，需要下载ncurses，先执行sudo apt-get install libncurses5-dev来下载，然后再make menuconfigDevice Drivers —&gt;Multimedia support —&gt;Video capture adapters —&gt;[*] Samsung Camera Interface (FIMC) driver // 移除摄像头驱动[ ] camera ov3640[ ] camera ov9650[ ] camera tvp5150[ ] camera saa7113[*] Samsung TV Driver[ ] HDMI CEC driver support // 移除HDMI遥控驱动[*] HDMI HPD driver supportHID Devices[ ] USB Human Interface Device (full HID) support // 移除鼠标驱动Networking support[ ] Bluetooth subsystem support // 移除蓝牙驱动File systems —&gt;[*] Network File Systems —&gt;&lt;*&gt; NFS client support // 添加NFS驱动[*] NFS client support for NFS version 3[*] NFS client support for the NFSv3 ACL protocol extension[*] NFS client support for NFS version 4 (EXPERIMENTAL)[ ] NFS client support for NFSv4.1 (DEVELOPER ONLY)[*] Root file system on NFSRootFS获取源码开发板光盘/Linux资源/Linux源码包/rootfs_linux_v1.6_CoreB_src_20140415.tar.bz2复制到Ubuntu /opt/ 目录下解压tar -jxvf rootfs_linux_v1.6_CoreB_src_20140415.tar.bz2源码检查检查Makefile所配置的交叉编译链、是否为arm架构设置安装目录为 /opt/Rootfs_TQ210编译make安装make installWeb服务器移植移植BOA-0.94.13获取源码cd /optwget https://nchc.dl.sourceforge.net/project/boa/boa/0.94.13/boa-0.94.13.tar.gztar -zxvf boa-0.94.13.tar.gz编译前配置cd src./configurevi Makefile将CC和CPP分别修改为CC=arm-linux-gcc和CPP=arm-linux-g++ -Evi boa.c在行225到227，将其注释掉123if (setuid(0) != -1) &#123; DIE(&quot;icky Linux kernel bug!&quot;); &#125;vi compat.h把120行修改为#define TIMEZONE_OFFSEST(foo) foo-&gt;tm_gmtoff编译makeError可能出现错误make: yacc: Command not foundsudo apt-get install -y byacc可能出现错误make: lex: Command not foundsudo apt-get install -y flex优化arm-linux-strip boa移植cgic库获取源码cd /optwget https://boutell.com/cgic/cgic205.tar.gztar -zxvf cgic205.tar.gz编译前配置vi Makefile以下为修改内容12345678910CC=arm-linux-gccAR=arm-linux-arRANLIB=arm-linux-ranlibcp libcgic.a /usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/armv4t/lib # 这两行根据自己所安装cp cgic.h /usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/usr/include # 交叉编译工具链位置改动$(CC) $(CFLAGS) cgictest.o -o cgictest.cgi $(LIBS)$(CC) $(CFLAGS) capture.o -o capture $(LIBS)编译make优化arm-linux-strip capture配置Web服务器配置BOAcd /opt/roorfs_TQ210mkdir web etc/boa # 在根文件系统新建web/、etc/boa/目录cp /opt/boa-0.94.13/src/boa rootfs_TQ210/sbincp /opt/boa-0.94.13/boa.conf rootfs_TQ210/etc/boa修改boa.conf文件vi etc/boa/boa.conf123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Port 80#Listen 192.168.0.105User rootGroup root#ServerAdmin root@localhost#ErrorLog /dev/nullErrorLog /dev/consoleAccessLog /dev/null#UseLocaltime#VerboseCGILogs#ServerName www.your.org.hereServerName jmlin_Server#VirtualHostDocumentRoot /web#UserDir public_htmlDirectoryIndex JMLin.html#DirectoryMaker /usr/lib/boa/boa_indexer# DirectoryCache /var/spool/boa/dircacheKeepAliveMax 1000KeepAliveTimeout 10MimeTypes /etc/mime.typesDefaultType text/plainCGIPath /binAddType application/x-httpd-cgi cgi#Alias /doc /usr/doc#ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/cp /etc/mime.types /opt/rootfs_TQ210/etc配置cgic库建立cgi-bin目录 mkdir /opt/rootfs_TQ210/web/cig-bincp /opt/cgic205/capture /opt/rootfs_TQ210/web/cgi-bin/cp /opt/cgic205/cgictest.cgi /opt/rootfs_TQ210/web/cgi-bin/测试静态网页测试在PC段网页浏览器输入地址：192.168.0.105CGI脚本测试在PC段网页浏览器输入地址：http://192.168.0.105/cgi-bin/cgictest.cgi在PC段网页浏览器输入地址：http://192.168.0.105/cgi-bin/helloweb.cgi注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>ARM_Linux</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
        <tag>NFS</tag>
        <tag>Kernel</tag>
        <tag>Rootfs</tag>
        <tag>BOA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交叉编译工具链环境搭建]]></title>
    <url>%2Fposts%2F%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[.解压mkdir /usr/local/arm/ 创建一个新文件夹，用于存放编译链工具mv /mnt/hgfs/Winshare/arm-2009q3.tar.bz2 /usr/local/arm/把你下载到的编译工具链压缩包移动到上面的文件夹,每个人的共享文件夹名字不一样，自己要根据实际改动cd /usr/local/arm/tar -jxvf arm-2009q3.tar.bz2安装mv /mnt/hgfs/Winshare/mk-arm-linux.sh /usr/local/arm/arm-2009q3/bin 根据自己的共享目录名字改动cd /usr/local/arm/arm-2009q3/binvi make-arm-linux.sh1234567891011121314151617181920212223ln arm-none-linux-gnueabi-addr2line -s arm-linux-addr2lineln arm-none-linux-gnueabi-ar -s arm-linux-arln arm-none-linux-gnueabi-as -s arm-linux-asln arm-none-linux-gnueabi-c++ -s arm-linux-c++ln arm-none-linux-gnueabi-c++filt -s arm-linux-c++filtln arm-none-linux-gnueabi-cpp -s arm-linux-cppln arm-none-linux-gnueabi-g++ -s arm-linux-g++ln arm-none-linux-gnueabi-gcc -s arm-linux-gccln arm-none-linux-gnueabi-gcc-4.4.1 -s arm-linux-gcc-4.4.1ln arm-none-linux-gnueabi-gcov -s arm-linux-gcovln arm-none-linux-gnueabi-gdb -s arm-linux-gdbln arm-none-linux-gnueabi-gdbtui -s arm-linux-gdbtuiln arm-none-linux-gnueabi-gprof -s arm-linux-gprofln arm-none-linux-gnueabi-ld -s arm-linux-ldln arm-none-linux-gnueabi-nm -s arm-linux-nmln arm-none-linux-gnueabi-objcopy -s arm-linux-objcopyln arm-none-linux-gnueabi-objdump -s arm-linux-objdumpln arm-none-linux-gnueabi-ranlib -s arm-linux-ranlibln arm-none-linux-gnueabi-readelf -s arm-linux-readelfln arm-none-linux-gnueabi-size -s arm-linux-sizeln arm-none-linux-gnueabi-sprite -s arm-linux-spriteln arm-none-linux-gnueabi-strings -s arm-linux-stringsln arm-none-linux-gnueabi-strip -s arm-linux-stripsource make-arm-linux.sh导入环境变量gedit ~/.bashrc打开这个文件，在最下面添加以下一行export PATH=/usr/local/arm/arm-2009q3/bin:$PATHsource ~/.bashrc64位兼容32位如果Ubuntu是64位的1234sudo dpkg --add-architecture i386sudo apt-get updatesudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386sudo ./adb测试在任意路径下敲arm-linux-gcc -v返回信息中含有gcc version 4.4.1表示已经安装成功了注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>交叉编译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NFS服务器搭建]]></title>
    <url>%2Fposts%2FNFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[.基于Ubuntu14.04环境安装sudo apt-get install nfs-kernel-server -y重启service rpcbind restartservice nfs-kernel-server restart建立文件目录mkdir /root/rootfs # 建立根文件目录chmod 777 -R /root/rootfsmkdir /opt #建立访问目录，位置不固定配置sudo vi /etc/exports/root/rootfs *(rw,sync,no_root_squash,no_subtree_check) #在文本最后加上/root/rootfs目录是与nfs服务客户端共享的目录，*代表允许所有的网段访问rw：挂载此目录的客户端对该共享目录具有读写权限sync：资料同步写入内存和硬盘no_root_squash：客户机用root访问该共享文件夹时，不映射root用户(root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户)no_subtree_check：不检查父目录的权限测试sudo exportfs -r #更新文件sudo showmount localhost -e #下面是显示信息Export list for Ubuntu2jmlin:/root/rootfs *本地挂载mount -t nfs -o nolock localhost:/root/rootfs /opt #挂载rootfs目录到/opt目录下注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>NFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS搭建]]></title>
    <url>%2Fposts%2FVPS%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[实验室的海外服务器还有10来天就过期了，趁有点时间就玩一玩！前言：今天去Vultr部署了一个虚拟专用服务器(下面以VPS代指)，一开始系统分配的IP已经被GFW墙了，可是我还抱着一丝轻蔑的态度，想要用远程终端通过代理来登录，折腾了2个小时后觉得不太靠谱，还是把VPS给删除掉，让系统再从新分配一个不同IP的VPS给我。然后马上来这里ping测试一下有没有被墙。幸运的是，我第二次就可以了，不需要通过代理就能用putty来登录VPS。弱弱地吐槽一句，Vultr的网页终端交互能力好弱啊！所部署的VPS参数如下 用了Ubuntu14.04挺久的了，所以玩生不如玩熟！！！一些更新apt-get update &amp;&amp; apt-get upgradeapt-get install gcc g++ # 更新编译器apt-get install aptitudevim系统原生配置的是vi，我习惯用vim就下载一个vim,接着再安装vim的插件apt-get install vimwget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -xSSR这个我就不多做解释了，懂的人懂就好！（奸笑ing）安装123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log一开始要设置密码，之后的都使用默认配置使用命令12345./shadowsocksR.sh uninstall # 卸载/etc/init.d/shadowsocks start # 启动/etc/init.d/shadowsocks stop # 停止/etc/init.d/shadowsocks restart # 重启/etc/init.d/shadowsocks status # 状态文件配置路径123/etc/shadowsocks.json # 配置文件路径/var/log/shadowsocks.log # 日志文件路径/usr/local/shadowsocks # 代码安装目录Database安装mysqlapt-get install mysql-server mysql-client libmysqlclient-dev libmysql-java弹出蓝色框框，输入两次密码登录mysql -u root -pGitapt-get install git -y配置git config --global user.email &quot;eclaboratory@163.com&quot;git config --global user.name &quot;EC-Lab&quot;git config --global credential.helper store # 用于保存用户数据博客环境搭建安装apt-get install npmapg-get install nginx -ynpm install hexo-cli hexo-server -g之后继续补充！注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>Vultr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim之高手进阶篇]]></title>
    <url>%2Fposts%2FVim%E4%B9%8B%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E7%AF%87.html</url>
    <content type="text"><![CDATA[距离上一次发博客也是有一段时间了！在命令模式下移动光标 H(屏幕首行开头) gg(文章首行开头) 0(行首) $(行末) b(前一个单词开头) w(后一个单词开头) e(后一个单词末尾) G(文章末行开头) 从命令模式进入插入模式o &quot; 在当前光标所在行下面插入一行 O &quot; 在当前光标所在行上面插入一行 分屏模式适用于多文件处理横向分屏:sp otherfilename &quot; split 垂直分屏:vsp otherfilename &quot; vertically split 切换Viewport按键作用Ctrl + w -&gt; h移动光标到左边的viewportCtrl + w -&gt; j移动光标到下边的viewportCtrl + w -&gt; k移动光标到上边的viewportCtrl + w -&gt; l移动光标到右边的viewportCtrl + w -&gt; +扩大当前viewportCtrl + w -&gt; -缩小当前viewportCtrl + w -&gt; =重新均匀分配各个viewport的占比Ctrl + w -&gt; r调换各个viewport的位置。用R的话是反向调换Ctrl + w -&gt; q 或c关闭当前viewportCtrl + o 或 :only只保留当前所在viewport字符搜索/ &quot; 顺序查找(n下一个、N上一个) ? &quot; 逆向查找 % &quot; 配对括号查找 字符替换:s/old/new &quot; 只改当前所在行的第一个 :s/old/new/g &quot; 只改当前所在行的所有 :#,#s/old/new/g &quot; #，#表示若干行中首位两行的行号 :%s/old/new/g &quot; 替换整个文件中的每个匹配符 :%s/old/new/gc &quot; 替换整个文件中的每个匹配符， 但会提示是否进行替换 文件合并:r filename &quot; 在光标后插入一个文件的内容 在vim中执行外部shell命令:! shell_command :w FILENAME &quot; 可将当前编辑文件保存FILENAME文件中 v motion :w FILENAME &quot; 可将当前编辑文件中可视模式下选中的内容保存到FILENAME文件中 :read FILENAME &quot; 可提取磁盘文件FILENAME并将其插入到当前文件的光标位置后面 :read ! wc % &quot; 可将文件包含的行数、单词数和字符数输出到当前文件的光标位置后面 :2read ! wc % &quot; 插入到第二行，使用`$`在最后一行插入，`0`在第一行前面插入 保存当前所有打开的文件及其状态:mksession ~/.vim/sessions/your_session_name.vim 还原上次会话法一：:source ~/.vim/sessions/your_session_name.vim法二：vim -S ~/.vim/sessions/your_session_name.vim注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry Pi 3B上手]]></title>
    <url>%2Fposts%2FRaspberry-Pi3%E4%B8%8A%E6%89%8B.html</url>
    <content type="text"><![CDATA[前段时间买了个树莓派3，但一直在忙其它东西，就把它荒废了！今天有时间，折腾就一下注: Raspberry系统为Raspbian 9.1 (Stretch)，如果是其它系统注意操作时的差异查看系统信息如果不知道自己的系统版本的话，可以敲lsb_release -aLog in第一次登陆，默认用户名为pi,密码为raspberry若要登陆root，可以改密码sudo passwd root更换镜像源sudo vi /etc/apt/sources.list 12deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contribdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contribsudo apt-get update sudo apt-get upgrade 安装输入法sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin 更新Vimapt-get remove vim-common apt-get install vim cd ~ // 切换到当前用户根目录 vi .vimrc // 进入文件编辑 1234567set autoindent &quot; 自动缩进set cindentset tabstop=4 &quot; Tab宽度set softtabstop=4 &quot; 同一缩进为4set shiftwidth=4 set expandtab &quot; 使用空格代替制表符set nu &quot; 显示行号source .vimrc 配置WIFI链接文件vi /etc/wpa_supplicant/wpa_supplicant.conf 12345678910111213141516171819country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev # 当前使用interface的socket文件update_config=1ap_scan=2 # 默认值是1，表示优先链接可见WIFI，受优先级影响 # 2，表示按照network定义的顺序链接，不受优先级影响network=&#123;ssid=&quot;Your Router&quot;psk=&quot;Your Passwd&quot;key_mgmt=WPA-PSK # 加密选项priority=6 # 链接优先级 越大越链接&#125;network=&#123;ssid=&quot;Your Router&quot;psk=&quot;Your Passwd&quot;key_mgmt=WPA-PSKpriority=5scan_ssid=1 # 连接隐藏WIFI选项&#125;设置无线网卡静态IPifconfig wlan0 # 记录ether后面的一组数据(如：e8:27:39:sd:ed:66)，后面会用到 vi /etc/dhcpcd.conf 在文件后面添加内容，下面的IP地址要根据自己所连接WIFI的IP地址改动1234interface e8:27:39:sd:ed:66 static ip_address=192.168.0.3/24 static routers=192.168.0.1 static domain_name_servers=192.168.0.2 8.8.8.8reboot root登录sshvi /etc/ssh/sshd_config 123PermitRootLogin prohibit-password改为PermitRootLogin yes防止ssh连接因超时闲置断开vi /etc/ssh/sshd_config 1ClientAliveInterval 60/etc/init.d/ssh restart 注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>树莓派3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot前期准备]]></title>
    <url>%2Fposts%2FUboot%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87.html</url>
    <content type="text"><![CDATA[考虑到大家之前没有学习嵌入式相关的基础知识，我下面会先从构建代码环境讲起，如果之后大家觉得感兴趣的，我也会写其他东西给大家看！如果大家之后有什么疑问可以直接来找我。注： 以下操作均在Windows平台Uboot源码文件源码获取拿到老师给的光盘镜像之后，进入bootloader文件可以看到uboot_TQ210_1.3.4_V1.7.tar.bz2，分别解压两次会得到opt这个文件夹，在解压第二次的时候解压器会报出一些错误，可以忽略它（因为里面有Linux平台下的link类型文件与Windows不兼容）按路径 opt\EmbedSky\TQ210\uboot_TQ210_1.3.4 依次进入到 uboot_TQ210_1.3.4 文件中，此目录在之后的代码分析中，我们称之为uboot的根目录Source Insight 4.0添加uboot源码工程软件安装及其破解下面是Source Insight 4.0的软件下载链接：链接：http://pan.baidu.com/s/1geJWo9d 密码：j9qu阅读那个 readme.txt 文件来破解添加uboot源码工程现在uboot根目录下创建一个文件夹 SI_Project ，名字随便起都行，用于存放等下Source Insight创建工程的文件打开Source Insight软件，在菜单栏点击Project-&gt; New Project标号1是输入将要创建的工程名Uboot1.3.4（自己设置），标号2是选择你电脑uboot的根目录所在的文件夹，然后点击OK标号1是找到刚才在uboot的根目录所创建的文件夹，我刚才创建了文件夹 SI_Project，然后点击OK在Directory栏选择uboot根目录，然后在右边点击 Add ALL把第二个勾上，意思是递归添加子目录文件，然后点击OK等待一下，就可以点击右上角的Close按钮点击标号1右侧打开文件目录，点击标号2，在标号3找到uboot根目录，可以看到右侧的文件就是源码文件及其文件夹一些设置因为之后需要浏览.S文件的汇编代码，所以需要在source insight中进行文件类型的关联依次在菜单栏点击Options-&gt;File Type Options，在出现的窗口左边选择C Source File，在File filterd下添加 *.S，最后点击CloseUboot根目录文件介绍arm_config.mk : 后缀为.mk，是一个Makefile文件，将来在某个Makefile中会调用它3个Changelog文件 : 修改记录文件，该文件记录了这个uboot项目的版本变迁以及每个版本较上一个版本修改的记录。config.mk : 性质同arm_config.mkCOPYING : 版权声明，uboot本身是GPL许可证的CREDITS : 鸣谢，记录了对uboot有贡献的人image_split : 一个脚本MAINTAINERS : 维护者，当前参与维护uboot源码的社区工作者MAKEALL : 一个脚本Makefile : 用于编译整个ubootmk : 快速编译的脚本，即先清理后配置再编译mkconfig ： uboot配置阶段的只要配置脚本，uboot的可移植性很大程度就是靠这个配置脚本在维护mkmovi ： 一个脚本，和inand/SD卡启动有关README : 使用说明书rules.mk : uboot中Makefile使用的规则Uboot根文件夹介绍api : 硬件无关功能函数，uboot移植时不用管api_examples : API相关的测试示例代码board : 存放各种开发板相关的配置文件common : 用于存放一些与具体硬件无关的普遍适用的一些代码。譬如控制台实现、crc校验。但是更多的主要是两类：一类是cmd开头的，是用来实现uboot的命令系统的；另一类是env开头的，是用来实现环境变量的cpu ： 与SOC相关的，里面存放的代码都是SOC相关初始化和控制代码（如：CPU的、中断的、串口的等内部外设，包括起始代码start.S）disk : 磁盘有关doc : 文档目录，英文原档，帮助理解ubootdrivers ： 存放Linux源代码中扣出来原封不动的Linux设备驱动，用于uboot的运行，主要是开发板上一些必须用到的驱动examples : 示例代码fs ： filesystem文件系统，从Linux源代码中移植过来的，用于管理flash等资源include ： 头文件目录lib开头的文件夹 ： 架构相关的库文件 lib_arm(arm架构使用的一些库文件)、lib_generic（所有架构通用的库文件）libfdt ： 设备树有关的，使用设备树来进行启动传参，进行硬件信息的描述nand_spl : nand相关代码net : 网络相关的代码onenand开头 ： onenand相关的代码tools : 一些工具类的代码注：本文内容部分来自互联网整理，部分来自个人经验总结。欢迎留言补充！]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说存储类关键字]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[.存储类关键字（用于修饰变量）auto(自动变量)auto即平时的局部变量关键字，可以省略，故定义局部变量时都没有写分配在内存中的栈上register(寄存器变量)这个不是很常用编译器会将其所修饰的变量尽量分配在寄存器中（使其变量的读写效率会变高）由于寄存器数量有限，关键字所修饰的变量不一定都放在寄存器内static(静态变量)修饰变量修饰全局变量修饰局部变量修饰函数修饰类别形成分配位置生命周期链接属性局部变量静态局部变量数据段/BSS段代码块作用域无链接全局变量静态全局变量数据段/BSS段文件作用域内链接函数静态函数在其声明文件文件作用域内链接extern(外部变量)修饰全局变量，用于文件作用域以外访问const(只读变量)其所修饰的变量存储在只读变量区，在C中仍然是变量（C++中，是只读常量）编译器通常将const保存在符号表中而非分配存储空间，从而节省了空间，提高了效率（例子：函数传参声明为const指针–另外一个就是防止该指针在函数体内被意外修改）就近原则解释const int a;a是常整型数，a不可变const int *a;a是指向一个常整型数的指针，a所指内容不可变int *const a;a是指向一个整型数的常指针，a不可变const int* const a;a是指向一个常整型数的常指针，a及其所指内容都不可变修改const修饰的变量(在GCC环境中)在GCC中，const是通过编译器在编译的时候执行检查来确保实现的(即改const类型变量是编译错误，而非运行时错误)GCC编译器把const类型的变量放在了数据段，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，故只要骗过编译器，const变量就可以修改了。12345const int a = 5;int *p;p = (int *)&amp;a;*p = 6;printf("a = %d. \n", a);volatile(易变变量)用以修饰一个可以被编译器之外改变的变量，告诉编译器不对改变量的访问进行优化编译器之内：当前程序上下文的控制流（即当前代码）编译器之外：中断ISR中引用的变量、多线程中共用的变量、硬件会更改的变量。（编译器在编译时无法预知的更改）typedef(自定义数据类型变量)自定义数据类型（不要与#define相混淆）12typedef int *Pint; const Pint p;typedef int *Pint; Pint const p;以上两个皆相当于 int *const p; 即p皆为常指针很多初学者都很难去记住上面的两个关系，是因为又与#define相混淆了，还没有完全理解typedef这个关键字原理如下：编译器在解析的时候会忽略数据类型，直接修饰p，因此以上两个式子都可以看为 Pint const p;如果实在想不通，就想想 const int i; 和int const i; 为什么是相同的restrict只用于修饰指针；其告知编译器，所有修改该指针所指向内容的操作全部是基于该指针的，即不存在其他进行修改操作的途径看不懂，是不是？其实它的作用就是为了帮助编译器进行更好的代码优化。该关键字用得少，慎用注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>存储类</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说存储类]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB.html</url>
    <content type="text"><![CDATA[.存储类(Storage Class)简单来说，存储类就是C语言中存储变量的地方的类型分为动态存储区，静态存储区动态存储区栈(Stack)其增长方向：自顶向下增长有内存空间的限制存储内容函数形参，在调用函数时给形参分配空间函数内的自动变量（即普通变量）函数调用时的现场保护和返回地址(即函数调用语句的下一句可执行语句)在函数调用开始时分配存储空间，函数结束时释放存储空间函数调用结束时，局部变量先出栈，接着是形参，最后栈指针指向最开始存储的地址来进行下一条指令堆(Heap)程序员自定义存储空间使用后，需要手动释放内存，不然会造成内存泄露静态存储区.data段存放非零全局变量、静态局部变量.bss段(Block Started by Symbol)存放未初始化的全局变量、静态局部变量运行时，由系统初始化，即清零。一般要自己写.ROData(文本常量区)存放字符串常量1char *p="linux"; // 定义了一个分配在栈上占4字节的指针指向了一个分配在文本常量区上占6字节的字符串.text段(代码区)cup执行的机器指令部分(函数体的二进制代码)属性只读，为了防止程序由于意外事故而修改自身指令作用域作用域即变量或函数起作用的范围文件作用域代码作用域生命周期永久临时链接属性链接属性有以下3种：外链接内链接无链接宏定义 和 inline内联函数 链接属性为 无链接总结类型存储类作用域生命周期链接属性普通全局变量.data段/.BSS段文件作用域永久外链接静态全局变量.data段/.BSS段文件作用域永久内链接普通局部变量栈代码作用域临时无链接静态局部变量.data段/.BSS段代码作用域永久无链接普通函数.text段文件作用域永久外链接静态函数.text段文件作用域永久内链接堆与栈的比较类型StackHeap生长方向向地址减小的方向增长向地址增大的方向增长分配方式动态分配与静态分配动态分配碎片问题无此问题过多使用会造成内存不足申请后系统响应无可用空间报异常提示栈溢出系统分配申请的内存到空闲地址链表中分配效率相对高相对低申请大小系统预先规定好大小系统可用内存申请效率相对快相对慢，容易产生内容碎片存储内容看上面一般在堆的头部用1字节存放堆的大小，其他程序员安排存取效率相对快,char s[]=”Hello”;在运行时赋值;数组比指针要快一些相对慢;char *s=”Hello”;在编译时确定最后附上一张内存分布的图片注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>存储类</tag>
        <tag>作用域</tag>
        <tag>生命周期</tag>
        <tag>链接属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim之基础入门篇]]></title>
    <url>%2Fposts%2FVim%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87.html</url>
    <content type="text"><![CDATA[很多人都对vim这货有所敬畏，其实只要多动手，vim是很容易上手的。用了vim大半年了，今天就写个基础入门篇，之后有空再加个高手进阶篇在命令模式下移动光标12345 k(上) h(左) l(右) j(下)从命令模式进入插入模式12a // 光标后插入i // 光标前插入从插入模式进入命令模式1Esc在命令模式下操作复制1yy // 复制光标所在的一行粘贴12p // 粘贴到光标后P // 粘贴到光标前删除1x // 删除光标后的一个字母剪切1dd // 剪切光标所在的一行撤销12u // 撤销上一次操作U // 撤销所在行的所以操作从命令模式进入底线命令模式保存1:w退出1:q // 如果所编辑的文件有更改，则退出失败保存并退出1:wq注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈指针]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E6%8C%87%E9%92%88.html</url>
    <content type="text"><![CDATA[.一级指针指针其实就是存放内存地址的变量，其长度在32位系统上固定为4字节。指针数组数组的存储内容是指针1int *p[];数组指针指向一个数组的指针1int (*p)[];指针函数函数的返回值类型是一个指针类型1234void *pf();/* or */typedef void *pf();pf function(); // 定义实例所以指针函数用于修饰函数返回值函数指针指向一个函数的指针(函数名 与 &amp;函数名 都表示函数运行的首地址)1234void (*fp)();/* or */typedef void (*fp)(int ,char);fp function; // 定义实例二重指针指向一个int*类型的指针1int **p;实例意义int a;&amp;a是一个int *型变量int *p;指针p指向一个int型变量int **p;指针p指向一个int *型变量int a[3]aaa+1&amp;a&amp;a+1int 类型数组首元素首地址(int)a + 1sizeof(int), 地址加4byte即a[1]数组首地址(int)a + 1*sizeof(int[3]), 地址加12byte即a[3]话说大端小端大端：数据的高字节存储在低地址中小端：数据的低字节存储在低地址中代码判断1234567891011union myunion&#123; int a; char b;&#125;;int BigorSmall()&#123; union myunion u1; u1.a = 1; return u1.b; // 地址0的那个字节内是1（小端）或者0（大端）&#125;123456char BigorSmall()&#123; int a = 1; char b = *((char *)(&amp;a)); return b;&#125;指针都是4字节，为什么还要定义指针类型？定义指针类型的好处是：定义一个指针时，编译器为指针所指向的内容定义好大小，无需程序员去管理代码中的变量在内存的情况计算机的内存地址分配原则：内存寻址由大到小，优先分配内存地址较大的空间给变量（从下往上），先定义的变量，分配的地址越大123456789#include&lt;stdio.h&gt;int main()&#123; int a = 2; char c = 1; int *p = &amp;c; // 编译器不会报错，但会有警告，因为指针类型不匹配 printf("%d .\n",*p); return 0;&#125;指针读取数据是箭头从下往上读取，该代码运行结果为513注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>大端小端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说内存对齐]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html</url>
    <content type="text"><![CDATA[颓废了一个多星期，感觉还是要写个博客压压惊！！！为什么会有内存对齐？为了访问未对齐的内存，处理器需要作两次内存访问；而，对齐访问仅需要一次访问。对齐参数32位系统中，默认4字节对齐（32位系统CPU字长是4字节）在Windows(32)/VC6.0下各种数据类型的变量的自身对齐参数就是该数据类型变量所占字节数的大小在Linux(32)/GCC下double类型下的对齐参数为4Linux(32)/GCC下如果该数据类型的长度没有超过CPU的字长，则以该数据类型变量的长度作为自身对齐参数如果超过了CPU字长，则自身对齐参数为CPU字长字节对齐原则结构体每个成员相对结构体首地址的偏移量(offset)是对齐参数(此对齐参数是取每个变量自身对齐参数和系统对齐参数两者中较小的一个)的整数倍，如果有需要会在每个成员之间填充字节编译器在为结构体成员开辟空间时，首先检查预开辟空间的地址相对于结构体首地址的偏移量是否为对齐参数的整数倍，若是，则存放该成员，否则，反之结构体变量所占空间的大小是对齐参数大小的整数倍，如有需要会在最后一个成员末尾填充若干字节使得所占空间是对齐参数 (对结构体中所有变量的对齐参数的最大值和系统默认对齐参数#pragma pack(n)比较，较小者作为对齐参数)的整数倍static修饰的变量所占空间没有被算入，因为其存储在.bss段/.data段内存对齐的关键字GCC推荐的对齐指令123__attribute__((packed)) // 一字节对齐使用时，直接接放在进行内存对齐的类型定义后面，其作用范围为使用该类型定义的变量__attribute__((aligned(n))) // 用法同上，使整个结构体进行n字节的对齐(n为2的幂次方)GCC支持但不推荐的对齐指令123#pragma pack(n) // 放在自定义字节对齐的数据结构开头，指定编译器对齐参数为n字节定义结构体#pragma pack() // 放在自定义字节对齐的数据结构结尾，取消指定对齐参数，恢复缺省参数]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot下烧录Linux内核镜像]]></title>
    <url>%2Fposts%2FUboot%E4%B8%8B%E7%83%A7%E5%BD%95Linux%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F.html</url>
    <content type="text"><![CDATA[本文的操作平台是S5PV210.启动介质(SD卡/iNand/Nand/NorFlash等)烧录镜像进入Uboot命令行12movi read kernel 30008000 // 从启动介质的kernel分区去读取内核镜像到DDR地址为0x30008000处bootm 30008000 // 启动内核tftp烧录镜像虚拟机Ubuntu配置tftp服务器设置Ubuntu静态IP(192.168.1.141)将要烧录的镜像放到Ubuntu的tftp文件夹（/tftpboot）中开发板进入Uboot命令行123set ipaddr 192.168.1.20set gatewayip 192.168.1.1set serverip 192.168.1.141 // 设置为tftp服务器所在平台的IP测试连接1ping 192.168.1.141烧录镜像12tftp 0x30008000 zImage-qt // 将服务器下的zImage-qt镜像下载到DDR地址为0x30008000处bootm 0x30008000 // 启动内核]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置TFTP]]></title>
    <url>%2Fposts%2F%E9%85%8D%E7%BD%AETFTP.html</url>
    <content type="text"><![CDATA[Uboot启动内核镜像，除了在SD卡、Nand等raw分区中启动外，还可以通过tftp从远端服务器获取镜像。下面是配置tftp的过程安装TFTP客户端、服务程序和xinetd12sudo apt-get install tftp-hpa tftpd-hpasudo apt-get install xinetd文件配置配置/etc/xinetd.conf若没有，则创建，然后修改，下同12345678910# Simple configuration file for xinetd##Some defaults, and include /etc/xinetd.d/defaults&#123;#Please note that you need a log_type line to be able to use log_on_success# and log_on_failure. The default is the following :# log_type = SYSLOG daemon info&#125;includedir /etc/xinetd.d配置/etc/default/tftpd-hpa将内容改为12345# /etc/default/tftpd-hpaTFTP_USERNAME=&quot;tftp&quot;TFTP_DIRECTORY=&quot;/tftpboot&quot;TFTP_ADDRESS=&quot;0.0.0.0:69&quot;TFTP_OPTIONS=&quot;-l -c -s&quot;配置/etc/xinetd.d/tftp123456789101112131415service tftp&#123;socket_type = dgramwait = yesdisable = nouser = rootprotocol = udpserver = /usr/sbin/in.tftpdserver_args = -s /tftpboot#log_on_success += PID HOST DURATION#log_on_failure += HOSTper_source = 11cps =100 2flags =IPv4&#125;修改权限创建一个服务器存放文件的文件夹并设置最高权限12sudo mkdir /tftpbootsudo chmod 777 /tftpboot重启服务每次修改完配置文件都需要重启服务123sudo service tftpd-hpa restartsudo /etc/init.d/xinetd reloadsudo /etc/init.d/xinetd restart本地测试在/tftpboot 中新建一个文件file进入另一个文件夹中进入本地tftp命令行下12sudo tftp localhost// 可输入help查看命令和命令作用123get file // 下载文件到当前文件夹 put file // 上传文件到tftp服务器q // 退出tftp命令行非本地关闭防火墙（sudo ufw disable）或 卸载防火墙（sudo apt -get remove iptables）sudo tftp 目标ip地址]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>TFTP</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot启动两个阶段]]></title>
    <url>%2Fposts%2FUboot%E5%90%AF%E5%8A%A8%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5.html</url>
    <content type="text"><![CDATA[.Uboot启动两级阶段第一阶段流程：第二阶段对开发板级别的硬件、软件数据结构进行初始化代码分析1234567891011121314151617181920212223242526272829303132333435start_armboot // 开始arm的启动 // Uboot启动地址0x33e00000 Uboot大小2M 堆大小912KB 栈大小512KB 存放全局数据的结构体 gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t); gd = (gd_t*)gd_base; // 将结构体指针gd实例化（分配空间） init_sequence(); cpu_init(); // 空的，在汇编阶段已经初始化过 board_init(); // 开发板 dm9000_pre_init(); // 网卡初始化 gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE; // 机器码 gd-&gt;bd-&gt;bi_boot_params = (PHYS_SDRAM_1+0x100); // 内存传参（启动参数） interrupt_init(); // 定时器4，用于计时 env_init(); // 环境变量初始化 init_baudrate(); // 软件层gd数据结构波特率初始化 serial_init(); // 空的，在汇编阶段已经初始化过 console_init_f(); // 控制台第一步初始化 display_banner(); // 打印Uboot版本号 print_cpuinfo(); // 打印SOC时钟频率信息 checkboard(); // 检验开发板名字 dram_init(); // 软件层gd数据结构DDR信息初始化 display_dram_config(); // 打印板上DDR内存大小 mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE); // 初始化Uboot所维护的堆内存 mmc_initialize(gd-&gt;bd); // 初始化iNand/SD卡 或 SOC上的控制器 env_relocate (); // 环境变量重定位 gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr ("ipaddr"); // 初始化软件层gd数据结构IP地址 gd-&gt;bd-&gt;bi_enetaddr // 初始化软件层gd数据结构以太网地址 devices_init (); // 参数传递，没有实现驱动初始化 jumptable_init (); // 跳转表 console_init_r (); // 控制台第二步初始化 enable_interrupts (); // 空的 loadaddr、bootfile // 内核启动环境变量读出初始化全局变量 board_late_init (); // 空的 eth_initialize(gd-&gt;bd); // 空的 x210_preboot_init(); // LCD初始化和显示开机logo check_menu_update_from_sd() // 检查自动更新 main_loop() // 主循环区别第一阶段第二阶段语言汇编阶段C阶段代码所在区域SRAMDRAM初始化SoC内部SoC外部Board内部st=>start: Uboot入口 e=>end: 第二阶段 io=>inputoutput: step1=>operation: ENTRY(_start) step2=>operation: 构建异常向量表 step3=>operation: 禁止中断,进入ARM状态,SVC模式 step4=>operation: 设置L2、L1cache和MMU step5=>operation: 识别并暂存启动介质选择 step6=>operation: 第一次设置栈(SRAM)并调用lowlevel_init step7=>operation: 检查复位状态 step8=>operation: 关看门狗 step9=>operation: 供电锁存 step10=>operation: 判断运行地址决定是否初始化时钟和DDR step11=>operation: system_clock_init(时钟初始化) step12=>operation: mem_ctrl_asm_init(DDR初始化) step13=>operation: uart_asm_init(串口初始化并打印'O') step14=>operation: pop {pc} (打印'K') step15=>operation: 第二次设置栈(DDR) step16=>operation: 判断Uboot是否进行Relocate step17=>operation: movi_bl2_copy step18=>operation: 使能域访问 step19=>operation: 设置TTB(转换表基地址) step20=>operation: 使能MMU单元 step21=>operation: 第三次设置栈(DDR) step22=>operation: 清理BSS段 step23=>operation: _start_armboot st(right)->step1->step2->step3 step3->step4->step5->step6 step6->step7->step8->step9 step9->step10->step11->step12 step12->step13->step14->step15 step15->step16->step17->step18->step19->step20 step20->step21->step22->step23(right)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot主目录下的Makefile分析]]></title>
    <url>%2Fposts%2FUboot%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84Makefile%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[本文是针对Uboot1.3.4 for x210来分析的，学习总结之余，也供大家参详！！！uboot version确定（24~29）VERSION:主版本号PATCHLEVEL：次版本号SUBLEVEL：再次版本号EXTRAVERSION:另外附加的版本信息include/version_autogenerated.h文件是编译过程中自动生成的一个文件，里面的内容就是我们在Makefile中配置的uboot的版本号HOSTARCH和HOSTOS（31~41）直接在shell中执行uname -m 得到的就是电脑CPU的版本号获取 HOSTARCH（CPU架构） HOSTOS（主机系统）静默编译（50~54）编译时哦make -s ，-s会作为MAKEFLAGS传给Makefile，因此XECHO变量=echo，即输出空信息单独输出文件夹编译（78~93）make O=输出目录export BUILD_DIR=输出目录，然后make若以上两者都指定了，O=输出目录具有更高的优先级确定OBJTREE、SRCTREE、TOPDIROBJTREE: 存放编译出.o文件目录的根目录，在默认编译下，OBJTREE等于当前目录SRCTREE: 源码目录，源代码的根目录，当前目录TOPDIR: 源码目录定义MKCONFIG变量（101）其值为源码根目录下mkconfig脚本文件，是uboot配置阶段配置脚本include $(obj)include.config.mk(133)include/config.mk不是源码自带的，是配置过程（make x210_sd_config）生成的其内容：12345ARCH = armCPU = s5pc11xBOARD = x210VENDOR = samsungSOC = s5pc110调用MKCONFIG脚本传参（2589）123x210_sd_config : unconfig #依赖为unconfig @$(MKCONFIG) $(@:_config=) arm s5pc11xx 210 samsung s5pc110 #传入参数有6个，$(@:_config=)变为x210_sd @echo &quot;TEXT_BASE = 0xc3e00000&quot; &gt; $(obj)board/samsung/x210/config.mk #创建config.mk文件并添加内容上面代码中的依赖 unconfig其定义在(473) 实现重复配置无报错12345unconfig: @rm -f $(obj)include/config.h $(obj)include/config.mk \ $(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \ $(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep \ $(obj)board/$(VENDOR)/$(BOARD)/config.mkARCH CROSS_COMPILEARCH（133） 定义当前编译的目标CPU的架构CROSS_COMPILE（136~180） 是定义交叉编译工具链的前缀（因为不同芯片所支持的工具链前缀都不一样，而后缀是一样的，这样定义增强程序可移植性）可以在编译时用make CROSS_COMPILE=xxx来实现编译传参覆盖Makefile里面的设置include $(TOPDIR)/config.mk（185）运行其他配置，即进入config.mk文件]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人使用软件]]></title>
    <url>%2Fposts%2FPersonal-Software.html</url>
    <content type="text"><![CDATA[文章不定期更新工欲善其事，必先利其器在网上潜水了几年，由于最近一段时间有点时间，就整理一下自己的东西。这个是软件篇啦！不知道大家对自己电脑系统里的软件的使用度是怎样，我是一个喜欢折腾且无论娱乐、学习、工作都会刻意追求软件精简与效率的人，特别是键盘流，当然了，离大神的距离还有很长很长。这几年大多的国产软件种种的流氓行为（例如弹窗推广、恶意修改用户设置等）显然是被我所厌恶而卸载的。借着博客这个平台，今天我就总结一下自己的软件使用清单。（以下个别软件可能需要科学上网方能下载））装机必备浏览器：Chrome这个就不用我多说了吧？一个软件的强大之处在于其可外接插件，Chrome也不例外，其拓展插件源庞大，但官网下载需要科学上网，不过也可以自己在官网以外的地方找资源。之后我会整理一个自己Chrome所使用的插件列表，可以的话，我也会贡献一下资源。FirefoxFirefox的插件源同样庞大，与Chrome最大的不同是，其自由度较大，可个人定制（前提你喜欢折腾），你懂的！！！下载器：Internet Download Manager大名鼎鼎的IDM，除了不能下载电驴链接，其他都还好，我就不多说了。直接上网盘地址吧。链接: http://pan.baidu.com/s/1wIL8U 密码: egaa迅雷极速版迅雷9有多恶心，大家可能领教过了，网上也有各种的迅雷9剔除广告的补丁。可是，呵呵，我还是想用回迅雷极速版，迅雷于我而言只是一个下载器，我不需要它所提供的其他功能！Resilio Sync一个基于P2P技术的多平台文件共享工具，其文件共享不需要经过云端服务器，所以它不限速、不限文件大小、不需要注册账户 。不过最近一个多月以来，由于一个不可明说但人人知道的原因，导致这个软件抽风了，使很多人都失联了。不过，黑夜中总会有一点曙光的。如果你失联了，点一下这里吧。在这，就再次贡献个链接吧。PDF浏览器：SumatraPDF我用它的原因，主要是它体积足够迷你，且启动速度快，非常适合在平板上使用。其实如果你有注意到，在我推荐的其它软件中大部分的体积都是十分迷人的！哈哈哈Foxit在我的笔记本电脑中，我浏览PDF主要是用Foxit的，其界面还可以，不过吸引我的主要是它的侧面工具栏，十分方便！图片浏览器：IrfanView 体积迷你，启动速度快。很多时候对图片只是想单纯的浏览，而不想要其它不必要的功能！云盘：百度网盘我就不想多说了，相信大家都知道。Google Drive15G免费的云储存空间试用，不过受墙的影响，想用就自己想办法了。如果想不用钱又大空间存储的话，貌似只有百度云盘了。系统篇优化：Advanced Systemcare一个国外优化软件，由于伟大的￥G*F·W#，软件在大陆境内不能实现自动升级，所以需要科学上网。另外软件需要注册码，大家有条件的就支持一下正版吧。如果是学生党可以去百度贴吧那里搜刮一下注册码。在这我就贡献一下自己的注册码。5F90C-4A11F-1BD01-DAC74Process Lasso一个系统进程优先级优化软件，软件默认的设置已经帮我们优化好了，如果不是特别懂，最好不要改动里面的默认设置。Adguard可以拦截很多桌面上弹出的广告，且软件支持自定义安装各种拦截插件。杀毒：火绒 堪称国产良心，我喜欢它的弹窗拦截，除了比它默认拦截的弹窗之外，有其它弹窗时，按一下Alt + Shift + A(软件默认的，可以自己改)选择要剔除的弹窗，然后你就真的永远见不到那个弹窗了，废话不多说，自己试过才知道。解压：7-Zip 体积迷人，高压缩比率，极客必备。效率：AutoHotKey一个脚本解释语言，解释器本身体积非常小，然后自己写要运行的脚本。当然了，网上也有很多已经写好的脚本，自己可以按需求去发现。一句话就是： 只要你会用，它无所不能。在此附上一个教程Wox一款快速启动的软件，速度快的，体积迷你。文件搜索配合Everything使用，效果更佳。Everything是一款文件搜索软件，比Windows自带的文件搜索快太多太多了。Listary其效果就等于 Wox + Everything，至于用哪个就看个人喜好吧！附上一个教程Seer一款文件预览软件，体积迷你，按个Space键，可以预览文件信息，其所支持的文件格式十分多，例如可以支持C、Java等编程语言文件的语法高亮预览；还有歌曲的预览、PPT、PDF等格式文件的预览，十分方便，启动速度也很快。F.lux一个护眼软件，作者已经多年没有更新了。不过功能够用。我本人十分喜欢它的夜间模式，即使周围没有光线，电脑屏幕也不刺眼。MacType把Windows不顺眼的字体风格渲染成Mac Book的字体画风。因为可以选择注册表方式加载，所以就不会拖慢电脑开机速度FileNote当文件繁多的时候(例如自己不熟悉的软件或一些不可备注的压缩包)，经常会不知道当前的文件要来干嘛的，此时可以使用FileNote对文件的用途进行备注，下次一看就知道这个文件是用来干嘛的了。Ditto一个剪切板工具，可保存最近的剪切记录或实现跨电脑跨平台剪切复制，且其所剪切的记录不单单是文本，也可以是图片、HTML等。网上有很多关于Ditto的使用技巧，我就不一一罗列了学习&amp;工作篇笔记：Leanote又称蚂蚁笔记，一款集笔记、博客、协作、私有云的笔记。其实，我之前是一直在用印象笔记的，碍于其对markdown语法支持一般，所以我就转入了Leanote，再者，蚂蚁笔记的主题自己改一下还是挺好看的。不过有一点还不太好，就是蚂蚁笔记现在还不支持对文章的加密，有点小小的遗憾！EverNote分为国际版(EverNote)、国内版(印象笔记)，两个的数据库是不相连接的。所以如果要使用，记得区分好，我一开始使用的时候就掉到了这个坑里。哈哈哈翻译：Lingoes 文本翻译软件，功能还算全面，支持屏幕取词，划词翻译。不要问我为什么不用有道笔记，我不会告诉你是因为它经常弹窗骚扰的！SSH：PuttyWindows下对Unix系统的远程控制终端，体积迷你。WinSCP一款开源的SFTP客户端。我的用途就是远程登录云端服务器。文本编辑器：gVimWindows平台下的Vim，在Linux下玩久了，回到Windows不习惯的话，可以试试它。Sublime Text 3前端程序员必备，它拥有庞大的插件源，因此可以拓展许多炫酷实用的功能。反正我现在都是用它来写博客的。Notepad++一个程序员自由开发文本编辑软件。文本比较：Beyond Compare 一个文本内容比较软件，我就不多说了。科学上网篇:XX-Net 它是GitHub上一个开源的项目，相对于其他科学上网的VPN，xx-net是十分彪悍稳定的，当然天下没有免费的午餐，不想做小白就要自己一步一步地配置，配置过程可能有点小长。所以，怕折腾者勿点教程娱乐篇视频播放器：Potplayer 拥有KMPlayer的硬件加速，界面简洁且功能强大，支持格式众多。音乐播放器：Mcool一个短小精悍的本地音乐播放器。网易云音乐喜欢它，主要是网易云的云端歌曲推送真心不错。桌面美化：火萤动态桌面，工作疲累时，看一看，还是挺恰意的。没有最好的软件，只有最适合自己的软件以上所列举的软件是我所用过的软件，如果你有更好的软件，也可以推荐我一下！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>优雅</tag>
        <tag>极客</tag>
        <tag>效率</tag>
        <tag>必备</tag>
        <tag>win10</tag>
        <tag>干货</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2Fposts%2FWTF.html</url>
    <content type="text"><![CDATA[闻道有先后，术业有专攻，如是而已最近有点时间，所以就花了两天的时间搭建了这个博客。有人问我，你浪费那么多时间搭建这个博客，要来干嘛用？说实话，有时候挺怕遇到这种不太开明的朋友的。搭建一个博客于我而言，是一个个人言论空间（相对网络上很多著名的言论平台，自己发的帖不会被平台随意删除）。另外，我是一个比较爱折腾（你可以说我犯贱）的人，搭建博客对我这种菜鸟而言是一个提高的机会。因为最近半年多都在学习ARM Linux，所以最近一段时间会把这半年来学的东西总结一下。另外，对于51单片机、STM32、ZigBee、WiFi，后期如果有时间我也会总结一下！！！当然了，时不时我还是会附送一点小干货的！！！博客刚开始搭建起来，很多细节还不是做得很好！！！见谅啊！！！]]></content>
  </entry>
</search>
