<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Uboot前期准备]]></title>
    <url>%2Fposts%2FUboot%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87.html</url>
    <content type="text"><![CDATA[考虑到大家之前没有学习嵌入式相关的基础知识，我下面会先从构建代码环境讲起，如果之后大家觉得感兴趣的，我也会写其他东西给大家看！如果大家之后有什么疑问可以直接来找我。注： 以下操作均在Windows平台Uboot源码文件源码获取拿到老师给的光盘镜像之后，进入bootloader文件可以看到uboot_TQ210_1.3.4_V1.7.tar.bz2，分别解压两次会得到opt这个文件夹，在解压第二次的时候解压器会报出一些错误，可以忽略它（因为里面有Linux平台下的link类型文件与Windows不兼容）按路径 opt\EmbedSky\TQ210\uboot_TQ210_1.3.4 依次进入到 uboot_TQ210_1.3.4 文件中，此目录在之后的代码分析中，我们称之为uboot的根目录Source Insight 4.0添加uboot源码工程软件安装及其破解下面是Source Insight 4.0的软件下载链接：链接：http://pan.baidu.com/s/1geJWo9d 密码：j9qu阅读那个 readme.txt 文件来破解添加uboot源码工程现在uboot根目录下创建一个文件夹 SI_Project ，名字随便起都行，用于存放等下Source Insight创建工程的文件打开Source Insight软件，在菜单栏点击Project-&gt; New Project标号1是输入将要创建的工程名Uboot1.3.4（自己设置），标号2是选择你电脑uboot的根目录所在的文件夹，然后点击OK标号1是找到刚才在uboot的根目录所创建的文件夹，我刚才创建了文件夹 SI_Project，然后点击OK在Directory栏选择uboot根目录，然后在右边点击 Add ALL把第二个勾上，意思是递归添加子目录文件，然后点击OK等待一下，就可以点击右上角的Close按钮点击标号1右侧打开文件目录，点击标号2，在标号3找到uboot根目录，可以看到右侧的文件就是源码文件及其文件夹Uboot根目录文件介绍arm_config.mk : 后缀为.mk，是一个Makefile文件，将来在某个Makefile中会调用它3个Changelog文件 : 修改记录文件，该文件记录了这个uboot项目的版本变迁以及每个版本较上一个版本修改的记录。config.mk : 性质同arm_config.mkCOPYING : 版权声明，uboot本身是GPL许可证的CREDITS : 鸣谢，记录了对uboot有贡献的人image_split : 一个脚本MAINTAINERS : 维护者，当前参与维护uboot源码的社区工作者MAKEALL : 一个脚本Makefile : 用于编译整个ubootmk : 快速编译的脚本，即先清理后配置再编译mkconfig ： uboot配置阶段的只要配置脚本，uboot的可移植性很大程度就是靠这个配置脚本在维护mkmovi ： 一个脚本，和inand/SD卡启动有关README : 使用说明书rules.mk : uboot中Makefile使用的规则Uboot根文件夹介绍api : 硬件无关功能函数，uboot移植时不用管api_examples : API相关的测试示例代码board : 存放各种开发板相关的配置文件common : 用于存放一些与具体硬件无关的普遍适用的一些代码。譬如控制台实现、crc校验。但是更多的主要是两类：一类是cmd开头的，是用来实现uboot的命令系统的；另一类是env开头的，是用来实现环境变量的cpu ： 与SOC相关的，里面存放的代码都是SOC相关初始化和控制代码（如：CPU的、中断的、串口的等内部外设，包括起始代码start.S）disk : 磁盘有关doc : 文档目录，英文原档，帮助理解ubootdrivers ： 存放Linux源代码中扣出来原封不动的Linux设备驱动，用于uboot的运行，主要是开发板上一些必须用到的驱动examples : 示例代码fs ： filesystem文件系统，从Linux源代码中移植过来的，用于管理flash等资源include ： 头文件目录lib开头的文件夹 ： 架构相关的库文件 lib_arm(arm架构使用的一些库文件)、lib_generic（所有架构通用的库文件）libfdt ： 设备树有关的，使用设备树来进行启动传参，进行硬件信息的描述nand_spl : nand相关代码net : 网络相关的代码onenand开头 ： onenand相关的代码tools : 一些工具类的代码注：本文内容部分来自互联网整理，部分来自个人经验总结。欢迎留言补充！]]></content>
  </entry>
  <entry>
    <title><![CDATA[话说存储类关键字]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[.存储类关键字（用于修饰变量）auto(自动变量)auto即平时的局部变量关键字，可以省略，故定义局部变量时都没有写分配在内存中的栈上register(寄存器变量)这个不是很常用编译器会将其所修饰的变量尽量分配在寄存器中（使其变量的读写效率会变高）由于寄存器数量有限，关键字所修饰的变量不一定都放在寄存器内static(静态变量)修饰变量修饰全局变量修饰局部变量修饰函数修饰类别形成分配位置生命周期链接属性局部变量静态局部变量数据段/BSS段代码块作用域无链接全局变量静态全局变量数据段/BSS段文件作用域内链接函数静态函数在其声明文件文件作用域内链接extern(外部变量)修饰全局变量，用于文件作用域以外访问const(只读变量)其所修饰的变量存储在只读变量区，在C中仍然是变量（C++中，是只读常量）编译器通常将const保存在符号表中而非分配存储空间，从而节省了空间，提高了效率（例子：函数传参声明为const指针–另外一个就是防止该指针在函数体内被意外修改）就近原则解释const int a;a是常整型数，a不可变const int *a;a是指向一个常整型数的指针，a所指内容不可变int *const a;a是指向一个整型数的常指针，a不可变const int* const a;a是指向一个常整型数的常指针，a及其所指内容都不可变修改const修饰的变量(在GCC环境中)在GCC中，const是通过编译器在编译的时候执行检查来确保实现的(即改const类型变量是编译错误，而非运行时错误)GCC编译器把const类型的变量放在了数据段，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，故只要骗过编译器，const变量就可以修改了。12345const int a = 5;int *p;p = (int *)&amp;a;*p = 6;printf("a = %d. \n", a);volatile(易变变量)用以修饰一个可以被编译器之外改变的变量，告诉编译器不对改变量的访问进行优化编译器之内：当前程序上下文的控制流（即当前代码）编译器之外：中断ISR中引用的变量、多线程中共用的变量、硬件会更改的变量。（编译器在编译时无法预知的更改）typedef(自定义数据类型变量)自定义数据类型（不要与#define相混淆）12typedef int *Pint; const Pint p;typedef int *Pint; Pint const p;以上两个皆相当于 int *const p; 即p皆为常指针很多初学者都很难去记住上面的两个关系，是因为又与#define相混淆了，还没有完全理解typedef这个关键字原理如下：编译器在解析的时候会忽略数据类型，直接修饰p，因此以上两个式子都可以看为 Pint const p;如果实在想不通，就想想 const int i; 和int const i; 为什么是相同的restrict只用于修饰指针；其告知编译器，所有修改该指针所指向内容的操作全部是基于该指针的，即不存在其他进行修改操作的途径看不懂，是不是？其实它的作用就是为了帮助编译器进行更好的代码优化。该关键字用得少，慎用注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>存储类</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说存储类]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB.html</url>
    <content type="text"><![CDATA[.存储类(Storage Class)简单来说，存储类就是C语言中存储变量的地方的类型分为动态存储区，静态存储区动态存储区栈(Stack)其增长方向：自顶向下增长有内存空间的限制存储内容函数形参，在调用函数时给形参分配空间函数内的自动变量（即普通变量）函数调用时的现场保护和返回地址(即函数调用语句的下一句可执行语句)在函数调用开始时分配存储空间，函数结束时释放存储空间函数调用结束时，局部变量先出栈，接着是形参，最后栈指针指向最开始存储的地址来进行下一条指令堆(Heap)程序员自定义存储空间使用后，需要手动释放内存，不然会造成内存泄露静态存储区.data段存放非零全局变量、静态局部变量.bss段(Block Started by Symbol)存放未初始化的全局变量、静态局部变量运行时，由系统初始化，即清零。一般要自己写.ROData(文本常量区)存放字符串常量1char *p="linux"; // 定义了一个分配在栈上占4字节的指针指向了一个分配在文本常量区上占6字节的字符串.text段(代码区)cup执行的机器指令部分(函数体的二进制代码)属性只读，为了防止程序由于意外事故而修改自身指令作用域作用域即变量或函数起作用的范围文件作用域代码作用域生命周期永久临时链接属性链接属性有以下3种：外链接内链接无链接宏定义 和 inline内联函数 链接属性为 无链接总结类型存储类作用域生命周期链接属性普通全局变量.data段/.BSS段文件作用域永久外链接静态全局变量.data段/.BSS段文件作用域永久内链接普通局部变量栈代码作用域临时无链接静态局部变量.data段/.BSS段代码作用域永久无链接普通函数.text段文件作用域永久外链接静态函数.text段文件作用域永久内链接堆与栈的比较类型StackHeap生长方向向地址减小的方向增长向地址增大的方向增长分配方式动态分配与静态分配动态分配碎片问题无此问题过多使用会造成内存不足申请后系统响应无可用空间报异常提示栈溢出系统分配申请的内存到空闲地址链表中分配效率相对高相对低申请大小系统预先规定好大小系统可用内存申请效率相对快相对慢，容易产生内容碎片存储内容看上面一般在堆的头部用1字节存放堆的大小，其他程序员安排存取效率相对快,char s[]=”Hello”;在运行时赋值;数组比指针要快一些相对慢;char *s=”Hello”;在编译时确定最后附上一张内存分布的图片注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>存储类</tag>
        <tag>作用域</tag>
        <tag>生命周期</tag>
        <tag>链接属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim之基础入门篇]]></title>
    <url>%2Fposts%2FVim%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87.html</url>
    <content type="text"><![CDATA[很多人都对vim这货有所敬畏，其实只要多动手，vim是很容易上手的。用了vim大半年了，今天就写个基础入门篇，之后有空再加个高手进阶篇在命令模式下移动光标12345 k(上) h(左) l(右) j(下)从命令模式进入插入模式12a // 光标后插入i // 光标前插入从插入模式进入命令模式1Esc在命令模式下操作复制1yy // 复制光标所在的一行粘贴12p // 粘贴到光标后P // 粘贴到光标前删除1x // 删除光标后的一个字母剪切1dd // 剪切光标所在的一行撤销12u // 撤销上一次操作U // 撤销所在行的所以操作从命令模式进入底线命令模式保存1:w退出1:q // 如果所编辑的文件有更改，则退出失败保存并退出1:wq注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈指针]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E6%8C%87%E9%92%88.html</url>
    <content type="text"><![CDATA[.一级指针指针其实就是存放内存地址的变量，其长度在32位系统上固定为4字节。指针数组数组的存储内容是指针1int *p[];数组指针指向一个数组的指针1int (*p)[];指针函数函数的返回值类型是一个指针类型1234void *pf();/* or */typedef void *pf();pf function(); // 定义实例所以指针函数用于修饰函数返回值函数指针指向一个函数的指针(函数名 与 &amp;函数名 都表示函数运行的首地址)1234void (*fp)();/* or */typedef void (*fp)(int ,char);fp function; // 定义实例二重指针指向一个int*类型的指针1int **p;实例意义int a;&amp;a是一个int *型变量int *p;指针p指向一个int型变量int **p;指针p指向一个int *型变量int a[3]aaa+1&amp;a&amp;a+1int 类型数组首元素首地址(int)a + 1sizeof(int), 地址加4byte即a[1]数组首地址(int)a + 1*sizeof(int[3]), 地址加12byte即a[3]话说大端小端大端：数据的高字节存储在低地址中小端：数据的低字节存储在低地址中代码判断1234567891011union myunion&#123; int a; char b;&#125;;int BigorSmall()&#123; union myunion u1; u1.a = 1; return u1.b; // 地址0的那个字节内是1（小端）或者0（大端）&#125;123456char BigorSmall()&#123; int a = 1; char b = *((char *)(&amp;a)); return b;&#125;指针都是4字节，为什么还要定义指针类型？定义指针类型的好处是：定义一个指针时，编译器为指针所指向的内容定义好大小，无需程序员去管理代码中的变量在内存的情况计算机的内存地址分配原则：内存寻址由大到小，优先分配内存地址较大的空间给变量（从下往上），先定义的变量，分配的地址越大123456789#include&lt;stdio.h&gt;int main()&#123; int a = 2; char c = 1; int *p = &amp;c; // 编译器不会报错，但会有警告，因为指针类型不匹配 printf("%d .\n",*p); return 0;&#125;指针读取数据是箭头从下往上读取，该代码运行结果为513注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>大端小端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说内存对齐]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html</url>
    <content type="text"><![CDATA[颓废了一个多星期，感觉还是要写个博客压压惊！！！为什么会有内存对齐？为了访问未对齐的内存，处理器需要作两次内存访问；而，对齐访问仅需要一次访问。对齐参数32位系统中，默认4字节对齐（32位系统CPU字长是4字节）在Windows(32)/VC6.0下各种数据类型的变量的自身对齐参数就是该数据类型变量所占字节数的大小在Linux(32)/GCC下double类型下的对齐参数为4Linux(32)/GCC下如果该数据类型的长度没有超过CPU的字长，则以该数据类型变量的长度作为自身对齐参数如果超过了CPU字长，则自身对齐参数为CPU字长字节对齐原则结构体每个成员相对结构体首地址的偏移量(offset)是对齐参数(此对齐参数是取每个变量自身对齐参数和系统对齐参数两者中较小的一个)的整数倍，如果有需要会在每个成员之间填充字节编译器在为结构体成员开辟空间时，首先检查预开辟空间的地址相对于结构体首地址的偏移量是否为对齐参数的整数倍，若是，则存放该成员，否则，反之结构体变量所占空间的大小是对齐参数大小的整数倍，如有需要会在最后一个成员末尾填充若干字节使得所占空间是对齐参数 (对结构体中所有变量的对齐参数的最大值和系统默认对齐参数#pragma pack(n)比较，较小者作为对齐参数)的整数倍static修饰的变量所占空间没有被算入，因为其存储在.bss段/.data段内存对齐的关键字GCC推荐的对齐指令123__attribute__((packed)) // 一字节对齐使用时，直接接放在进行内存对齐的类型定义后面，其作用范围为使用该类型定义的变量__attribute__((aligned(n))) // 用法同上，使整个结构体进行n字节的对齐(n为2的幂次方)GCC支持但不推荐的对齐指令123#pragma pack(n) // 放在自定义字节对齐的数据结构开头，指定编译器对齐参数为n字节定义结构体#pragma pack() // 放在自定义字节对齐的数据结构结尾，取消指定对齐参数，恢复缺省参数]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot下烧录Linux内核镜像]]></title>
    <url>%2Fposts%2FUboot%E4%B8%8B%E7%83%A7%E5%BD%95Linux%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F.html</url>
    <content type="text"><![CDATA[本文的操作平台是S5PV210.启动介质(SD卡/iNand/Nand/NorFlash等)烧录镜像进入Uboot命令行12movi read kernel 30008000 // 从启动介质的kernel分区去读取内核镜像到DDR地址为0x30008000处bootm 30008000 // 启动内核tftp烧录镜像虚拟机Ubuntu配置tftp服务器设置Ubuntu静态IP(192.168.1.141)将要烧录的镜像放到Ubuntu的tftp文件夹（/tftpboot）中开发板进入Uboot命令行123set ipaddr 192.168.1.20set gatewayip 192.168.1.1set serverip 192.168.1.141 // 设置为tftp服务器所在平台的IP测试连接1ping 192.168.1.141烧录镜像12tftp 0x30008000 zImage-qt // 将服务器下的zImage-qt镜像下载到DDR地址为0x30008000处bootm 0x30008000 // 启动内核]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置TFTP]]></title>
    <url>%2Fposts%2F%E9%85%8D%E7%BD%AETFTP.html</url>
    <content type="text"><![CDATA[Uboot启动内核镜像，除了在SD卡、Nand等raw分区中启动外，还可以通过tftp从远端服务器获取镜像。下面是配置tftp的过程安装TFTP客户端、服务程序和xinetd12sudo apt-get install tftp-hpa tftpd-hpasudo apt-get install xinetd文件配置配置/etc/xinetd.conf若没有，则创建，然后修改，下同12345678910# Simple configuration file for xinetd##Some defaults, and include /etc/xinetd.d/defaults&#123;#Please note that you need a log_type line to be able to use log_on_success# and log_on_failure. The default is the following :# log_type = SYSLOG daemon info&#125;includedir /etc/xinetd.d配置/etc/default/tftpd-hpa将内容改为12345# /etc/default/tftpd-hpaTFTP_USERNAME=&quot;tftp&quot;TFTP_DIRECTORY=&quot;/tftpboot&quot;TFTP_ADDRESS=&quot;0.0.0.0:69&quot;TFTP_OPTIONS=&quot;-l -c -s&quot;配置/etc/xinetd.d/tftp123456789101112131415service tftp&#123;socket_type = dgramwait = yesdisable = nouser = rootprotocol = udpserver = /usr/sbin/in.tftpdserver_args = -s /tftpboot#log_on_success += PID HOST DURATION#log_on_failure += HOSTper_source = 11cps =100 2flags =IPv4&#125;修改权限创建一个服务器存放文件的文件夹并设置最高权限12sudo mkdir /tftpbootsudo chmod 777 /tftpboot重启服务每次修改完配置文件都需要重启服务123sudo service tftpd-hpa restartsudo /etc/init.d/xinetd reloadsudo /etc/init.d/xinetd restart本地测试在/tftpboot 中新建一个文件file进入另一个文件夹中进入本地tftp命令行下12sudo tftp localhost// 可输入help查看命令和命令作用123get file // 下载文件到当前文件夹 put file // 上传文件到tftp服务器q // 退出tftp命令行非本地关闭防火墙（sudo ufw disable）或 卸载防火墙（sudo apt -get remove iptables）sudo tftp 目标ip地址]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>TFTP</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot启动两个阶段]]></title>
    <url>%2Fposts%2FUboot%E5%90%AF%E5%8A%A8%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5.html</url>
    <content type="text"><![CDATA[.Uboot启动两级阶段第一阶段流程：第二阶段对开发板级别的硬件、软件数据结构进行初始化代码分析1234567891011121314151617181920212223242526272829303132333435start_armboot // 开始arm的启动 // Uboot启动地址0x33e00000 Uboot大小2M 堆大小912KB 栈大小512KB 存放全局数据的结构体 gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t); gd = (gd_t*)gd_base; // 将结构体指针gd实例化（分配空间） init_sequence(); cpu_init(); // 空的，在汇编阶段已经初始化过 board_init(); // 开发板 dm9000_pre_init(); // 网卡初始化 gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE; // 机器码 gd-&gt;bd-&gt;bi_boot_params = (PHYS_SDRAM_1+0x100); // 内存传参（启动参数） interrupt_init(); // 定时器4，用于计时 env_init(); // 环境变量初始化 init_baudrate(); // 软件层gd数据结构波特率初始化 serial_init(); // 空的，在汇编阶段已经初始化过 console_init_f(); // 控制台第一步初始化 display_banner(); // 打印Uboot版本号 print_cpuinfo(); // 打印SOC时钟频率信息 checkboard(); // 检验开发板名字 dram_init(); // 软件层gd数据结构DDR信息初始化 display_dram_config(); // 打印板上DDR内存大小 mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE); // 初始化Uboot所维护的堆内存 mmc_initialize(gd-&gt;bd); // 初始化iNand/SD卡 或 SOC上的控制器 env_relocate (); // 环境变量重定位 gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr ("ipaddr"); // 初始化软件层gd数据结构IP地址 gd-&gt;bd-&gt;bi_enetaddr // 初始化软件层gd数据结构以太网地址 devices_init (); // 参数传递，没有实现驱动初始化 jumptable_init (); // 跳转表 console_init_r (); // 控制台第二步初始化 enable_interrupts (); // 空的 loadaddr、bootfile // 内核启动环境变量读出初始化全局变量 board_late_init (); // 空的 eth_initialize(gd-&gt;bd); // 空的 x210_preboot_init(); // LCD初始化和显示开机logo check_menu_update_from_sd() // 检查自动更新 main_loop() // 主循环区别第一阶段第二阶段语言汇编阶段C阶段代码所在区域SRAMDRAM初始化SoC内部SoC外部Board内部st=>start: Uboot入口 e=>end: 第二阶段 io=>inputoutput: step1=>operation: ENTRY(_start) step2=>operation: 构建异常向量表 step3=>operation: 禁止中断,进入ARM状态,SVC模式 step4=>operation: 设置L2、L1cache和MMU step5=>operation: 识别并暂存启动介质选择 step6=>operation: 第一次设置栈(SRAM)并调用lowlevel_init step7=>operation: 检查复位状态 step8=>operation: 关看门狗 step9=>operation: 供电锁存 step10=>operation: 判断运行地址决定是否初始化时钟和DDR step11=>operation: system_clock_init(时钟初始化) step12=>operation: mem_ctrl_asm_init(DDR初始化) step13=>operation: uart_asm_init(串口初始化并打印'O') step14=>operation: pop {pc} (打印'K') step15=>operation: 第二次设置栈(DDR) step16=>operation: 判断Uboot是否进行Relocate step17=>operation: movi_bl2_copy step18=>operation: 使能域访问 step19=>operation: 设置TTB(转换表基地址) step20=>operation: 使能MMU单元 step21=>operation: 第三次设置栈(DDR) step22=>operation: 清理BSS段 step23=>operation: _start_armboot st(right)->step1->step2->step3 step3->step4->step5->step6 step6->step7->step8->step9 step9->step10->step11->step12 step12->step13->step14->step15 step15->step16->step17->step18->step19->step20 step20->step21->step22->step23(right)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot主目录下的Makefile分析]]></title>
    <url>%2Fposts%2FUboot%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84Makefile%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[本文是针对Uboot1.3.4 for x210来分析的，学习总结之余，也供大家参详！！！uboot version确定（24~29）VERSION:主版本号PATCHLEVEL：次版本号SUBLEVEL：再次版本号EXTRAVERSION:另外附加的版本信息include/version_autogenerated.h文件是编译过程中自动生成的一个文件，里面的内容就是我们在Makefile中配置的uboot的版本号HOSTARCH和HOSTOS（31~41）直接在shell中执行uname -m 得到的就是电脑CPU的版本号获取 HOSTARCH（CPU架构） HOSTOS（主机系统）静默编译（50~54）编译时哦make -s ，-s会作为MAKEFLAGS传给Makefile，因此XECHO变量=echo，即输出空信息单独输出文件夹编译（78~93）make O=输出目录export BUILD_DIR=输出目录，然后make若以上两者都指定了，O=输出目录具有更高的优先级确定OBJTREE、SRCTREE、TOPDIROBJTREE: 存放编译出.o文件目录的根目录，在默认编译下，OBJTREE等于当前目录SRCTREE: 源码目录，源代码的根目录，当前目录TOPDIR: 源码目录定义MKCONFIG变量（101）其值为源码根目录下mkconfig脚本文件，是uboot配置阶段配置脚本include $(obj)include.config.mk(133)include/config.mk不是源码自带的，是配置过程（make x210_sd_config）生成的其内容：12345ARCH = armCPU = s5pc11xBOARD = x210VENDOR = samsungSOC = s5pc110调用MKCONFIG脚本传参（2589）123x210_sd_config : unconfig #依赖为unconfig @$(MKCONFIG) $(@:_config=) arm s5pc11xx 210 samsung s5pc110 #传入参数有6个，$(@:_config=)变为x210_sd @echo &quot;TEXT_BASE = 0xc3e00000&quot; &gt; $(obj)board/samsung/x210/config.mk #创建config.mk文件并添加内容上面代码中的依赖 unconfig其定义在(473) 实现重复配置无报错12345unconfig: @rm -f $(obj)include/config.h $(obj)include/config.mk \ $(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \ $(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep \ $(obj)board/$(VENDOR)/$(BOARD)/config.mkARCH CROSS_COMPILEARCH（133） 定义当前编译的目标CPU的架构CROSS_COMPILE（136~180） 是定义交叉编译工具链的前缀（因为不同芯片所支持的工具链前缀都不一样，而后缀是一样的，这样定义增强程序可移植性）可以在编译时用make CROSS_COMPILE=xxx来实现编译传参覆盖Makefile里面的设置include $(TOPDIR)/config.mk（185）运行其他配置，即进入config.mk文件]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人使用软件]]></title>
    <url>%2Fposts%2FPersonal-Software.html</url>
    <content type="text"><![CDATA[文章不定期更新工欲善其事，必先利其器在网上潜水了几年，由于最近一段时间有点时间，就整理一下自己的东西。这个是软件篇啦！不知道大家对自己电脑系统里的软件的使用度是怎样，我是一个喜欢折腾且无论娱乐、学习、工作都会刻意追求软件精简与效率的人，特别是键盘流，当然了，离大神的距离还有很长很长。这几年大多的国产软件种种的流氓行为（例如弹窗推广、恶意修改用户设置等）显然是被我所厌恶而卸载的。借着博客这个平台，今天我就总结一下自己的软件使用清单。（以下个别软件可能需要科学上网方能下载））装机必备浏览器：Chrome这个就不用我多说了吧？一个软件的强大之处在于其可外接插件，Chrome也不例外，其拓展插件源庞大，但官网下载需要科学上网，不过也可以自己在官网以外的地方找资源。之后我会整理一个自己Chrome所使用的插件列表，可以的话，我也会贡献一下资源。FirefoxFirefox的插件源同样庞大，与Chrome最大的不同是，其自由度较大，可个人定制（前提你喜欢折腾），你懂的！！！下载器：Internet Download Manager大名鼎鼎的IDM，除了不能下载电驴链接，其他都还好，我就不多说了。直接上网盘地址吧。链接: http://pan.baidu.com/s/1wIL8U 密码: egaa迅雷极速版迅雷9有多恶心，大家可能领教过了，网上也有各种的迅雷9剔除广告的补丁。可是，呵呵，我还是想用回迅雷极速版，迅雷于我而言只是一个下载器，我不需要它所提供的其他功能！Resilio Sync一个基于P2P技术的多平台文件共享工具，其文件共享不需要经过云端服务器，所以它不限速、不限文件大小、不需要注册账户 。不过最近一个多月以来，由于一个不可明说但人人知道的原因，导致这个软件抽风了，使很多人都失联了。不过，黑夜中总会有一点曙光的。如果你失联了，点一下这里吧。在这，就再次贡献个链接吧。PDF浏览器：SumatraPDF我用它的原因，主要是它体积足够迷你，且启动速度快，非常适合在平板上使用。其实如果你有注意到，在我推荐的其它软件中大部分的体积都是十分迷人的！哈哈哈Foxit在我的笔记本电脑中，我浏览PDF主要是用Foxit的，其界面还可以，不过吸引我的主要是它的侧面工具栏，十分方便！图片浏览器：IrfanView体积迷你，启动速度快。很多时候对图片只是想单纯的浏览，而不想要其它不必要的功能！云盘：百度网盘我就不想多说了，相信大家都知道。Google Drive15G免费的云储存空间试用，不过受墙的影响，想用就自己想办法了。如果想不用钱又大空间存储的话，貌似只有百度云盘了。系统篇优化：Advanced Systemcare一个国外优化软件，由于伟大的￥G*F·W#，软件在大陆境内不能实现自动升级，所以需要科学上网。另外软件需要注册码，大家有条件的就支持一下正版吧。如果是学生党可以去百度贴吧那里搜刮一下注册码。在这我就贡献一下自己的注册码。5F90C-4A11F-1BD01-DAC74Process Lasso一个系统进程优先级优化软件，软件默认的设置已经帮我们优化好了，如果不是特别懂，最好不要改动里面的默认设置。Adguard可以拦截很多桌面上弹出的广告，且软件支持自定义安装各种拦截插件。杀毒：火绒堪称国产良心，我喜欢它的弹窗拦截，除了比它默认拦截的弹窗之外，有其它弹窗时，按一下Alt + Shift + A(软件默认的，可以自己改)选择要剔除的弹窗，然后你就真的永远见不到那个弹窗了，废话不多说，自己试过才知道。解压：7-Zip体积迷人，高压缩比率，极客必备。效率：AutoHotKey一个脚本解释语言，解释器本身体积非常小，然后自己写要运行的脚本。当然了，网上也有很多已经写好的脚本，自己可以按需求去发现。一句话就是： 只要你会用，它无所不能。在此附上一个教程Wox一款快速启动的软件，速度快的，体积迷你。文件搜索配合Everything使用，效果更佳。Everything是一款文件搜索软件，比Windows自带的文件搜索快太多太多了。Listary其效果就等于 Wox + Everything，至于用哪个就看个人喜好吧！附上一个教程Seer一款文件预览软件，体积迷你，按个Space键，可以预览文件信息，其所支持的文件格式十分多，例如可以支持C、Java等编程语言文件的语法高亮预览；还有歌曲的预览、PPT、PDF等格式文件的预览，十分方便，启动速度也很快。F.lux一个护眼软件，作者已经多年没有更新了。不过功能够用。我本人十分喜欢它的夜间模式，即使周围没有光线，电脑屏幕也不刺眼。MacType把Windows不顺眼的字体风格渲染成Mac Book的字体画风。因为可以选择注册表方式加载，所以就不会拖慢电脑开机速度FileNote当文件繁多的时候(例如自己不熟悉的软件或一些不可备注的压缩包)，经常会不知道当前的文件要来干嘛的，此时可以使用FileNote对文件的用途进行备注，下次一看就知道这个文件是用来干嘛的了。Ditto一个剪切板工具，可保存最近的剪切记录或实现跨电脑跨平台剪切复制，且其所剪切的记录不单单是文本，也可以是图片、HTML等。网上有很多关于Ditto的使用技巧，我就不一一罗列了学习&amp;工作篇笔记：Leanote又称蚂蚁笔记，一款集笔记、博客、协作、私有云的笔记。其实，我之前是一直在用印象笔记的，碍于其对markdown语法支持一般，所以我就转入了Leanote，再者，蚂蚁笔记的主题自己改一下还是挺好看的。不过有一点还不太好，就是蚂蚁笔记现在还不支持对文章的加密，有点小小的遗憾！EverNote分为国际版(EverNote)、国内版(印象笔记)，两个的数据库是不相连接的。所以如果要使用，记得区分好，我一开始使用的时候就掉到了这个坑里。哈哈哈翻译：Lingoes文本翻译软件，功能还算全面，支持屏幕取词，划词翻译。不要问我为什么不用有道笔记，我不会告诉你是因为它经常弹窗骚扰的！SSH：PuttyWindows下对Unix系统的远程控制终端，体积迷你。WinSCP一款开源的SFTP客户端。我的用途就是远程登录云端服务器。文本编辑器：gVimWindows平台下的Vim，在Linux下玩久了，回到Windows不习惯的话，可以试试它。Sublime Text 3前端程序员必备，它拥有庞大的插件源，因此可以拓展许多炫酷实用的功能。反正我现在都是用它来写博客的。Notepad++一个程序员自由开发文本编辑软件。文本比较：Beyond Compare一个文本内容比较软件，我就不多说了。科学上网篇:XX-Net它是GitHub上一个开源的项目，相对于其他科学上网的VPN，xx-net是十分彪悍稳定的，当然天下没有免费的午餐，不想做小白就要自己一步一步地配置，配置过程可能有点小长。所以，怕折腾者勿点教程娱乐篇视频播放器：Potplayer拥有KMPlayer的硬件加速，界面简洁且功能强大，支持格式众多。音乐播放器：Mcool一个短小精悍的本地音乐播放器。网易云音乐喜欢它，主要是网易云的云端歌曲推送真心不错。桌面美化：火萤动态桌面，工作疲累时，看一看，还是挺恰意的。没有最好的软件，只有最适合自己的软件以上所列举的软件是我所用过的软件，如果你有更好的软件，也可以推荐我一下！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>优雅</tag>
        <tag>极客</tag>
        <tag>效率</tag>
        <tag>必备</tag>
        <tag>win10</tag>
        <tag>干货</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初次接触Uboot源码]]></title>
    <url>%2Fposts%2F%E5%88%9D%E6%AC%A1%E6%8E%A5%E8%A7%A6Uboot.html</url>
    <content type="text"><![CDATA[上半年对Cortex-A8裸机与嵌入式C语言进行了系统性的学习，终于进阶到了Uboot启动阶段。注：以下配置是以S5PV210为例。废话不说，上菜。配置： ​uboot和Linux kernel等复杂项目，不能直接编译，都需要先配置才能编译首先进入uboot根目录若不指定编译文件目录，执行 make x210_sd_config 出现：Configuring for x210_sd board 配置成功指定编译文件目录123makeO=Outputx210_sd_config#配置文件makeO=Outputall#编译makeO=Outputdistclean#清理编译：第一步：编译之前检查交叉编译链对不对，检查当前编译环境中有没有安装合适的arm-linux-链第二步：检查uboot根目录的Makefile中的编译器的设置是否正确。在工程的主Makefile中会设置交叉编译工具链的路径和名字，必须保证这个路径和名字和我们自己装的是一致，当然将编译命令导出到环境变量就可以不同确保以上2点，即可进行编译。可以直接make，或者make -j4(多线程编译)uboot中各文件介绍：.gitignore : git工具的文件 arm_config.mk : 后缀为.mk，是一个Makefile文件，将来在某个Makefile中会调用它 3个Changelog文件 : 修改记录文件，该文件记录了这个uboot项目的版本变迁以及每个版本较上一个版本修改的记录。 config.mk : 性质同arm_config.mk COPYING : 版权声明，uboot本身是GPL许可证的 CREDITS : 鸣谢，记录了对uboot有贡献的人 image_split : 一个脚本 MAINTAINERS : 维护者，当前参与维护uboot源码的社区工作者 MAKEALL : 一个脚本 Ｍakefile : 用于编译整个uboot mk : 快速编译的脚本，即先清理后配置再编译 mkconfig ： uboot配置阶段的只要配置脚本，uboot的可移植性很大程度就是靠这个配置脚本在维护 mkmovi ： 一个脚本，和inand/SD卡启动有关 README : 使用说明书 rules.mk : uboot中Makefile使用的规则 根目录文件夹名：api : 硬件无关功能函数，uboot移植时不用管 api_examples : API相关的测试示例代码 board : 存放各种开发板相关的配置文件 common : 用于存放一些与具体硬件无关的普遍适用的一些代码。譬如控制台实现、crc校验。但是更多的主要是两类：一类是cmd开头的，是用来实现uboot的命令系统的；另一类是env开头的，是用来实现环境变量的 cpu ： 与SOC相关的，里面存放的代码都是SOC相关初始化和控制代码（如：CPU的、中断的、串口的等内部外设，包括起始代码start.S） disk : 磁盘有关 doc : 文档目录，英文原档，帮助理解uboot drivers ： 存放Linux源代码中扣出来原封不动的Linux设备驱动，用于uboot的运行，主要是开发板上一些必须用到的驱动 examples : 示例代码 fs ： filesystem文件系统，从Linux源代码中移植过来的，用于管理flash等资源 include ： 头文件目录 lib开头的文件夹 ： 架构相关的库文件 lib_arm(arm架构使用的一些库文件)、lib_generic（所有架构通用的库文件） 这类文件夹中的内容移植时基本不用管 libfdt ： 设备树有关的。使用设备树来进行启动传参，进行硬件信息的描述 nand_spl : nand相关 net : 网络相关的代码 onenand开头 ： onenand相关的 post : sd_fusing : 实现烧录uboot镜像到SD卡的代码 tools : 一些工具类的代码 会不定时更新后续博客！！！有想法的，欢迎留意讨论！！！]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2Fposts%2FWTF.html</url>
    <content type="text"><![CDATA[闻道有先后，术业有专攻，如是而已最近有点时间，所以就花了两天的时间搭建了这个博客。有人问我，你浪费那么多时间搭建这个博客，要来干嘛用？说实话，有时候挺怕遇到这种不太开明的朋友的。搭建一个博客于我而言，是一个个人言论空间（相对网络上很多著名的言论平台，自己发的帖不会被平台随意删除）。另外，我是一个比较爱折腾（你可以说我犯贱）的人，搭建博客对我这种菜鸟而言是一个提高的机会。因为最近半年多都在学习ARM Linux，所以最近一段时间会把这半年来学的东西总结一下。另外，对于51单片机、STM32、ZigBee、WiFi，后期如果有时间我也会总结一下！！！当然了，时不时我还是会附送一点小干货的！！！博客刚开始搭建起来，很多细节还不是做得很好！！！见谅啊！！！]]></content>
  </entry>
</search>
