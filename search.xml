<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于TQ210的学习小过程]]></title>
    <url>%2Fposts%2F%E5%9F%BA%E4%BA%8ETQ210%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[因为开发环境的差异，以下的操作可能会有点出入，所以要学会自己去修改，网上也会有相应的提示Uboot修改基于Uboot1.3.4初步检查1.检查交叉编译工具链1vi Makefile查看CROSS_COMPILE是否正确其实也可以在编译的时候加上编译链传入参数例如make -j8 CROSS_COMPILE=arm-linux-2.编译源码并烧录查看Makefile，查找开发板配置信息本开发板型号：s5pc11x会看到smdkv210single_config12make smdkv210single_configmake进入烧录目录(sd_fusing)检查文件参数1file mkbl1其参数应为Intel 80386若不是，则重新编译本目录文件1make clean &amp;&amp; make烧录1./sd_fusing.sh /dev/sdb(根据实际情况改动)后续移植0.修改配置信息1#define CONFIG_IDENT_STRING &quot; for SMDKV210 Transplanted by JM.Lin&quot;1.杂项123start.S ↓bl PMIC_InitIp // 将其屏蔽，没有此功能2.内存初始化设置两个内存的地址连续储存即把内存1的起始地址从0x20000000变为0x30000000123456789101112131415161718192021↓ [smdkv210single.h]#define SDRAM_BANK_SIZE 0x10000000 // 本机有两个为256MB大的内存 ↓#define PHYS_SDRAM_1 MEMORY_BASE_ADDRESS // 第一块的物理内存地址设置为0x30000000 ↓#define PHYS_SDRAM_2 0x40000000 // 第二块的物理内存地址设置为0x40000000 ↓ // 设置MEMCONFIG_0寄存器#define DMC0_MEMCONFIG_0 0x30F01323 // 30为地址放到0x30000000地址，F0表示地址范围0-0x0FFFFFFF,256MB ↓#ifdef CONFIG_ENABLE_MMU // 设置Uboot虚拟映射起始地址#define CFG_UBOOT_BASE 0xc3e00000#else#define CFG_UBOOT_BASE 0x33e00000 // 不使能MMU时，用到，由0x23e00000更改#endif ↓#define virt_to_phys(x) virt_to_phy_smdkc110(x) // 虚拟地址到物理地址的转换 ↓ [smdkc110.c]return (addr - 0xc0000000 + 0x30000000); // 实现虚拟地址0xc0000000映射到0x30000000 ↓ [lowlevel_init.S].set __base,0x300 // 下面是c0000000-d0000000这段虚拟地址表设置，映射到20000000-30000000这段物理地址上.rept 0xD00 - 0xC003.MMC配置法1：根据uboot启动回显信息分别搜索unrecognised和EXT_CSD，对比找到12345678mmc.c↓if (ext_csd_struct &gt; 5) &#123; // 更改版本号5变为8，因为调试信息中为version7，当version小于7时，才不会跳入这里 printf(&quot;unrecognised EXT_CSD structure &quot; &quot;version %d\n&quot;, ext_csd_struct); err = -1; goto out; &#125;法2：12345mmc.c↓int mmc_initialize(bd_t *bis) ↓mmc = find_mmc_device(1); // 在启动uboot时，寻找MMC设备，0为机子内部的inand，1为SD2的卡槽4.USART通信1#define CONFIG_SERIAL3 1 /* we use UART2 on SMDKC110 定义板子的串口通信端口*/5.网卡DM9000程序：123456789101112init_sequence board.c ↓board_init smdkc110.c ↓dm9000_pre_initSROM_BW_REG &amp;= ~(0xf &lt;&lt; 4); // 查原理图可知，使用了Bank1SROM_BW_REG |= (1&lt;&lt;7) | (1&lt;&lt;6) | (1&lt;&lt;5) | (1&lt;&lt;4);SROM_BC1_REG = ((0&lt;&lt;28)|(1&lt;&lt;24)|(5&lt;&lt;16)|(1&lt;&lt;12)|(4&lt;&lt;8)|(6&lt;&lt;4)|(0&lt;&lt;0)); // 使用了SROM_CS1tmp &amp;=~(0xf&lt;&lt;4); // 引脚复用，选择SROM_CSn[1]作为复用功能tmp |=(2&lt;&lt;4);数据：12345smdkv210single.h↓#define CONFIG_DM9000_BASE (0x88000300) // 使用了SROMC_Bank1 ↓#define DM9000_DATA (CONFIG_DM9000_BASE+4) // ADDR2接上了CMD，4表示二进制的0b100，代表ADDR2位高电平Linux kernel移植准备条件将光盘kernel文件Linux资源\Linux源码包\3.0.8\Kernel_3.0.8_TQ210_for_Linux_v2.2.tar.bz2复制到你的交叉编译环境(我的是虚拟机Ubuntu)将文件解压 tar -jxvf Kernel_3.0.8_TQ210_for_Linux_v2.2.tar.bz2内核配置清理内核编译文件make distclean配置生成默认文件cp config_for_TQ210_Linux_v2.1_CoreB .config #直接使用天嵌已经给的默认配置文件kernel 裁剪make menuconfig如果是第一次使用的话，可能会出现错误根据错误，需要下载ncurses，先执行sudo apt-get install libncurses5-dev来下载，然后再make menuconfigDevice DriversMultimedia supportVideo capture adapters[x] Samsung Camera Interface (FIMC) driver // 移除摄像头驱动[ ] camera ov3640[ ] camera ov9650[ ] camera tvp5150[ ] camera saa7113[x] Samsung TV Driver[ ] HDMI CEC driver support // 移除HDMI遥控驱动[x] HDMI HPD driver supportHID Devices[ ] USB Human Interface Device (full HID) support // 移除鼠标驱动Networking support[ ] Bluetooth subsystem support // 移除蓝牙驱动注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
        <tag>Linux</tag>
        <tag>移植</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS搭建]]></title>
    <url>%2Fposts%2FVPS%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[实验室的海外服务器还有10来天就过期了，趁有点时间就玩一玩！前言：今天去Vultr部署了一个虚拟专用服务器(下面以VPS代指)，一开始系统分配的IP已经被GFW墙了，可是我还抱着一丝轻蔑的态度，想要用远程终端通过代理来登录，折腾了2个小时后觉得不太靠谱，还是把VPS给删除掉，让系统再从新分配一个不同IP的VPS给我。然后马上来这里ping测试一下有没有被墙。幸运的是，我第二次就可以了，不需要通过代理就能用putty来登录VPS。弱弱地吐槽一句，Vultr的网页终端交互能力好弱啊！所部署的VPS参数如下 用了Ubuntu14.04挺久的了，所以玩生不如玩熟！！！一些更新apt-get update &amp;&amp; apt-get upgradeapt-get install gcc g++ # 更新编译器apt-get install aptitudevim系统原生配置的是vi，我习惯用vim就下载一个vim,接着再安装vim的插件apt-get install vimwget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -xSSR这个我就不多做解释了，懂的人懂就好！（奸笑ing）安装123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.shchmod +x shadowsocksR.sh./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log一开始要设置密码，之后的都使用默认配置使用命令12345./shadowsocksR.sh uninstall # 卸载/etc/init.d/shadowsocks start # 启动/etc/init.d/shadowsocks stop # 停止/etc/init.d/shadowsocks restart # 重启/etc/init.d/shadowsocks status # 状态文件配置路径123/etc/shadowsocks.json # 配置文件路径/var/log/shadowsocks.log # 日志文件路径/usr/local/shadowsocks # 代码安装目录Database安装mysqlapt-get install mysql-server mysql-client libmysqlclient-dev libmysql-java弹出蓝色框框，输入两次密码登录mysql -u root -pGitapt-get install git -y配置git config --global user.email &quot;eclaboratory@163.com&quot;git config --global user.name &quot;EC-Lab&quot;git config --global credential.helper store # 用于保存用户数据博客环境搭建安装apt-get install npmapg-get install nginx -ynpm install hexo-cli hexo-server -g之后继续补充！注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>VPS</tag>
        <tag>Vultr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim之高手进阶篇]]></title>
    <url>%2Fposts%2FVim%E4%B9%8B%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E7%AF%87.html</url>
    <content type="text"><![CDATA[距离上一次发博客也是有一段时间了！在命令模式下移动光标 H(屏幕首行开头) gg(文章首行开头) 0(行首) $(行末) b(前一个单词开头) w(后一个单词开头) e(后一个单词末尾) G(文章末行开头) 从命令模式进入插入模式o &quot; 在当前光标所在行下面插入一行 O &quot; 在当前光标所在行上面插入一行 分屏模式适用于多文件处理横向分屏:sp otherfilename “ split垂直分屏:vsp otherfilename “ vertically split切换Viewport| 按键 | 作用 || :——– | :——– || Ctrl + w -&gt; h | 移动光标到左边的viewport|| Ctrl + w -&gt; j | 移动光标到下边的viewport|| Ctrl + w -&gt; k | 移动光标到上边的viewport|| Ctrl + w -&gt; l | 移动光标到右边的viewport|| Ctrl + w -&gt; + | 扩大当前viewport|| Ctrl + w -&gt; - | 缩小当前viewport|| Ctrl + w -&gt; = | 重新均匀分配各个viewport的占比|| Ctrl + w -&gt; r | 调换各个viewport的位置。用R的话是反向调换|| Ctrl + w -&gt; q 或c | 关闭当前viewport|| Ctrl + o 或 :only | 只保留当前所在viewport|字符搜索/ &quot; 顺序查找(n下一个、N上一个) ? &quot; 逆向查找 % &quot; 配对括号查找 字符替换:s/old/new &quot; 只改当前所在行的第一个 :s/old/new/g &quot; 只改当前所在行的所有 :#,#s/old/new/g &quot; #，#表示若干行中首位两行的行号 :%s/old/new/g &quot; 替换整个文件中的每个匹配符 :%s/old/new/gc &quot; 替换整个文件中的每个匹配符， 但会提示是否进行替换 文件合并:r filename &quot; 在光标后插入一个文件的内容 在vim中执行外部shell命令:! shell_command :w FILENAME &quot; 可将当前编辑文件保存FILENAME文件中 v motion :w FILENAME &quot; 可将当前编辑文件中可视模式下选中的内容保存到FILENAME文件中 :read FILENAME &quot; 可提取磁盘文件FILENAME并将其插入到当前文件的光标位置后面 :read ! wc % &quot; 可将文件包含的行数、单词数和字符数输出到当前文件的光标位置后面 :2read ! wc % &quot; 插入到第二行，使用`$`在最后一行插入，`0`在第一行前面插入 保存当前所有打开的文件及其状态:mksession ~/.vim/sessions/your_session_name.vim 还原上次会话法一：:source ~/.vim/sessions/your_session_name.vim法二：vim -S ~/.vim/sessions/your_session_name.vim注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Raspberry Pi 3B上手]]></title>
    <url>%2Fposts%2FRaspberry-Pi3%E4%B8%8A%E6%89%8B.html</url>
    <content type="text"><![CDATA[前段时间买了个树莓派3，但一直在忙其它东西，就把它荒废了！今天有时间，折腾就一下注: Raspberry系统为Raspbian 9.1 (Stretch)，如果是其它系统注意操作时的差异查看系统信息如果不知道自己的系统版本的话，可以敲lsb_release -aLog in第一次登陆，默认用户名为pi,密码为raspberry若要登陆root，可以改密码sudo passwd root更换镜像源sudo vi /etc/apt/sources.list 12deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contribdeb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contribsudo apt-get update sudo apt-get upgrade 安装输入法sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin 更新Vimapt-get remove vim-common apt-get install vim cd ~ // 切换到当前用户根目录 vi .vimrc // 进入文件编辑 1234567set autoindent &quot; 自动缩进set cindentset tabstop=4 &quot; Tab宽度set softtabstop=4 &quot; 同一缩进为4set shiftwidth=4 set expandtab &quot; 使用空格代替制表符set nu &quot; 显示行号source .vimrc 配置WIFI链接文件vi /etc/wpa_supplicant/wpa_supplicant.conf 12345678910111213141516171819country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev # 当前使用interface的socket文件update_config=1ap_scan=2 # 默认值是1，表示优先链接可见WIFI，受优先级影响 # 2，表示按照network定义的顺序链接，不受优先级影响network=&#123;ssid=&quot;Your Router&quot;psk=&quot;Your Passwd&quot;key_mgmt=WPA-PSK # 加密选项priority=6 # 链接优先级 越大越链接&#125;network=&#123;ssid=&quot;Your Router&quot;psk=&quot;Your Passwd&quot;key_mgmt=WPA-PSKpriority=5scan_ssid=1 # 连接隐藏WIFI选项&#125;设置无线网卡静态IPifconfig wlan0 # 记录ether后面的一组数据(如：e8:27:39:sd:ed:66)，后面会用到 vi /etc/dhcpcd.conf 在文件后面添加内容，下面的IP地址要根据自己所连接WIFI的IP地址改动1234interface e8:27:39:sd:ed:66 static ip_address=192.168.0.3/24 static routers=192.168.0.1 static domain_name_servers=192.168.0.2 8.8.8.8reboot root登录sshvi /etc/ssh/sshd_config 123PermitRootLogin prohibit-password改为PermitRootLogin yes防止ssh连接因超时闲置断开vi /etc/ssh/sshd_config 1ClientAliveInterval 60/etc/init.d/ssh restart 注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>树莓派3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot前期准备]]></title>
    <url>%2Fposts%2FUboot%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87.html</url>
    <content type="text"><![CDATA[考虑到大家之前没有学习嵌入式相关的基础知识，我下面会先从构建代码环境讲起，如果之后大家觉得感兴趣的，我也会写其他东西给大家看！如果大家之后有什么疑问可以直接来找我。注： 以下操作均在Windows平台Uboot源码文件源码获取拿到老师给的光盘镜像之后，进入bootloader文件可以看到uboot_TQ210_1.3.4_V1.7.tar.bz2，分别解压两次会得到opt这个文件夹，在解压第二次的时候解压器会报出一些错误，可以忽略它（因为里面有Linux平台下的link类型文件与Windows不兼容）按路径 opt\EmbedSky\TQ210\uboot_TQ210_1.3.4 依次进入到 uboot_TQ210_1.3.4 文件中，此目录在之后的代码分析中，我们称之为uboot的根目录Source Insight 4.0添加uboot源码工程软件安装及其破解下面是Source Insight 4.0的软件下载链接：链接：http://pan.baidu.com/s/1geJWo9d 密码：j9qu阅读那个 readme.txt 文件来破解添加uboot源码工程现在uboot根目录下创建一个文件夹 SI_Project ，名字随便起都行，用于存放等下Source Insight创建工程的文件打开Source Insight软件，在菜单栏点击Project-&gt; New Project标号1是输入将要创建的工程名Uboot1.3.4（自己设置），标号2是选择你电脑uboot的根目录所在的文件夹，然后点击OK标号1是找到刚才在uboot的根目录所创建的文件夹，我刚才创建了文件夹 SI_Project，然后点击OK在Directory栏选择uboot根目录，然后在右边点击 Add ALL把第二个勾上，意思是递归添加子目录文件，然后点击OK等待一下，就可以点击右上角的Close按钮点击标号1右侧打开文件目录，点击标号2，在标号3找到uboot根目录，可以看到右侧的文件就是源码文件及其文件夹一些设置因为之后需要浏览.S文件的汇编代码，所以需要在source insight中进行文件类型的关联依次在菜单栏点击Options-&gt;File Type Options，在出现的窗口左边选择C Source File，在File filterd下添加 *.S，最后点击CloseUboot根目录文件介绍arm_config.mk : 后缀为.mk，是一个Makefile文件，将来在某个Makefile中会调用它3个Changelog文件 : 修改记录文件，该文件记录了这个uboot项目的版本变迁以及每个版本较上一个版本修改的记录。config.mk : 性质同arm_config.mkCOPYING : 版权声明，uboot本身是GPL许可证的CREDITS : 鸣谢，记录了对uboot有贡献的人image_split : 一个脚本MAINTAINERS : 维护者，当前参与维护uboot源码的社区工作者MAKEALL : 一个脚本Makefile : 用于编译整个ubootmk : 快速编译的脚本，即先清理后配置再编译mkconfig ： uboot配置阶段的只要配置脚本，uboot的可移植性很大程度就是靠这个配置脚本在维护mkmovi ： 一个脚本，和inand/SD卡启动有关README : 使用说明书rules.mk : uboot中Makefile使用的规则Uboot根文件夹介绍api : 硬件无关功能函数，uboot移植时不用管api_examples : API相关的测试示例代码board : 存放各种开发板相关的配置文件common : 用于存放一些与具体硬件无关的普遍适用的一些代码。譬如控制台实现、crc校验。但是更多的主要是两类：一类是cmd开头的，是用来实现uboot的命令系统的；另一类是env开头的，是用来实现环境变量的cpu ： 与SOC相关的，里面存放的代码都是SOC相关初始化和控制代码（如：CPU的、中断的、串口的等内部外设，包括起始代码start.S）disk : 磁盘有关doc : 文档目录，英文原档，帮助理解ubootdrivers ： 存放Linux源代码中扣出来原封不动的Linux设备驱动，用于uboot的运行，主要是开发板上一些必须用到的驱动examples : 示例代码fs ： filesystem文件系统，从Linux源代码中移植过来的，用于管理flash等资源include ： 头文件目录lib开头的文件夹 ： 架构相关的库文件 lib_arm(arm架构使用的一些库文件)、lib_generic（所有架构通用的库文件）libfdt ： 设备树有关的，使用设备树来进行启动传参，进行硬件信息的描述nand_spl : nand相关代码net : 网络相关的代码onenand开头 ： onenand相关的代码tools : 一些工具类的代码注：本文内容部分来自互联网整理，部分来自个人经验总结。欢迎留言补充！]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说存储类关键字]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[.存储类关键字（用于修饰变量）auto(自动变量)auto即平时的局部变量关键字，可以省略，故定义局部变量时都没有写分配在内存中的栈上register(寄存器变量)这个不是很常用编译器会将其所修饰的变量尽量分配在寄存器中（使其变量的读写效率会变高）由于寄存器数量有限，关键字所修饰的变量不一定都放在寄存器内static(静态变量)修饰变量修饰全局变量修饰局部变量修饰函数修饰类别形成分配位置生命周期链接属性局部变量静态局部变量数据段/BSS段代码块作用域无链接全局变量静态全局变量数据段/BSS段文件作用域内链接函数静态函数在其声明文件文件作用域内链接extern(外部变量)修饰全局变量，用于文件作用域以外访问const(只读变量)其所修饰的变量存储在只读变量区，在C中仍然是变量（C++中，是只读常量）编译器通常将const保存在符号表中而非分配存储空间，从而节省了空间，提高了效率（例子：函数传参声明为const指针–另外一个就是防止该指针在函数体内被意外修改）就近原则解释const int a;a是常整型数，a不可变const int *a;a是指向一个常整型数的指针，a所指内容不可变int *const a;a是指向一个整型数的常指针，a不可变const int* const a;a是指向一个常整型数的常指针，a及其所指内容都不可变修改const修饰的变量(在GCC环境中)在GCC中，const是通过编译器在编译的时候执行检查来确保实现的(即改const类型变量是编译错误，而非运行时错误)GCC编译器把const类型的变量放在了数据段，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，故只要骗过编译器，const变量就可以修改了。12345const int a = 5;int *p;p = (int *)&amp;a;*p = 6;printf("a = %d. \n", a);volatile(易变变量)用以修饰一个可以被编译器之外改变的变量，告诉编译器不对改变量的访问进行优化编译器之内：当前程序上下文的控制流（即当前代码）编译器之外：中断ISR中引用的变量、多线程中共用的变量、硬件会更改的变量。（编译器在编译时无法预知的更改）typedef(自定义数据类型变量)自定义数据类型（不要与#define相混淆）12typedef int *Pint; const Pint p;typedef int *Pint; Pint const p;以上两个皆相当于 int *const p; 即p皆为常指针很多初学者都很难去记住上面的两个关系，是因为又与#define相混淆了，还没有完全理解typedef这个关键字原理如下：编译器在解析的时候会忽略数据类型，直接修饰p，因此以上两个式子都可以看为 Pint const p;如果实在想不通，就想想 const int i; 和int const i; 为什么是相同的restrict只用于修饰指针；其告知编译器，所有修改该指针所指向内容的操作全部是基于该指针的，即不存在其他进行修改操作的途径看不懂，是不是？其实它的作用就是为了帮助编译器进行更好的代码优化。该关键字用得少，慎用注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>存储类</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说存储类]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB.html</url>
    <content type="text"><![CDATA[.存储类(Storage Class)简单来说，存储类就是C语言中存储变量的地方的类型分为动态存储区，静态存储区动态存储区栈(Stack)其增长方向：自顶向下增长有内存空间的限制存储内容函数形参，在调用函数时给形参分配空间函数内的自动变量（即普通变量）函数调用时的现场保护和返回地址(即函数调用语句的下一句可执行语句)在函数调用开始时分配存储空间，函数结束时释放存储空间函数调用结束时，局部变量先出栈，接着是形参，最后栈指针指向最开始存储的地址来进行下一条指令堆(Heap)程序员自定义存储空间使用后，需要手动释放内存，不然会造成内存泄露静态存储区.data段存放非零全局变量、静态局部变量.bss段(Block Started by Symbol)存放未初始化的全局变量、静态局部变量运行时，由系统初始化，即清零。一般要自己写.ROData(文本常量区)存放字符串常量1char *p="linux"; // 定义了一个分配在栈上占4字节的指针指向了一个分配在文本常量区上占6字节的字符串.text段(代码区)cup执行的机器指令部分(函数体的二进制代码)属性只读，为了防止程序由于意外事故而修改自身指令作用域作用域即变量或函数起作用的范围文件作用域代码作用域生命周期永久临时链接属性链接属性有以下3种：外链接内链接无链接宏定义 和 inline内联函数 链接属性为 无链接总结类型存储类作用域生命周期链接属性普通全局变量.data段/.BSS段文件作用域永久外链接静态全局变量.data段/.BSS段文件作用域永久内链接普通局部变量栈代码作用域临时无链接静态局部变量.data段/.BSS段代码作用域永久无链接普通函数.text段文件作用域永久外链接静态函数.text段文件作用域永久内链接堆与栈的比较类型StackHeap生长方向向地址减小的方向增长向地址增大的方向增长分配方式动态分配与静态分配动态分配碎片问题无此问题过多使用会造成内存不足申请后系统响应无可用空间报异常提示栈溢出系统分配申请的内存到空闲地址链表中分配效率相对高相对低申请大小系统预先规定好大小系统可用内存申请效率相对快相对慢，容易产生内容碎片存储内容看上面一般在堆的头部用1字节存放堆的大小，其他程序员安排存取效率相对快,char s[]=”Hello”;在运行时赋值;数组比指针要快一些相对慢;char *s=”Hello”;在编译时确定最后附上一张内存分布的图片注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>存储类</tag>
        <tag>作用域</tag>
        <tag>生命周期</tag>
        <tag>链接属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim之基础入门篇]]></title>
    <url>%2Fposts%2FVim%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87.html</url>
    <content type="text"><![CDATA[很多人都对vim这货有所敬畏，其实只要多动手，vim是很容易上手的。用了vim大半年了，今天就写个基础入门篇，之后有空再加个高手进阶篇在命令模式下移动光标12345 k(上) h(左) l(右) j(下)从命令模式进入插入模式12a // 光标后插入i // 光标前插入从插入模式进入命令模式1Esc在命令模式下操作复制1yy // 复制光标所在的一行粘贴12p // 粘贴到光标后P // 粘贴到光标前删除1x // 删除光标后的一个字母剪切1dd // 剪切光标所在的一行撤销12u // 撤销上一次操作U // 撤销所在行的所以操作从命令模式进入底线命令模式保存1:w退出1:q // 如果所编辑的文件有更改，则退出失败保存并退出1:wq注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈指针]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E6%8C%87%E9%92%88.html</url>
    <content type="text"><![CDATA[.一级指针指针其实就是存放内存地址的变量，其长度在32位系统上固定为4字节。指针数组数组的存储内容是指针1int *p[];数组指针指向一个数组的指针1int (*p)[];指针函数函数的返回值类型是一个指针类型1234void *pf();/* or */typedef void *pf();pf function(); // 定义实例所以指针函数用于修饰函数返回值函数指针指向一个函数的指针(函数名 与 &amp;函数名 都表示函数运行的首地址)1234void (*fp)();/* or */typedef void (*fp)(int ,char);fp function; // 定义实例二重指针指向一个int*类型的指针1int **p;实例意义int a;&amp;a是一个int *型变量int *p;指针p指向一个int型变量int **p;指针p指向一个int *型变量int a[3]aaa+1&amp;a&amp;a+1int 类型数组首元素首地址(int)a + 1sizeof(int), 地址加4byte即a[1]数组首地址(int)a + 1*sizeof(int[3]), 地址加12byte即a[3]话说大端小端大端：数据的高字节存储在低地址中小端：数据的低字节存储在低地址中代码判断1234567891011union myunion&#123; int a; char b;&#125;;int BigorSmall()&#123; union myunion u1; u1.a = 1; return u1.b; // 地址0的那个字节内是1（小端）或者0（大端）&#125;123456char BigorSmall()&#123; int a = 1; char b = *((char *)(&amp;a)); return b;&#125;指针都是4字节，为什么还要定义指针类型？定义指针类型的好处是：定义一个指针时，编译器为指针所指向的内容定义好大小，无需程序员去管理代码中的变量在内存的情况计算机的内存地址分配原则：内存寻址由大到小，优先分配内存地址较大的空间给变量（从下往上），先定义的变量，分配的地址越大123456789#include&lt;stdio.h&gt;int main()&#123; int a = 2; char c = 1; int *p = &amp;c; // 编译器不会报错，但会有警告，因为指针类型不匹配 printf("%d .\n",*p); return 0;&#125;指针读取数据是箭头从下往上读取，该代码运行结果为513注：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>大端小端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[话说内存对齐]]></title>
    <url>%2Fposts%2F%E8%AF%9D%E8%AF%B4%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html</url>
    <content type="text"><![CDATA[颓废了一个多星期，感觉还是要写个博客压压惊！！！为什么会有内存对齐？为了访问未对齐的内存，处理器需要作两次内存访问；而，对齐访问仅需要一次访问。对齐参数32位系统中，默认4字节对齐（32位系统CPU字长是4字节）在Windows(32)/VC6.0下各种数据类型的变量的自身对齐参数就是该数据类型变量所占字节数的大小在Linux(32)/GCC下double类型下的对齐参数为4Linux(32)/GCC下如果该数据类型的长度没有超过CPU的字长，则以该数据类型变量的长度作为自身对齐参数如果超过了CPU字长，则自身对齐参数为CPU字长字节对齐原则结构体每个成员相对结构体首地址的偏移量(offset)是对齐参数(此对齐参数是取每个变量自身对齐参数和系统对齐参数两者中较小的一个)的整数倍，如果有需要会在每个成员之间填充字节编译器在为结构体成员开辟空间时，首先检查预开辟空间的地址相对于结构体首地址的偏移量是否为对齐参数的整数倍，若是，则存放该成员，否则，反之结构体变量所占空间的大小是对齐参数大小的整数倍，如有需要会在最后一个成员末尾填充若干字节使得所占空间是对齐参数 (对结构体中所有变量的对齐参数的最大值和系统默认对齐参数#pragma pack(n)比较，较小者作为对齐参数)的整数倍static修饰的变量所占空间没有被算入，因为其存储在.bss段/.data段内存对齐的关键字GCC推荐的对齐指令123__attribute__((packed)) // 一字节对齐使用时，直接接放在进行内存对齐的类型定义后面，其作用范围为使用该类型定义的变量__attribute__((aligned(n))) // 用法同上，使整个结构体进行n字节的对齐(n为2的幂次方)GCC支持但不推荐的对齐指令123#pragma pack(n) // 放在自定义字节对齐的数据结构开头，指定编译器对齐参数为n字节定义结构体#pragma pack() // 放在自定义字节对齐的数据结构结尾，取消指定对齐参数，恢复缺省参数]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot下烧录Linux内核镜像]]></title>
    <url>%2Fposts%2FUboot%E4%B8%8B%E7%83%A7%E5%BD%95Linux%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F.html</url>
    <content type="text"><![CDATA[本文的操作平台是S5PV210.启动介质(SD卡/iNand/Nand/NorFlash等)烧录镜像进入Uboot命令行12movi read kernel 30008000 // 从启动介质的kernel分区去读取内核镜像到DDR地址为0x30008000处bootm 30008000 // 启动内核tftp烧录镜像虚拟机Ubuntu配置tftp服务器设置Ubuntu静态IP(192.168.1.141)将要烧录的镜像放到Ubuntu的tftp文件夹（/tftpboot）中开发板进入Uboot命令行123set ipaddr 192.168.1.20set gatewayip 192.168.1.1set serverip 192.168.1.141 // 设置为tftp服务器所在平台的IP测试连接1ping 192.168.1.141烧录镜像12tftp 0x30008000 zImage-qt // 将服务器下的zImage-qt镜像下载到DDR地址为0x30008000处bootm 0x30008000 // 启动内核]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置TFTP]]></title>
    <url>%2Fposts%2F%E9%85%8D%E7%BD%AETFTP.html</url>
    <content type="text"><![CDATA[Uboot启动内核镜像，除了在SD卡、Nand等raw分区中启动外，还可以通过tftp从远端服务器获取镜像。下面是配置tftp的过程安装TFTP客户端、服务程序和xinetd12sudo apt-get install tftp-hpa tftpd-hpasudo apt-get install xinetd文件配置配置/etc/xinetd.conf若没有，则创建，然后修改，下同12345678910# Simple configuration file for xinetd##Some defaults, and include /etc/xinetd.d/defaults&#123;#Please note that you need a log_type line to be able to use log_on_success# and log_on_failure. The default is the following :# log_type = SYSLOG daemon info&#125;includedir /etc/xinetd.d配置/etc/default/tftpd-hpa将内容改为12345# /etc/default/tftpd-hpaTFTP_USERNAME=&quot;tftp&quot;TFTP_DIRECTORY=&quot;/tftpboot&quot;TFTP_ADDRESS=&quot;0.0.0.0:69&quot;TFTP_OPTIONS=&quot;-l -c -s&quot;配置/etc/xinetd.d/tftp123456789101112131415service tftp&#123;socket_type = dgramwait = yesdisable = nouser = rootprotocol = udpserver = /usr/sbin/in.tftpdserver_args = -s /tftpboot#log_on_success += PID HOST DURATION#log_on_failure += HOSTper_source = 11cps =100 2flags =IPv4&#125;修改权限创建一个服务器存放文件的文件夹并设置最高权限12sudo mkdir /tftpbootsudo chmod 777 /tftpboot重启服务每次修改完配置文件都需要重启服务123sudo service tftpd-hpa restartsudo /etc/init.d/xinetd reloadsudo /etc/init.d/xinetd restart本地测试在/tftpboot 中新建一个文件file进入另一个文件夹中进入本地tftp命令行下12sudo tftp localhost// 可输入help查看命令和命令作用123get file // 下载文件到当前文件夹 put file // 上传文件到tftp服务器q // 退出tftp命令行非本地关闭防火墙（sudo ufw disable）或 卸载防火墙（sudo apt -get remove iptables）sudo tftp 目标ip地址]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>TFTP</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot启动两个阶段]]></title>
    <url>%2Fposts%2FUboot%E5%90%AF%E5%8A%A8%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5.html</url>
    <content type="text"><![CDATA[.Uboot启动两级阶段第一阶段流程：第二阶段对开发板级别的硬件、软件数据结构进行初始化代码分析1234567891011121314151617181920212223242526272829303132333435start_armboot // 开始arm的启动 // Uboot启动地址0x33e00000 Uboot大小2M 堆大小912KB 栈大小512KB 存放全局数据的结构体 gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - sizeof(gd_t); gd = (gd_t*)gd_base; // 将结构体指针gd实例化（分配空间） init_sequence(); cpu_init(); // 空的，在汇编阶段已经初始化过 board_init(); // 开发板 dm9000_pre_init(); // 网卡初始化 gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE; // 机器码 gd-&gt;bd-&gt;bi_boot_params = (PHYS_SDRAM_1+0x100); // 内存传参（启动参数） interrupt_init(); // 定时器4，用于计时 env_init(); // 环境变量初始化 init_baudrate(); // 软件层gd数据结构波特率初始化 serial_init(); // 空的，在汇编阶段已经初始化过 console_init_f(); // 控制台第一步初始化 display_banner(); // 打印Uboot版本号 print_cpuinfo(); // 打印SOC时钟频率信息 checkboard(); // 检验开发板名字 dram_init(); // 软件层gd数据结构DDR信息初始化 display_dram_config(); // 打印板上DDR内存大小 mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE); // 初始化Uboot所维护的堆内存 mmc_initialize(gd-&gt;bd); // 初始化iNand/SD卡 或 SOC上的控制器 env_relocate (); // 环境变量重定位 gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr ("ipaddr"); // 初始化软件层gd数据结构IP地址 gd-&gt;bd-&gt;bi_enetaddr // 初始化软件层gd数据结构以太网地址 devices_init (); // 参数传递，没有实现驱动初始化 jumptable_init (); // 跳转表 console_init_r (); // 控制台第二步初始化 enable_interrupts (); // 空的 loadaddr、bootfile // 内核启动环境变量读出初始化全局变量 board_late_init (); // 空的 eth_initialize(gd-&gt;bd); // 空的 x210_preboot_init(); // LCD初始化和显示开机logo check_menu_update_from_sd() // 检查自动更新 main_loop() // 主循环区别第一阶段第二阶段语言汇编阶段C阶段代码所在区域SRAMDRAM初始化SoC内部SoC外部Board内部st=>start: Uboot入口 e=>end: 第二阶段 io=>inputoutput: step1=>operation: ENTRY(_start) step2=>operation: 构建异常向量表 step3=>operation: 禁止中断,进入ARM状态,SVC模式 step4=>operation: 设置L2、L1cache和MMU step5=>operation: 识别并暂存启动介质选择 step6=>operation: 第一次设置栈(SRAM)并调用lowlevel_init step7=>operation: 检查复位状态 step8=>operation: 关看门狗 step9=>operation: 供电锁存 step10=>operation: 判断运行地址决定是否初始化时钟和DDR step11=>operation: system_clock_init(时钟初始化) step12=>operation: mem_ctrl_asm_init(DDR初始化) step13=>operation: uart_asm_init(串口初始化并打印'O') step14=>operation: pop {pc} (打印'K') step15=>operation: 第二次设置栈(DDR) step16=>operation: 判断Uboot是否进行Relocate step17=>operation: movi_bl2_copy step18=>operation: 使能域访问 step19=>operation: 设置TTB(转换表基地址) step20=>operation: 使能MMU单元 step21=>operation: 第三次设置栈(DDR) step22=>operation: 清理BSS段 step23=>operation: _start_armboot st(right)->step1->step2->step3 step3->step4->step5->step6 step6->step7->step8->step9 step9->step10->step11->step12 step12->step13->step14->step15 step15->step16->step17->step18->step19->step20 step20->step21->step22->step23(right)->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Uboot主目录下的Makefile分析]]></title>
    <url>%2Fposts%2FUboot%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84Makefile%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[本文是针对Uboot1.3.4 for x210来分析的，学习总结之余，也供大家参详！！！uboot version确定（24~29）VERSION:主版本号PATCHLEVEL：次版本号SUBLEVEL：再次版本号EXTRAVERSION:另外附加的版本信息include/version_autogenerated.h文件是编译过程中自动生成的一个文件，里面的内容就是我们在Makefile中配置的uboot的版本号HOSTARCH和HOSTOS（31~41）直接在shell中执行uname -m 得到的就是电脑CPU的版本号获取 HOSTARCH（CPU架构） HOSTOS（主机系统）静默编译（50~54）编译时哦make -s ，-s会作为MAKEFLAGS传给Makefile，因此XECHO变量=echo，即输出空信息单独输出文件夹编译（78~93）make O=输出目录export BUILD_DIR=输出目录，然后make若以上两者都指定了，O=输出目录具有更高的优先级确定OBJTREE、SRCTREE、TOPDIROBJTREE: 存放编译出.o文件目录的根目录，在默认编译下，OBJTREE等于当前目录SRCTREE: 源码目录，源代码的根目录，当前目录TOPDIR: 源码目录定义MKCONFIG变量（101）其值为源码根目录下mkconfig脚本文件，是uboot配置阶段配置脚本include $(obj)include.config.mk(133)include/config.mk不是源码自带的，是配置过程（make x210_sd_config）生成的其内容：12345ARCH = armCPU = s5pc11xBOARD = x210VENDOR = samsungSOC = s5pc110调用MKCONFIG脚本传参（2589）123x210_sd_config : unconfig #依赖为unconfig @$(MKCONFIG) $(@:_config=) arm s5pc11xx 210 samsung s5pc110 #传入参数有6个，$(@:_config=)变为x210_sd @echo &quot;TEXT_BASE = 0xc3e00000&quot; &gt; $(obj)board/samsung/x210/config.mk #创建config.mk文件并添加内容上面代码中的依赖 unconfig其定义在(473) 实现重复配置无报错12345unconfig: @rm -f $(obj)include/config.h $(obj)include/config.mk \ $(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \ $(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep \ $(obj)board/$(VENDOR)/$(BOARD)/config.mkARCH CROSS_COMPILEARCH（133） 定义当前编译的目标CPU的架构CROSS_COMPILE（136~180） 是定义交叉编译工具链的前缀（因为不同芯片所支持的工具链前缀都不一样，而后缀是一样的，这样定义增强程序可移植性）可以在编译时用make CROSS_COMPILE=xxx来实现编译传参覆盖Makefile里面的设置include $(TOPDIR)/config.mk（185）运行其他配置，即进入config.mk文件]]></content>
      <categories>
        <category>Uboot</category>
      </categories>
      <tags>
        <tag>Uboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人使用软件]]></title>
    <url>%2Fposts%2FPersonal-Software.html</url>
    <content type="text"><![CDATA[文章不定期更新工欲善其事，必先利其器在网上潜水了几年，由于最近一段时间有点时间，就整理一下自己的东西。这个是软件篇啦！不知道大家对自己电脑系统里的软件的使用度是怎样，我是一个喜欢折腾且无论娱乐、学习、工作都会刻意追求软件精简与效率的人，特别是键盘流，当然了，离大神的距离还有很长很长。这几年大多的国产软件种种的流氓行为（例如弹窗推广、恶意修改用户设置等）显然是被我所厌恶而卸载的。借着博客这个平台，今天我就总结一下自己的软件使用清单。（以下个别软件可能需要科学上网方能下载））装机必备浏览器：Chrome这个就不用我多说了吧？一个软件的强大之处在于其可外接插件，Chrome也不例外，其拓展插件源庞大，但官网下载需要科学上网，不过也可以自己在官网以外的地方找资源。之后我会整理一个自己Chrome所使用的插件列表，可以的话，我也会贡献一下资源。FirefoxFirefox的插件源同样庞大，与Chrome最大的不同是，其自由度较大，可个人定制（前提你喜欢折腾），你懂的！！！下载器：Internet Download Manager大名鼎鼎的IDM，除了不能下载电驴链接，其他都还好，我就不多说了。直接上网盘地址吧。链接: http://pan.baidu.com/s/1wIL8U 密码: egaa迅雷极速版迅雷9有多恶心，大家可能领教过了，网上也有各种的迅雷9剔除广告的补丁。可是，呵呵，我还是想用回迅雷极速版，迅雷于我而言只是一个下载器，我不需要它所提供的其他功能！Resilio Sync一个基于P2P技术的多平台文件共享工具，其文件共享不需要经过云端服务器，所以它不限速、不限文件大小、不需要注册账户 。不过最近一个多月以来，由于一个不可明说但人人知道的原因，导致这个软件抽风了，使很多人都失联了。不过，黑夜中总会有一点曙光的。如果你失联了，点一下这里吧。在这，就再次贡献个链接吧。PDF浏览器：SumatraPDF我用它的原因，主要是它体积足够迷你，且启动速度快，非常适合在平板上使用。其实如果你有注意到，在我推荐的其它软件中大部分的体积都是十分迷人的！哈哈哈Foxit在我的笔记本电脑中，我浏览PDF主要是用Foxit的，其界面还可以，不过吸引我的主要是它的侧面工具栏，十分方便！图片浏览器：IrfanView体积迷你，启动速度快。很多时候对图片只是想单纯的浏览，而不想要其它不必要的功能！云盘：百度网盘我就不想多说了，相信大家都知道。Google Drive15G免费的云储存空间试用，不过受墙的影响，想用就自己想办法了。如果想不用钱又大空间存储的话，貌似只有百度云盘了。系统篇优化：Advanced Systemcare一个国外优化软件，由于伟大的￥G*F·W#，软件在大陆境内不能实现自动升级，所以需要科学上网。另外软件需要注册码，大家有条件的就支持一下正版吧。如果是学生党可以去百度贴吧那里搜刮一下注册码。在这我就贡献一下自己的注册码。5F90C-4A11F-1BD01-DAC74Process Lasso一个系统进程优先级优化软件，软件默认的设置已经帮我们优化好了，如果不是特别懂，最好不要改动里面的默认设置。Adguard可以拦截很多桌面上弹出的广告，且软件支持自定义安装各种拦截插件。杀毒：火绒堪称国产良心，我喜欢它的弹窗拦截，除了比它默认拦截的弹窗之外，有其它弹窗时，按一下Alt + Shift + A(软件默认的，可以自己改)选择要剔除的弹窗，然后你就真的永远见不到那个弹窗了，废话不多说，自己试过才知道。解压：7-Zip体积迷人，高压缩比率，极客必备。效率：AutoHotKey一个脚本解释语言，解释器本身体积非常小，然后自己写要运行的脚本。当然了，网上也有很多已经写好的脚本，自己可以按需求去发现。一句话就是： 只要你会用，它无所不能。在此附上一个教程Wox一款快速启动的软件，速度快的，体积迷你。文件搜索配合Everything使用，效果更佳。Everything是一款文件搜索软件，比Windows自带的文件搜索快太多太多了。Listary其效果就等于 Wox + Everything，至于用哪个就看个人喜好吧！附上一个教程Seer一款文件预览软件，体积迷你，按个Space键，可以预览文件信息，其所支持的文件格式十分多，例如可以支持C、Java等编程语言文件的语法高亮预览；还有歌曲的预览、PPT、PDF等格式文件的预览，十分方便，启动速度也很快。F.lux一个护眼软件，作者已经多年没有更新了。不过功能够用。我本人十分喜欢它的夜间模式，即使周围没有光线，电脑屏幕也不刺眼。MacType把Windows不顺眼的字体风格渲染成Mac Book的字体画风。因为可以选择注册表方式加载，所以就不会拖慢电脑开机速度FileNote当文件繁多的时候(例如自己不熟悉的软件或一些不可备注的压缩包)，经常会不知道当前的文件要来干嘛的，此时可以使用FileNote对文件的用途进行备注，下次一看就知道这个文件是用来干嘛的了。Ditto一个剪切板工具，可保存最近的剪切记录或实现跨电脑跨平台剪切复制，且其所剪切的记录不单单是文本，也可以是图片、HTML等。网上有很多关于Ditto的使用技巧，我就不一一罗列了学习&amp;工作篇笔记：Leanote又称蚂蚁笔记，一款集笔记、博客、协作、私有云的笔记。其实，我之前是一直在用印象笔记的，碍于其对markdown语法支持一般，所以我就转入了Leanote，再者，蚂蚁笔记的主题自己改一下还是挺好看的。不过有一点还不太好，就是蚂蚁笔记现在还不支持对文章的加密，有点小小的遗憾！EverNote分为国际版(EverNote)、国内版(印象笔记)，两个的数据库是不相连接的。所以如果要使用，记得区分好，我一开始使用的时候就掉到了这个坑里。哈哈哈翻译：Lingoes文本翻译软件，功能还算全面，支持屏幕取词，划词翻译。不要问我为什么不用有道笔记，我不会告诉你是因为它经常弹窗骚扰的！SSH：PuttyWindows下对Unix系统的远程控制终端，体积迷你。WinSCP一款开源的SFTP客户端。我的用途就是远程登录云端服务器。文本编辑器：gVimWindows平台下的Vim，在Linux下玩久了，回到Windows不习惯的话，可以试试它。Sublime Text 3前端程序员必备，它拥有庞大的插件源，因此可以拓展许多炫酷实用的功能。反正我现在都是用它来写博客的。Notepad++一个程序员自由开发文本编辑软件。文本比较：Beyond Compare一个文本内容比较软件，我就不多说了。科学上网篇:XX-Net它是GitHub上一个开源的项目，相对于其他科学上网的VPN，xx-net是十分彪悍稳定的，当然天下没有免费的午餐，不想做小白就要自己一步一步地配置，配置过程可能有点小长。所以，怕折腾者勿点教程娱乐篇视频播放器：Potplayer拥有KMPlayer的硬件加速，界面简洁且功能强大，支持格式众多。音乐播放器：Mcool一个短小精悍的本地音乐播放器。网易云音乐喜欢它，主要是网易云的云端歌曲推送真心不错。桌面美化：火萤动态桌面，工作疲累时，看一看，还是挺恰意的。没有最好的软件，只有最适合自己的软件以上所列举的软件是我所用过的软件，如果你有更好的软件，也可以推荐我一下！]]></content>
      <categories>
        <category>Geek</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>优雅</tag>
        <tag>极客</tag>
        <tag>效率</tag>
        <tag>必备</tag>
        <tag>win10</tag>
        <tag>干货</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前言]]></title>
    <url>%2Fposts%2FWTF.html</url>
    <content type="text"><![CDATA[闻道有先后，术业有专攻，如是而已最近有点时间，所以就花了两天的时间搭建了这个博客。有人问我，你浪费那么多时间搭建这个博客，要来干嘛用？说实话，有时候挺怕遇到这种不太开明的朋友的。搭建一个博客于我而言，是一个个人言论空间（相对网络上很多著名的言论平台，自己发的帖不会被平台随意删除）。另外，我是一个比较爱折腾（你可以说我犯贱）的人，搭建博客对我这种菜鸟而言是一个提高的机会。因为最近半年多都在学习ARM Linux，所以最近一段时间会把这半年来学的东西总结一下。另外，对于51单片机、STM32、ZigBee、WiFi，后期如果有时间我也会总结一下！！！当然了，时不时我还是会附送一点小干货的！！！博客刚开始搭建起来，很多细节还不是做得很好！！！见谅啊！！！]]></content>
  </entry>
</search>
