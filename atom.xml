<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JM.Lin&#39;s Blogs</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.jmlin.top/"/>
  <updated>2018-09-27T03:29:53.666Z</updated>
  <id>https://blog.jmlin.top/</id>
  
  <author>
    <name>JM.Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.CentOS环境搭建Hadoop集群</title>
    <link href="https://blog.jmlin.top/posts/2-CentOS%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAHadoop%E9%9B%86%E7%BE%A4.html"/>
    <id>https://blog.jmlin.top/posts/2-CentOS环境搭建Hadoop集群.html</id>
    <published>2018-09-27T02:57:48.000Z</published>
    <updated>2018-09-27T03:29:53.666Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:31:15 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><blockquote><p><strong><code>注</code></strong>：本文在已经使用VMware虚拟机安装了CentOS6.5_64位镜像基础下进行操作（如还未安装，可参考该<a href="https://blog.csdn.net/sl1992/article/details/52871418" target="_blank" rel="external">链接</a>）；以下所有关于命令行操作均以<code>root</code>用户操作，其设计相关的<strong><code>文件名称</code></strong>和<strong><code>目录名称</code></strong>不一定全部相同，请按照实际情况修改。</p></blockquote><h1 id="1-基础配置"><a href="#1-基础配置" class="headerlink" title="1. 基础配置"></a>1. 基础配置</h1><h2 id="基础软件安装"><a href="#基础软件安装" class="headerlink" title="基础软件安装"></a>基础软件安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install vim -y</div></pre></td></tr></table></figure><h2 id="共享目录配置"><a href="#共享目录配置" class="headerlink" title="共享目录配置"></a>共享目录配置</h2><ul><li>在VMware顶栏点击<code>虚拟机</code>-&gt;<code>安装VMWare Tools</code></li><li>此时虚拟机弹出一个光盘镜像，以下命令行操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">tar -zxvf /media/VMware\ Tools/VMwareTools-10.1.6-5214329.tar.gz -C /home/jmlin/</div><div class="line">cd /home/jmlin/vmware-tools-distrib</div><div class="line">sudo ./vmware-install.pl</div></pre></td></tr></table></figure><ul><li>之后一直按回车，默认设置</li><li>在VMware顶栏点击<code>虚拟机</code>-&gt;<code>设置</code>-&gt;<code>选项</code>-&gt;<code>共享文件夹</code>-&gt;<code>总是启用</code></li><li>在右边框选择<code>添加</code>-&gt;<code>下一步</code>-&gt;选择自己要共享的文件夹的路径-&gt;一路确定</li><li>命令行<code>reboot</code>重启虚拟机</li></ul><h2 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h2><p>a. <strong>图形界面操作</strong><br><img src="http://p1crnqdyo.bkt.clouddn.com/images/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP_master.png" alt=""></p><p>b. <code>命令行操作</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth</div><div class="line">------</div><div class="line">DEVICE=eth0             # 网卡设备名</div><div class="line">BOOTPROTO=static        # 获取静态IP</div><div class="line"># BOOTPROTO=dhcp        # 通过DHCP协议获取IP</div><div class="line"># BOOTPROTO=bootp       # 通过BOOTP协议获取IP</div><div class="line">ONBOOT=yes              # 自动联网</div><div class="line">NM_CONTROLLED=yes</div><div class="line">IPADDR=192.168.0.110 </div><div class="line">NETMASK=255.255.255.0  </div><div class="line">GATEWAY=192.168.0.1  </div><div class="line">DNS1=192.168.0.1        # 设置为路由器IP</div><div class="line">------</div><div class="line">service network restart</div></pre></td></tr></table></figure><h2 id="DNS解析、修改主机名"><a href="#DNS解析、修改主机名" class="headerlink" title="DNS解析、修改主机名"></a>DNS解析、修改主机名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">vi /etc/hosts</div><div class="line">------</div><div class="line">192.168.0.110 master</div><div class="line">192.168.0.111 slave1</div><div class="line">192.168.0.112 slave2</div><div class="line">                ·   (设置从机名)</div><div class="line">                ·</div><div class="line">                ·</div><div class="line">------</div><div class="line">source /etc/hosts</div><div class="line"></div><div class="line">vi /etc/sysconfig/network</div><div class="line">将`HOSTNAME=localhost.localdomain`改为</div><div class="line">------</div><div class="line">HOSTNAME=master</div><div class="line">------</div><div class="line">hostname master     # 令修改立即生效</div></pre></td></tr></table></figure><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service iptables stop</div><div class="line">chkconfig iptables off</div><div class="line">service iptables status</div></pre></td></tr></table></figure><h2 id="系统自动登录"><a href="#系统自动登录" class="headerlink" title="系统自动登录"></a>系统自动登录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vi /etc/gdm/custom.conf</div><div class="line">------</div><div class="line">[daemon]</div><div class="line">AutomaticLoginEnable=true</div><div class="line">AutomaticLogin=jmlin</div><div class="line">------</div></pre></td></tr></table></figure><h2 id="设置root弱密码"><a href="#设置root弱密码" class="headerlink" title="设置root弱密码"></a>设置root弱密码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">vi /etc/pam.d/system-auth</div><div class="line">------</div><div class="line">password    requisite     pam_cracklib.so try_first_pass retry=3 type= minlen=5</div><div class="line">------</div></pre></td></tr></table></figure><ul><li>由于是本地操作，所以就设置一个短的密码，一般生产环境不建议设置太短</li></ul><h2 id="配置SSH免密登录"><a href="#配置SSH免密登录" class="headerlink" title="配置SSH免密登录"></a>配置SSH免密登录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum install openssh-server -y</div><div class="line">ssh-keygen -t rsa</div><div class="line">三次回车</div><div class="line">cd ~/.ssh/</div><div class="line">cp id_rsa.pub authorized_keys</div><div class="line">chkconfig sshd on   # 配置sshd自启动</div></pre></td></tr></table></figure><h2 id="创建hadoop用户"><a href="#创建hadoop用户" class="headerlink" title="创建hadoop用户"></a>创建<code>hadoop</code>用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /home/hadoop</div><div class="line">useradd -d /home/hadoop -m hadoop</div><div class="line">passwd hadoop</div></pre></td></tr></table></figure><hr><h1 id="2-JDK"><a href="#2-JDK" class="headerlink" title="2. JDK"></a>2. JDK</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">rpm -ivh jdk-8u51-linux-x64.rpm</div><div class="line">mv /usr/java/jdk1.8.0_51 /usr/local/jdk</div><div class="line">vi ~/.bashrc</div><div class="line">------</div><div class="line"># 在文件最后添加</div><div class="line">export JAVA_HOME=/usr/local/jdk</div><div class="line">export PATH=$JAVA_HOME/bin:$PATH</div><div class="line">------</div><div class="line">source ~/.bashrc</div><div class="line">java -version</div></pre></td></tr></table></figure><hr><h1 id="3-Hadoop"><a href="#3-Hadoop" class="headerlink" title="3. Hadoop"></a>3. Hadoop</h1><h2 id="伪分布式安装"><a href="#伪分布式安装" class="headerlink" title="伪分布式安装"></a>伪分布式安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">tar zxvf hadoop-2.6.2.tar.gz -C /usr/local/</div><div class="line">cd !$</div><div class="line">mv hadoop-2.6.2 hadoop</div><div class="line">vi ~/.bashrc</div><div class="line">------</div><div class="line">alias cdha=&apos;cd /usr/local/hadoop&apos;</div><div class="line">export HADOOP_HOME=/usr/local/hadoop</div><div class="line">export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATH</div><div class="line">------</div><div class="line">source !$</div></pre></td></tr></table></figure><h2 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h2><h3 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a><strong><code>hadoop-env.sh</code></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cdha</div><div class="line">cd etc/hadoop</div><div class="line">vi hadoop-env.sh</div><div class="line">将`export JAVA_HOME=$&#123;JAVA_HOME&#125;`替换为</div><div class="line">------</div><div class="line">export JAVA_HOME=/usr/local/jdk</div><div class="line">------</div></pre></td></tr></table></figure><h3 id="yarn-env-sh"><a href="#yarn-env-sh" class="headerlink" title="yarn-env.sh"></a><strong><code>yarn-env.sh</code></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vi yarn-env.sh</div><div class="line">将`23行`替换为</div><div class="line">------</div><div class="line">export JAVA_HOME=/usr/local/jdk</div><div class="line">------</div></pre></td></tr></table></figure><h3 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a><strong><code>core-site.xml</code></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">vi core-site.xml</div><div class="line">------</div><div class="line">&lt;configuration&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</div><div class="line">     &lt;value&gt;hdfs://master:9000&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</div><div class="line">     &lt;value&gt;/home/hadoop/tmp&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;hadoop.native.lib&lt;/name&gt;</div><div class="line">     &lt;value&gt;false&lt;/value&gt;</div><div class="line">     &lt;description&gt;Should native hadoop libraries, if present, be used.&lt;/description&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div><div class="line">------</div></pre></td></tr></table></figure><h3 id="hdfs-site-xml"><a href="#hdfs-site-xml" class="headerlink" title="hdfs-site.xml"></a><strong><code>hdfs-site.xml</code></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">vi hdfs-site.xml</div><div class="line">------</div><div class="line">&lt;configuration&gt;</div><div class="line"> &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</div><div class="line">     &lt;value&gt;3&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.name.dir&lt;/name&gt;</div><div class="line">     &lt;value&gt;/home/hadoop/hdfs/name&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;dfs.data.dir&lt;/name&gt;</div><div class="line">     &lt;value&gt;/home/hadoop/hdfs/data&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div><div class="line">------</div></pre></td></tr></table></figure><h3 id="yarn-site-xml"><a href="#yarn-site-xml" class="headerlink" title="yarn-site.xml"></a><strong><code>yarn-site.xml</code></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">vi yarn-site.xml</div><div class="line">------</div><div class="line">&lt;configuration&gt;</div><div class="line"></div><div class="line">&lt;!-- Site specific YARN configuration properties --&gt;</div><div class="line"></div><div class="line"> &lt;property&gt;</div><div class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</div><div class="line">     &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line"> &lt;property&gt;</div><div class="line">    &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt;</div><div class="line">     &lt;value&gt;org.apache.hadoop.mapred.ShuffleHandler&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line"> &lt;property&gt;</div><div class="line">    &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</div><div class="line">     &lt;value&gt;master:18088&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div><div class="line">------</div></pre></td></tr></table></figure><h3 id="mapred-site-xml"><a href="#mapred-site-xml" class="headerlink" title="mapred-site.xml"></a><strong><code>mapred-site.xml</code></strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">cp mapred-site.xml.template mapred-site.xml</div><div class="line">vi !$</div><div class="line">------</div><div class="line">&lt;configuration&gt;</div><div class="line"> &lt;property&gt;</div><div class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</div><div class="line">    &lt;value&gt;yarn&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</div><div class="line">    &lt;value&gt;master:10020&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">  &lt;property&gt;</div><div class="line">    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</div><div class="line">    &lt;value&gt;master:19888&lt;/value&gt;</div><div class="line">  &lt;/property&gt;</div><div class="line">&lt;/configuration&gt;</div><div class="line">------</div></pre></td></tr></table></figure><h3 id="At-Last"><a href="#At-Last" class="headerlink" title="At Last"></a>At Last</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hdfs namenode –format   # 格式化文件系统</div><div class="line">start-all.sh</div><div class="line">jps                     # 查看Java进程状态</div></pre></td></tr></table></figure><p><img src="http://p1crnqdyo.bkt.clouddn.com/images/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3/%E5%90%AF%E5%8A%A8hadoop%E6%98%BE%E7%A4%BA.png" alt=""></p><h2 id="出现警告"><a href="#出现警告" class="headerlink" title="出现警告"></a>出现警告</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</div></pre></td></tr></table></figure><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vi /usr/local/hadoop/etc/hadoop/log4j.properties</div><div class="line">添加一行，用于消除因hadoop希望glibc版本为2.14以上的警告信息</div><div class="line">------</div><div class="line">log4j.logger.org.apache.hadoop.util.NativeCodeLoader=ERROR</div><div class="line">------</div></pre></td></tr></table></figure><h2 id="MapReduce使用"><a href="#MapReduce使用" class="headerlink" title="MapReduce使用"></a>MapReduce使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/hadoop/share/hadoop/mapreduce</div><div class="line">hadoop jar hadoop-mapreduce-example-2.6.2.jar   # 查看包中的功能</div><div class="line"></div><div class="line"># 统计文件中单词重复的次数</div><div class="line">hadoop jar hadoop-mapreduce-example-2.6.2.jar wordcount     # 查看wordcount用法</div><div class="line">cd </div><div class="line">touch ReadMe.txt</div><div class="line">echo &apos;Hello World&apos; &gt; ReadMe.txt</div><div class="line">hadoop fs -put ./ReadMe.txt /</div><div class="line">cd -</div><div class="line">hadoop jar hadoop-mapreduce-example-2.6.2.jar wordcount /ReadMe.txt /wordcount_output</div><div class="line">hadoop fs -text /wordcount_output/part-r-00000</div></pre></td></tr></table></figure><hr><h1 id="4-分布式安装"><a href="#4-分布式安装" class="headerlink" title="4. 分布式安装"></a>4. 分布式安装</h1><blockquote><p>以下操作，想要使用多少台从机就设置多少次</p></blockquote><h2 id="导出虚拟机"><a href="#导出虚拟机" class="headerlink" title="导出虚拟机"></a>导出虚拟机</h2><ul><li>先把要复制的虚拟机关机</li><li>VMware状态栏-&gt;<code>文件</code>-&gt;<code>导出为OVF</code></li></ul><h2 id="设置静态IP-1"><a href="#设置静态IP-1" class="headerlink" title="设置静态IP"></a>设置静态IP</h2><p><img src="http://p1crnqdyo.bkt.clouddn.com/images/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3/%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP_slave1.png" alt="设置静态IP"></p><h2 id="DNS解析、修改主机名-1"><a href="#DNS解析、修改主机名-1" class="headerlink" title="DNS解析、修改主机名"></a>DNS解析、修改主机名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[root@slave1 hadoop]# vi /etc/hosts</div><div class="line">------</div><div class="line">192.168.0.110 master</div><div class="line">192.168.0.111 slave1</div><div class="line">192.168.0.112 slave2</div><div class="line">                ·   (设置从机名)</div><div class="line">                ·</div><div class="line">                ·</div><div class="line">------</div><div class="line"></div><div class="line">[root@slave1 hadoop]# vi /etc/sysconfig/network</div><div class="line">将`HOSTNAME=master`改为</div><div class="line">------</div><div class="line">HOSTNAME=slave1</div><div class="line">------</div><div class="line">[root@slave1 hadoop]# hostname slave1     # 令修改立即生效</div></pre></td></tr></table></figure><hr><h1 id="5-集群间SSH免密登录"><a href="#5-集群间SSH免密登录" class="headerlink" title="5. 集群间SSH免密登录"></a>5. 集群间SSH免密登录</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 主节点</div><div class="line">[root@master hadoop]# ssh-copy-id -i ~/.ssh/id_rsa.pub slave1</div><div class="line"></div><div class="line"># 从节点</div><div class="line">[root@slave1 hadoop]# ssh-copy-id -i ~/.ssh/id_rsa.pub master</div></pre></td></tr></table></figure><hr><h1 id="6-格式化文件系统"><a href="#6-格式化文件系统" class="headerlink" title="6. 格式化文件系统"></a>6. 格式化文件系统</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># 从节点</div><div class="line">[root@slave1 hadoop]# rm -rf /home/hadoop/tmp/*</div><div class="line">[root@slave1 hadoop]# rm -rf /home/hadoop/hdfs/name/*</div><div class="line">[root@slave1 hadoop]# rm -rf /home/hadoop/hdfs/data/*</div><div class="line"></div><div class="line"># 主节点</div><div class="line">[root@master hadoop]# rm -rf /home/hadoop/tmp/*</div><div class="line">[root@master hadoop]# rm -rf /home/hadoop/hdfs/name/*</div><div class="line">[root@master hadoop]# rm -rf /home/hadoop/hdfs/data/*</div><div class="line"></div><div class="line">[root@master hadoop]# hdfs namenode -format</div></pre></td></tr></table></figure><hr><h1 id="7-启动集群"><a href="#7-启动集群" class="headerlink" title="7. 启动集群"></a>7. 启动集群</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># 主机</div><div class="line">[root@master hadoop]# start-all.sh</div><div class="line">[root@master hadoop]# jps</div><div class="line">[root@master hadoop]# hdfs dfsadmin -report     # 查看结点状态报告</div><div class="line"></div><div class="line"># 从机</div><div class="line">[root@slave1 hadoop]# jps</div></pre></td></tr></table></figure><h2 id="Web-UI-查看集群是否启动成功"><a href="#Web-UI-查看集群是否启动成功" class="headerlink" title="Web UI 查看集群是否启动成功"></a>Web UI 查看集群是否启动成功</h2><ul><li>浏览器打开</li><li><p><code>http://master:50070</code><br><img src="http://p1crnqdyo.bkt.clouddn.com/images/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3/Namenode_information1.png" alt=""><br><img src="http://p1crnqdyo.bkt.clouddn.com/images/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3/Namenode_information2.png" alt=""></p></li><li><p><code>http://master:18088</code><br><img src="http://p1crnqdyo.bkt.clouddn.com/images/%E4%BA%91%E8%AE%A1%E7%AE%97%E7%9B%B8%E5%85%B3/All_Application.png" alt=""></p></li></ul><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://linux.cn/article-8486-1.html" target="_blank" rel="external">在树莓派上通过 Apache Spark on YARN 搭建 Hadoop 集群</a></li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:31:15 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="云计算与物联网" scheme="https://blog.jmlin.top/categories/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
      <category term="hadoop" scheme="https://blog.jmlin.top/tags/hadoop/"/>
    
      <category term="分布式云计算" scheme="https://blog.jmlin.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>1.话说大数据</title>
    <link href="https://blog.jmlin.top/posts/1-%E8%AF%9D%E8%AF%B4%E5%A4%A7%E6%95%B0%E6%8D%AE.html"/>
    <id>https://blog.jmlin.top/posts/1-话说大数据.html</id>
    <published>2018-09-17T15:00:48.000Z</published>
    <updated>2018-09-18T06:50:59.625Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>一些简单的关于云计算的基础概念总结<br><a id="more"></a></p><blockquote><p>特征：<code>大量化</code>、<code>快速化</code>、<code>多样化</code>、<strong><code>价值化</code></strong></p></blockquote><ul><li>IT基础设施<ul><li>1.云计算</li><li>2.虚拟化</li><li>3.大数据</li><li>4.Hadoop生态圈(分布式存储与并行计算及其框架)</li></ul></li></ul><h1 id="1-关键技术"><a href="#1-关键技术" class="headerlink" title="1. 关键技术"></a>1. 关键技术</h1><h2 id="1-1-数据采集"><a href="#1-1-数据采集" class="headerlink" title="1.1 数据采集"></a>1.1 数据采集</h2><ul><li>利用<strong>ETL</strong>工具将分布的、异构数据源中的数据(如关系数据、平面数据文件)，抽取到临时中间层后进行清洗、转换、集成</li><li>最后加载到<code>数据仓库</code>或<code>数据集市</code>中，成为<code>联机分析处理</code>、<code>数据挖掘</code>的基础</li><li>或者可以把<strong>实时采集的数据</strong>作为<strong>流计算系统</strong>的输入，进行实时处理分析</li></ul><h2 id="1-2-数据存储和管理"><a href="#1-2-数据存储和管理" class="headerlink" title="1.2 数据存储和管理"></a>1.2 数据存储和管理</h2><ul><li>利用<strong>分布式文件系统</strong>、<strong>数据仓库</strong>、<strong>关系数据库</strong>、<strong>NoSQL</strong>、<strong>云数据库</strong>等</li><li>实现对<code>结构化</code>、<code>半结构化</code>和<code>非结构化</code>海量数据的存储和管理</li></ul><h2 id="1-3-数据处理与分析"><a href="#1-3-数据处理与分析" class="headerlink" title="1.3 数据处理与分析"></a>1.3 数据处理与分析</h2><ul><li>利用<strong>分布式并行编程模型</strong>和<strong>计算框架</strong>，结合<strong>机器学习</strong>和<strong>数据挖掘算法</strong></li><li>实现对海量数据的处理和分析(对分析结果进行可视化呈现，帮助人们更好地理解数据、分析数据)</li></ul><h2 id="1-4-数据隐私和安全"><a href="#1-4-数据隐私和安全" class="headerlink" title="1.4 数据隐私和安全"></a>1.4 数据隐私和安全</h2><ul><li>在从大数据中挖掘潜在的巨大商业价值和学术价值的同时，构建<strong>隐私数据保护体系</strong>和<strong>数据安全体系</strong>，有效保护个人隐私和数据安全</li></ul><hr><h1 id="2-Hadoop生态圈"><a href="#2-Hadoop生态圈" class="headerlink" title="2. Hadoop生态圈"></a>2. Hadoop生态圈</h1><ul><li>资源<ul><li><strong><code>HDFS存储</code></strong></li><li><strong><code>MapReduce框架</code></strong></li></ul></li><li>服务<ul><li><strong><code>HDFS操作</code></strong></li><li><strong><code>HDFS编程</code></strong></li><li><strong><code>MapReduce提供分布式并行计算</code></strong></li><li><strong><code>HBase数据库</code></strong></li><li><strong><code>Hive数据仓库</code></strong></li></ul></li></ul><hr><ul><li>数据库与数据仓库对比<ul><li>数据仓库的数据一般由数据库的数据经过一定的规则转换得到</li><li>数据仓库主要用来分析数据，一般是TB级数据(如决策支持系统、数据挖掘)</li></ul></li></ul><table><thead><tr><th style="text-align:center">数据仓库</th><th style="text-align:center">数据库</th></tr></thead><tbody><tr><td style="text-align:center">面向分析</td><td style="text-align:center">面向事务处理</td></tr><tr><td style="text-align:center">数据基本不变</td><td style="text-align:center">根据日常业务而更新</td></tr></tbody></table><hr><h1 id="3-大数据计算模式"><a href="#3-大数据计算模式" class="headerlink" title="3. 大数据计算模式"></a>3. 大数据计算模式</h1><table><thead><tr><th style="text-align:center">典型大数据计算模式</th><th style="text-align:center">典型系统</th></tr></thead><tbody><tr><td style="text-align:center">批处理计算</td><td style="text-align:center"><code>Hadoop MapReduce</code>，<strong><code>Spark</code></strong>等</td></tr><tr><td style="text-align:center">流式计算</td><td style="text-align:center">Scribe，Flume，<strong><code>Storm</code></strong>，S4, Spark Steaming等</td></tr><tr><td style="text-align:center">迭代计算</td><td style="text-align:center">HaLoop，iMapReduce，Twister，Spark等</td></tr><tr><td style="text-align:center">图计算</td><td style="text-align:center">Pregel，Giraph，Trinity，PowerGraph，<strong><code>GraphX</code></strong>等</td></tr><tr><td style="text-align:center">内存计算</td><td style="text-align:center">Dremel，Hana，Spark等</td></tr><tr><td style="text-align:center">大数据查询分析计算</td><td style="text-align:center">HBase，<strong><code>Hive</code></strong>，Cassandra，Impala，Shark，Hana等</td></tr></tbody></table><hr><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;一些简单的关于云计算的基础概念总结&lt;br&gt;
    
    </summary>
    
      <category term="云计算与物联网" scheme="https://blog.jmlin.top/categories/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
    
  </entry>
  
  <entry>
    <title>话说字符设备驱动</title>
    <link href="https://blog.jmlin.top/posts/%E8%AF%9D%E8%AF%B4%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8.html"/>
    <id>https://blog.jmlin.top/posts/话说字符设备驱动.html</id>
    <published>2018-05-02T12:18:43.000Z</published>
    <updated>2018-05-03T03:25:52.272Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>最近在学习字符设备驱动，涉及到很多框架层面的东西，这里就来记录一下。<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li><p>开始，就先把框架图放出来。</p><img src="http://p1crnqdyo.bkt.clouddn.com/images/话说字符设备驱动\框架图.png"></li><li><p>在用户空间通过<code>insmod</code>调用<code>module_init</code>模块加载函数激活相应的设备驱动初始化函数</p></li><li>接着就是添加字符设备驱动<ul><li>在字符设备驱动初始化前，先要分配主次设备号</li><li>在对应目录中创建相应的类文件和设备文件</li><li>并填充<code>file_operations</code>结构体</li></ul></li><li>字符设备驱动注册到内核后就可以使用之前应用层的<code>read</code>、<code>write</code>、<code>ioctl</code>等函数<ul><li>应用层所使用的对文件进行读写操作的函数都绑定了<code>file_operations</code>中的方法</li></ul></li></ul><hr><h1 id="应用层调用接口"><a href="#应用层调用接口" class="headerlink" title="应用层调用接口"></a>应用层调用接口</h1><p><strong>常用方法</strong>：</p><ol><li><strong><code>open</code></strong>打开设备文件</li><li><strong><code>read</code></strong>读取设备文件内容</li><li><strong><code>write</code></strong>写入设备文件内容</li><li><strong><code>ioctl</code></strong>进行IO操作</li><li><strong><code>close</code></strong>关闭设备文件</li></ol><h1 id="设备类"><a href="#设备类" class="headerlink" title="设备类"></a>设备类</h1><ul><li><strong><code>struct kobject</code></strong>数据结构在sysfs中代表一个目录</li><li><strong><code>struct driver</code></strong>、<strong><code>struct device</code></strong>、<strong><code>struct class</code></strong>均由<strong><code>kobject</code></strong>派生</li><li><strong><code>struct driver_attribute</code></strong>、<strong><code>struct device_attribute</code></strong>、<strong><code>struct class_attribute</code></strong>代表普通文件</li><li><strong><code>struct kset</code></strong>是<strong><code>struct kobject</code></strong>的容器，可以成为同一类<strong><code>struct kobject</code></strong>的父亲，而其自身也有<strong><code>struct kobject</code></strong>成员，因此其又可以和其他<strong><code>struct kobject</code></strong>成为上一级<strong><code>struct kset</code></strong>的子成员</li></ul><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="cdev"><a href="#cdev" class="headerlink" title="cdev"></a><code>cdev</code></h2><ul><li>这个是存放字符设备驱动的相关数据的结构体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct cdev &#123;</div><div class="line">    struct kobject kobj;                </div><div class="line">    struct module *owner;               // 指向实现驱动的模块</div><div class="line">    const struct file_operations *ops;  // 操纵该字符设备文件的方法</div><div class="line">    struct list_head list;              // 对应字符设备文件的inode-&gt;i_devices的链表头</div><div class="line">    dev_t dev;                          // 设备号</div><div class="line">    unsigned int count;                 // 次设备个数</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h2 id="file-operation"><a href="#file-operation" class="headerlink" title="file_operation"></a><code>file_operation</code></h2><ul><li>定义字符设备驱动提供给<code>VFS</code>的接口函数集</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">struct file_operations &#123;</div><div class="line">    struct module *owner;</div><div class="line">    loff_t (*llseek) (struct file *, loff_t, int);</div><div class="line">    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</div><div class="line">    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</div><div class="line">    ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</div><div class="line">    ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);</div><div class="line">    int (*readdir) (struct file *, void *, filldir_t);</div><div class="line">    unsigned int (*poll) (struct file *, struct poll_table_struct *);</div><div class="line">    int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);</div><div class="line">    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</div><div class="line">    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</div><div class="line">    int (*mmap) (struct file *, struct vm_area_struct *);</div><div class="line">    int (*open) (struct inode *, struct file *);</div><div class="line">    int (*flush) (struct file *, fl_owner_t id);</div><div class="line">    int (*release) (struct inode *, struct file *);</div><div class="line">    int (*fsync) (struct file *, int datasync);</div><div class="line">    int (*aio_fsync) (struct kiocb *, int datasync);</div><div class="line">    int (*fasync) (int, struct file *, int);</div><div class="line">    int (*lock) (struct file *, int, struct file_lock *);</div><div class="line">    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</div><div class="line">    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</div><div class="line">    int (*check_flags)(int);</div><div class="line">    int (*flock) (struct file *, int, struct file_lock *);</div><div class="line">    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);</div><div class="line">    ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);</div><div class="line">    int (*setlease)(struct file *, long, struct file_lock **);</div><div class="line">&#125;;</div></pre></td></tr></table></figure><hr><h1 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h1><ul><li>由于年代的变迁，字符设备号的分配接口有新的和旧的，不过它们的底层还是调用了相同的函数</li></ul><h2 id="1-分配字符设备号-旧接口"><a href="#1-分配字符设备号-旧接口" class="headerlink" title="1. 分配字符设备号(旧接口)"></a>1. 分配字符设备号(旧接口)</h2><h3 id="①-分配"><a href="#①-分配" class="headerlink" title="① 分配"></a><code>① 分配</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static inline int register_chrdev(unsigned int major, const char *name,</div><div class="line">                 const struct file_operations *fops)</div></pre></td></tr></table></figure><ul><li>传入参数分别为主设备号、设备名称、文件操作集</li></ul><h3 id="②-释放"><a href="#②-释放" class="headerlink" title="② 释放"></a><code>② 释放</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static inline void unregister_chrdev(unsigned int major, const char *name)</div></pre></td></tr></table></figure><ul><li>传入参数分别为主设备号、设备名称</li></ul><h2 id="2-分配字符设备号-新接口"><a href="#2-分配字符设备号-新接口" class="headerlink" title="2. 分配字符设备号(新接口)"></a>2. 分配字符设备号(新接口)</h2><h3 id="①-静态分配"><a href="#①-静态分配" class="headerlink" title="① 静态分配"></a><code>① 静态分配</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int register_chrdev_region(dev_t from, unsigned count, const char *name)</div></pre></td></tr></table></figure><ul><li>传入参数分别为设备号、设备数量、设备名称</li></ul><h3 id="②-动态分配"><a href="#②-动态分配" class="headerlink" title="② 动态分配"></a><code>② 动态分配</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,</div><div class="line">            const char *name)</div></pre></td></tr></table></figure><ul><li>传入参数分别为设备号、次设备号基址、设备数量、设备名称</li></ul><h3 id="③-释放"><a href="#③-释放" class="headerlink" title="③ 释放"></a><code>③ 释放</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void unregister_chrdev_region(dev_t from, unsigned count)</div></pre></td></tr></table></figure><ul><li>传入参数分别为设备号、设备个数</li></ul><h2 id="3-创建设备文件"><a href="#3-创建设备文件" class="headerlink" title="3. 创建设备文件"></a>3. 创建设备文件</h2><ul><li>可以在应用层使用命令行<code>cat /proc/devices</code>查看所有设备的设备名、以及主次设备号</li></ul><h3 id="①-手工创建"><a href="#①-手工创建" class="headerlink" title="① 手工创建"></a>① 手工创建</h3><ul><li><code>mknod filename type major minor</code></li></ul><h3 id="②-自动创建"><a href="#②-自动创建" class="headerlink" title="② 自动创建"></a>② 自动创建</h3><h4 id="⑴-class-create"><a href="#⑴-class-create" class="headerlink" title="⑴ class_create"></a>⑴ <code>class_create</code></h4><ul><li>首先创建一个设备类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define class_create(owner, name)       \</div><div class="line">(&#123;                      \</div><div class="line">    static struct lock_class_key __key; \</div><div class="line">    __class_create(owner, name, &amp;__key);    \</div><div class="line">&#125;)</div></pre></td></tr></table></figure><h4 id="⑵-device-create"><a href="#⑵-device-create" class="headerlink" title="⑵ device_create"></a>⑵ <code>device_create</code></h4><ul><li>接着创建一个设备</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct device *device_create(struct class *class, struct device *parent,</div><div class="line">                 dev_t devt, void *drvdata, const char *fmt, ...)</div><div class="line">&#123;</div><div class="line">    va_list vargs;</div><div class="line">    struct device *dev;</div><div class="line"></div><div class="line">    va_start(vargs, fmt);</div><div class="line">    dev = device_create_vargs(class, parent, devt, drvdata, fmt, vargs);</div><div class="line">    va_end(vargs);</div><div class="line">    return dev;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在驱动代码中调用<code>class_create()</code>为设备创建一个设备类，再为每个设备调用<code>device_create()</code>创建对应的设备，udev(mdev)会自动创建一个设备文件</li></ul><blockquote><p>原理：利用<code>udev(mdev)</code>来实现设备文件的自动创建，由busybox配置。在加载模块的时候，用户空间的mdev会自动去<code>/sysfs</code>下相应的目录寻找对应的类从而创建设备结点</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// /etc/init.d/rcS</div><div class="line"></div><div class="line">#!/bin/sh</div><div class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">    ···中间省略···</div><div class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug          // 与这个运行脚本有关</div><div class="line">mdev -s</div><div class="line">    ···中间省略···</div></pre></td></tr></table></figure><h4 id="⑶-class-destroy"><a href="#⑶-class-destroy" class="headerlink" title="⑶ class_destroy"></a>⑶ <code>class_destroy</code></h4><ul><li>删除设备类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void class_destroy(struct class *cls)</div><div class="line">&#123;</div><div class="line">    if ((cls == NULL) || (IS_ERR(cls)))</div><div class="line">        return;</div><div class="line">    class_unregister(cls);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="⑷-device-destroy"><a href="#⑷-device-destroy" class="headerlink" title="⑷ device_destroy"></a>⑷ <code>device_destroy</code></h4><ul><li>删除设备</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void device_destroy(struct class *class, dev_t devt)</div><div class="line">&#123;</div><div class="line">    struct device *dev;</div><div class="line">    dev = class_find_device(class, NULL, &amp;devt, __match_devt);</div><div class="line">    if (dev) &#123;</div><div class="line">        put_device(dev);</div><div class="line">        device_unregister(dev);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="4-注册-注销字符设备驱动"><a href="#4-注册-注销字符设备驱动" class="headerlink" title="4. 注册/注销字符设备驱动"></a>4. 注册/注销字符设备驱动</h2><h3 id="①-cdev-alloc"><a href="#①-cdev-alloc" class="headerlink" title="① cdev_alloc"></a><code>① cdev_alloc</code></h3><ul><li>获取一个字符设备结构体</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">static struct cdev *pcdev = NULL;</div><div class="line">pcdev = cdev_alloc();</div></pre></td></tr></table></figure><h3 id="②-cdev-init"><a href="#②-cdev-init" class="headerlink" title="② cdev_init"></a><code>② cdev_init</code></h3><ul><li>字符设备驱动初始化</li><li>绑定字符设备结构体(cdev)与文件操作集(fops)</li><li><code>void cdev_init(struct cdev *cdev, const struct file_operations *fops)</code></li></ul><h3 id="③-cdev-add"><a href="#③-cdev-add" class="headerlink" title="③ cdev_add"></a><code>③ cdev_add</code></h3><ul><li>添加字符设备驱动</li><li>绑定字符设备驱动(cdev)与设备号(dev)</li><li><code>int cdev_add(struct cdev *p, dev_t dev, unsigned count)</code></li></ul><h3 id="④-cdev-del"><a href="#④-cdev-del" class="headerlink" title="④ cdev_del"></a><code>④ cdev_del</code></h3><ul><li>注销字符设备驱动</li><li><code>void cdev_del(struct cdev *p)</code></li></ul><h2 id="5-内核的虚拟地址映射"><a href="#5-内核的虚拟地址映射" class="headerlink" title="5. 内核的虚拟地址映射"></a>5. 内核的虚拟地址映射</h2><p>若需要用到gpio等资源就需要虚拟地址映射</p><h3 id="①-request-mem-region"><a href="#①-request-mem-region" class="headerlink" title="① request_mem_region"></a><code>① request_mem_region</code></h3><ul><li>向内核请求需要映射的内存资源</li><li><code>request_mem_region(start,n,name)</code></li></ul><h3 id="②-ioremap"><a href="#②-ioremap" class="headerlink" title="② ioremap"></a><code>② ioremap</code></h3><ul><li>映射传入的物理地址返回一个虚拟地址</li><li><code>ioremap(cookie,size)</code></li></ul><h3 id="③-iounmap"><a href="#③-iounmap" class="headerlink" title="③ iounmap"></a><code>③ iounmap</code></h3><ul><li>传入虚拟地址，取消地址映射</li><li><code>iounmap(cookie)</code></li></ul><h3 id="④-release-mem-region"><a href="#④-release-mem-region" class="headerlink" title="④ release_mem_region"></a><code>④ release_mem_region</code></h3><ul><li>释放内核请求需要映射的内存资源</li><li><code>release_mem_region(start,n)</code></li></ul><h2 id="6-Others"><a href="#6-Others" class="headerlink" title="6. Others"></a>6. Others</h2><h3 id="①-printk"><a href="#①-printk" class="headerlink" title="① printk"></a><code>① printk</code></h3><ul><li>内核信息打印函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#define KERN_EMERG    &quot;&lt;0&gt;&quot;    /* system is unusable */</div><div class="line">#define KERN_ALERT    &quot;&lt;1&gt;&quot;    /* action must be taken immediately */</div><div class="line">#define KERN_CRIT     &quot;&lt;2&gt;&quot;    /* critical conditions */</div><div class="line">#define KERN_ERR      &quot;&lt;3&gt;&quot;    /* error conditions */</div><div class="line">#define KERN_WARNING  &quot;&lt;4&gt;&quot;    /* warning conditions */</div><div class="line">#define KERN_NOTICE   &quot;&lt;5&gt;&quot;    /* normal but significant */</div><div class="line">#define KERN_INFO     &quot;&lt;6&gt;&quot;    /* informational */</div><div class="line">#define KERN_DEBUG    &quot;&lt;7&gt;&quot;    /* debug-level messages */</div><div class="line"></div><div class="line">#define DEFAULT_MESSAGE_LOGLEVEL 4 /* KERN_WARNING */</div><div class="line">// 未指定日志级别的printk的默认级别为DEFAULT_MESSAGE_LOGLEVEL</div><div class="line"></div><div class="line">printk(KERN_INFO &quot;Hello, world!/n&quot;);</div></pre></td></tr></table></figure><ul><li>使用命令行<code>cat /proc/sys/kernel/printk</code><br>显示： 4 4 1 7</li><li>分别表示<ul><li>当前控制台日志级别</li><li>未明确指定日志级别的默认信息日志级别</li><li>最高允许设置的控制台日志级别</li><li>引导时默认的日志级别</li></ul></li><li><code>dmesg</code>可查看<code>printk</code>打印的信息</li></ul><h3 id="②-copy-from-user"><a href="#②-copy-from-user" class="headerlink" title="② copy_from_user"></a><code>② copy_from_user</code></h3><ul><li>使用<code>file_operations</code>中的方法集 <code>write</code>函数将数据从用户空间复制到内核空间</li><li>`static inline unsigned long __must_check copy_from_user(void *to,<pre><code>const void __user *from, unsigned long n)`
</code></pre></li></ul><h3 id="③-copy-to-user"><a href="#③-copy-to-user" class="headerlink" title="③ copy_to_user"></a><code>③ copy_to_user</code></h3><ul><li>使用<code>file_operations</code>中的方法集 <code>read</code>函数将数据从内核空间复制到用户空间</li><li>`static inline unsigned long <strong>must_check copy_to_user(void </strong>user *to,<pre><code>const void *from, unsigned long n)`
</code></pre></li></ul><hr><blockquote><p>参考文章<br><a href="https://blog.csdn.net/yueqian_scut/article/details/45938557" target="_blank" rel="external">Linux字符设备驱动剖析</a><br><a href="http://blog.csdn.net/yueqian_scut/article/details/50935554" target="_blank" rel="external">深入理解Linux字符设备驱动</a></p></blockquote><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;最近在学习字符设备驱动，涉及到很多框架层面的东西，这里就来记录一下。&lt;br&gt;
    
    </summary>
    
      <category term="Linux驱动架构" scheme="https://blog.jmlin.top/categories/Linux%E9%A9%B1%E5%8A%A8%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="driver" scheme="https://blog.jmlin.top/tags/driver/"/>
    
      <category term="device" scheme="https://blog.jmlin.top/tags/device/"/>
    
      <category term="驱动" scheme="https://blog.jmlin.top/tags/%E9%A9%B1%E5%8A%A8/"/>
    
      <category term="设备" scheme="https://blog.jmlin.top/tags/%E8%AE%BE%E5%A4%87/"/>
    
      <category term="字符" scheme="https://blog.jmlin.top/tags/%E5%AD%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>ARM处理器概述</title>
    <link href="https://blog.jmlin.top/posts/ARM%E5%A4%84%E7%90%86%E5%99%A8.html"/>
    <id>https://blog.jmlin.top/posts/ARM处理器.html</id>
    <published>2018-01-28T14:56:28.000Z</published>
    <updated>2018-07-23T03:02:34.614Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>简单总结一下ARM处理器工作模式及其寄存器！</p><a id="more"></a><h1 id="一-异常与中断的理解"><a href="#一-异常与中断的理解" class="headerlink" title="一. 异常与中断的理解 "></a>一. <strong>异常与中断的理解</strong></h1><h2 id="Insight-One"><a href="#Insight-One" class="headerlink" title="Insight One"></a>Insight One</h2><ul><li>中断描述的主体是外设(向CPU发送信号)，异常描述的主体是CPU(接收信号)</li><li>中断是一个过程，是CPU在执行当前的程序的过程中因硬件或软件的原因插入了另一段程序运行的过程</li></ul><h2 id="Insight-Two"><a href="#Insight-Two" class="headerlink" title="Insight Two"></a>Insight Two</h2><ul><li>中断是异常的一种，异常分为中断异常(IRQ/FIQ)和非中断异常(SVC/Undefine/Abort)</li></ul><hr><h1 id="二-7个工作模式"><a href="#二-7个工作模式" class="headerlink" title="二. 7个工作模式"></a>二. <strong>7个工作模式</strong></h1><p>7个工作模式分别为：User, FIQ, IRQ, SVC, Abort, Undefine, System</p><h2 id="A-Normal-Mode"><a href="#A-Normal-Mode" class="headerlink" title="A. Normal Mode"></a><strong>A. Normal Mode</strong></h2><h4 id="1-User"><a href="#1-User" class="headerlink" title="1.User"></a>1.<code>User</code></h4><ul><li>用户模式</li><li>用户程序运行模式，运行在操作系统的用户态，没有权限去操作其他硬件资源，不能切换到其它模式下，只能执行处理自己的数据，要想访问硬件资源或切换其它模式只能通过软中断或产生异常</li></ul><h2 id="B-Privileged-Modes"><a href="#B-Privileged-Modes" class="headerlink" title="B. Privileged Modes"></a><strong>B. Privileged Modes</strong></h2><ul><li>特权模式</li><li>该组模式下可以任意访问系统资源<blockquote><p>其特权：<br><code>MRS</code>(把状态寄存器的内容放到通用寄存器)<br><code>MSR</code>(把通用寄存器的内容放到状态寄存器)<br>由于状态寄存器的内容不能够改变，因此先把内容复制到通用寄存器中，然后修改通用寄存器中的内容，再把通用寄存器中的内容复制给状态寄存器中，即可完成“修改状态寄存器”的任务</p></blockquote></li></ul><h3 id="异常模式"><a href="#异常模式" class="headerlink" title="异常模式"></a>异常模式</h3><h4 id="2-FIQ"><a href="#2-FIQ" class="headerlink" title="2.FIQ"></a>2.<code>FIQ</code></h4><ul><li>快速中断模式</li><li>一个高优先级（fast）中断产生</li></ul><h4 id="3-IRQ"><a href="#3-IRQ" class="headerlink" title="3.IRQ"></a>3.<code>IRQ</code></h4><ul><li>普通中断模式</li><li>一个低优先级(normal)中断产生</li></ul><h4 id="4-Supervisor-SVC"><a href="#4-Supervisor-SVC" class="headerlink" title="4.Supervisor/SVC"></a>4.<code>Supervisor/SVC</code></h4><ul><li>管理模式</li><li>操作系统的保护模式，系统开机、复位或软中断指令执行时响应</li><li>CPU上电后默认模式，该模式主要用来做系统初始化，软中断处理也在该模式下，当用户模式下的用户程序请求使用硬件资源是，通过软件中断进入该模式</li></ul><h4 id="5-Abort"><a href="#5-Abort" class="headerlink" title="5.Abort"></a>5.<code>Abort</code></h4><ul><li>中止模式</li><li>虚拟内存和存储器的保护模式，指令预取中止和数据访问中止时响应</li><li>当用户程序访问非法地址，没有权限读取的内存地址时，会进入该模式。Linux下编程出现的segment fault通常都是在该模式下抛出返回的</li></ul><h4 id="6-Undefine"><a href="#6-Undefine" class="headerlink" title="6.Undefine"></a>6.<code>Undefine</code></h4><ul><li>未定义模式</li><li>用于软件仿真，CPU在指令的译码阶段不能识别某指令操作时响应</li></ul><h3 id="非异常模式"><a href="#非异常模式" class="headerlink" title="非异常模式"></a>非异常模式</h3><h4 id="7-System"><a href="#7-System" class="headerlink" title="7.System"></a>7.<code>System</code></h4><ul><li>系统模式</li><li>共用User模式下相同寄存器集的特权模式，运行操作系统任务，可以访问所有系统资源</li></ul><h3 id="地址偏移量"><a href="#地址偏移量" class="headerlink" title="地址偏移量"></a>地址偏移量</h3><p>各种异常模式的地址偏移量</p><img src="http://p1crnqdyo.bkt.clouddn.com/images/ARM处理器\异常向量表.png"> <img src="http://p1crnqdyo.bkt.clouddn.com/images/ARM处理器\描述.png"><hr><h1 id="三-37个寄存器"><a href="#三-37个寄存器" class="headerlink" title="三. 37个寄存器"></a>三. <strong>37个寄存器</strong></h1><h2 id="1-30个通用寄存器"><a href="#1-30个通用寄存器" class="headerlink" title="1. 30个通用寄存器"></a>1. <strong>30个通用寄存器</strong></h2><ul><li>1.1. 8个不分组寄存器<ul><li>8个(R0-R7)<ul><li>[x] R0-R7</li></ul></li></ul></li><li>1.2. 22个分组寄存器<ul><li>10个(R8-R12)<ul><li>[x] 5个FIQ模式的分组寄存器</li><li>[x] 5个非FIQ模式的分组寄存器</li></ul></li><li>12个(R13-R14)<ul><li>[x] 6个SP(Stack Pointer Register)</li><li>[x] 6个LR(Link Register)</li></ul></li></ul></li></ul><h2 id="2-7个特殊功能寄存器"><a href="#2-7个特殊功能寄存器" class="headerlink" title="2. 7个特殊功能寄存器"></a>2. <strong>7个特殊功能寄存器</strong></h2><ul><li>2.1.<ul><li>1个(R15)<ul><li>[x] PC指针(Program Control register)<ul><li>PC指向哪里，CPU就会执行哪条代码，所以程序跳转就是把目标地址代码放到PC中</li></ul></li></ul></li><li>1个<ul><li>[x] CPSR(Current program status register/当前程序状态寄存器)</li></ul></li><li>5个<ul><li>[x] SPSR(Saved program status register/保存程序状态寄存器)<ul><li>异常模式下使用</li></ul></li></ul></li></ul></li><li>mode位(bit4~bit0)决定了CPU的工作模式，uboot代码中使用汇编设置</li></ul><img src="http://p1crnqdyo.bkt.clouddn.com/images/ARM处理器\CPSR.png"> <img src="http://p1crnqdyo.bkt.clouddn.com/images/ARM处理器\7个工作模式及其37个寄存器.png"><hr><h1 id="四-异常产生及其返回"><a href="#四-异常产生及其返回" class="headerlink" title="四. 异常产生及其返回 "></a>四. <strong>异常产生及其返回</strong></h1><img src="http://p1crnqdyo.bkt.clouddn.com/images/ARM处理器\异常产生及其返回.png"><hr><h1 id="五-ARM的基本设定"><a href="#五-ARM的基本设定" class="headerlink" title="五. ARM的基本设定 "></a>五. <strong>ARM的基本设定</strong></h1><h2 id="ARM约定"><a href="#ARM约定" class="headerlink" title="ARM约定"></a>ARM约定</h2><pre><code>Byte : 8bits
Halfword : 16bits
Word : 32bits
</code></pre><h2 id="大部分ARM-core提供"><a href="#大部分ARM-core提供" class="headerlink" title="大部分ARM core提供"></a>大部分ARM core提供</h2><pre><code>ARM指令集（32 bit）
Thumb指令集（16 bit）
Thumb2指令集（16 &amp; 32 bit）
</code></pre><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;简单总结一下ARM处理器工作模式及其寄存器！&lt;/p&gt;
    
    </summary>
    
      <category term="ARM_Linux" scheme="https://blog.jmlin.top/categories/ARM-Linux/"/>
    
    
      <category term="ARM" scheme="https://blog.jmlin.top/tags/ARM/"/>
    
      <category term="异常" scheme="https://blog.jmlin.top/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="寄存器" scheme="https://blog.jmlin.top/tags/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>mini嵌入式web服务器搭建</title>
    <link href="https://blog.jmlin.top/posts/mini%E5%B5%8C%E5%85%A5%E5%BC%8Fweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.html"/>
    <id>https://blog.jmlin.top/posts/mini嵌入式web服务器搭建.html</id>
    <published>2018-01-07T04:22:54.000Z</published>
    <updated>2018-01-07T04:39:31.562Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="Windows系统下"><a href="#Windows系统下" class="headerlink" title="Windows系统下"></a>Windows系统下</h2><h3 id="安装虚拟机"><a href="#安装虚拟机" class="headerlink" title="安装虚拟机"></a>安装虚拟机</h3><ul><li>安装以Linux为内核的操作系统(如Ubuntu)</li></ul><h3 id="安装secureCRT超级终端"><a href="#安装secureCRT超级终端" class="headerlink" title="安装secureCRT超级终端"></a>安装secureCRT超级终端</h3><ul><li>用于查看开发板输出的调试信息并与开发板交互</li></ul><h3 id="安装DNW"><a href="#安装DNW" class="headerlink" title="安装DNW"></a>安装DNW</h3><h3 id="安装Source-Insight"><a href="#安装Source-Insight" class="headerlink" title="安装Source Insight"></a>安装Source Insight</h3><ul><li>在Windows下查看及其修改代码</li></ul><h2 id="虚拟机系统下"><a href="#虚拟机系统下" class="headerlink" title="虚拟机系统下"></a>虚拟机系统下</h2><h3 id="设置文件共享"><a href="#设置文件共享" class="headerlink" title="设置文件共享"></a>设置文件共享</h3><h3 id="安装交叉编译工具链，并导入环境变量"><a href="#安装交叉编译工具链，并导入环境变量" class="headerlink" title="安装交叉编译工具链，并导入环境变量"></a>安装交叉编译工具链，并导入环境变量</h3><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><ul><li><code>mkdir /usr/local/arm/</code> 创建一个新文件夹，用于存放编译链工具</li><li><code>mv /mnt/hgfs/Winshare/arm-2009q3.tar.bz2 /usr/local/arm/</code>把下载到的编译工具链压缩包移动到上面的文件夹</li><li><code>cd /usr/local/arm/</code></li><li><code>tar -jxvf arm-2009q3.tar.bz2</code></li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li><code>mv /mnt/hgfs/Winshare/mk-arm-linux.sh /usr/local/arm/arm-2009q3/bin</code> 根据自己的共享目录名字改动</li><li><code>cd /usr/local/arm/arm-2009q3/bin</code></li><li><code>source mk-arm-linux.sh</code></li></ul><h4 id="导入环境变量"><a href="#导入环境变量" class="headerlink" title="导入环境变量"></a>导入环境变量</h4><ul><li><code>gedit ~/.bashrc</code>打开这个文件，在最下面添加以下一行<ul><li><code>export PATH=/usr/local/arm/arm-2009q3/bin:$PATH</code></li></ul></li><li><code>source ~/.bashrc</code></li></ul><h4 id="64位兼容32位"><a href="#64位兼容32位" class="headerlink" title="64位兼容32位"></a>64位兼容32位</h4><ul><li>如果Ubuntu是64位的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo dpkg --add-architecture i386</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386</div><div class="line">sudo ./adb</div></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>在任意路径下敲<code>arm-linux-gcc -v</code></li><li>返回信息<code>gcc version 4.4.1</code></li><li>表示你已经安装成功了</li></ul><h3 id="安装NFS"><a href="#安装NFS" class="headerlink" title="安装NFS"></a>安装NFS</h3><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><ul><li><code>sudo apt-get install nfs-kernel-server -y</code></li></ul><h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><ul><li><code>service rpcbind restart</code></li><li><code>service nfs-kernel-server restart</code></li></ul><h4 id="建立文件目录"><a href="#建立文件目录" class="headerlink" title="建立文件目录"></a>建立文件目录</h4><ul><li><code>mkdir /opt/Rootfs_TQ210</code> # 建立根文件目录</li><li><code>chmod 777 -R /opt/Rootfs_TQ210</code></li><li><code>mkdir /opt1</code> #建立访问目录，位置不固定</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ul><li><code>sudo vi /etc/exports</code><ul><li><code>/opt/Rootfs_TQ210 *(rw,sync,no_root_squash,no_subtree_check)</code> #在文本最后加上<blockquote><p><em>/opt/Rootfs_TQ210</em>目录是与nfs服务客户端共享的目录，*代表允许所有的网段访问<br>rw：挂载此目录的客户端对该共享目录具有读写权限<br>sync：资料同步写入内存和硬盘<br>no_root_squash：客户机用root访问该共享文件夹时，不映射root用户(root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户)<br>no_subtree_check：不检查父目录的权限</p></blockquote></li></ul></li></ul><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><ul><li><code>sudo exportfs -r</code> #更新文件</li><li><code>sudo showmount localhost -e</code> #下面是显示信息<ul><li><code>Export list for Ubuntu2jmlin:</code></li><li><code>/opt/Rootfs_TQ210 *</code></li></ul></li></ul><h4 id="本地挂载"><a href="#本地挂载" class="headerlink" title="本地挂载"></a>本地挂载</h4><ul><li><code>mount -t nfs -o nolock localhost:/opt/Rootfs_TQ210 /opt1</code> #挂载<code>Rootfs_TQ210</code>目录到<em><code>/opt1</code></em>目录下</li></ul><hr><h1 id="Uboot"><a href="#Uboot" class="headerlink" title="Uboot"></a>Uboot</h1><h2 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h2><ul><li><em><code>开发板光盘/bootloader/uboot_TQ210_1.3.4_V1.7.tar.bz2</code></em></li><li>复制到Ubuntu<em><code>/opt/</code></em>目录下</li><li>解压<code>tar -jxvf uboot_TQ210_1.3.4_V1.7.tar.bz2</code></li></ul><h2 id="源码检查"><a href="#源码检查" class="headerlink" title="源码检查"></a>源码检查</h2><h3 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h3><ul><li><code>make distclean</code></li></ul><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><ul><li>交叉编译工具链路径</li><li><code>vi Makefile</code> # 在相应地方(149)添加</li><li><code>CROSS_COMPILE = arm-linux-</code></li></ul><h2 id="编译前配置"><a href="#编译前配置" class="headerlink" title="编译前配置"></a>编译前配置</h2><ul><li><code>make TQ210_config</code></li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li><code>make -j8</code></li></ul><h2 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h2><ul><li>使用DNW烧录</li></ul><h2 id="进入Uboot命令命令行"><a href="#进入Uboot命令命令行" class="headerlink" title="进入Uboot命令命令行"></a>进入Uboot命令命令行</h2><ul><li>开发板开机按下空格键，进入天嵌制作的操作菜单</li><li>按下字母<code>q</code>退出天嵌的操作菜单，进入uboot命令行</li></ul><h3 id="设置uboot环境变量"><a href="#设置uboot环境变量" class="headerlink" title="设置uboot环境变量"></a>设置uboot环境变量</h3><p>本地IP地址和服务器IP地址要在同一网段<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">set ipaddr 192.168.0.105        # 设置本地IP地址</div><div class="line">set gatewayip 192.168.0.1       # 设置网关</div><div class="line">set serverip 192.168.0.101      # 设置服务器IP地址</div><div class="line"></div><div class="line">set nfsipaddr 192.168.0.105     # 设置NFS IP地址</div><div class="line">set nfsserverip 192.168.0.101   # 设置NFS 服务器IP地址</div><div class="line">set nfs_dir /opt/rootfs_TQ210        # 设置NFS 文件夹</div><div class="line">set bootargs root=/dev/nfs nfsroot=192.168.0.101:/opt/rootfs_TQ210 ip=192.168.0.105:192.168.0.101:192.168.0.1:255.255.255.0::eth0:off init=/linuxrc console=ttySAC0,115200</div><div class="line">save</div></pre></td></tr></table></figure><p></p><hr><h1 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h1><h2 id="获取源码-1"><a href="#获取源码-1" class="headerlink" title="获取源码"></a>获取源码</h2><ul><li><em><code>开发板光盘/Linux资源/Linux源码包/3.0.8/Kernel_3.0.8_TQ210_for_Linux_v2.2.tar.bz2</code></em></li><li>复制到Ubuntu <em><code>/opt/</code></em> 目录下</li><li>解压<code>tar -jxvf Kernel_3.0.8_TQ210_for_Linux_v2.2.tar.bz2</code></li></ul><h2 id="源码检查-1"><a href="#源码检查-1" class="headerlink" title="源码检查"></a>源码检查</h2><h3 id="清理-1"><a href="#清理-1" class="headerlink" title="清理"></a>清理</h3><ul><li><code>make distclean</code></li></ul><h2 id="编译前配置-1"><a href="#编译前配置-1" class="headerlink" title="编译前配置"></a>编译前配置</h2><ul><li><code>cp config_for_TQ210_Linux_v2.1_CoreB .config</code></li><li>检查Makefile所配置的交叉编译链、是否为arm架构</li></ul><h2 id="配置生成默认文件"><a href="#配置生成默认文件" class="headerlink" title="配置生成默认文件"></a>配置生成默认文件</h2><ul><li><code>cp config_for_TQ210_Linux_v2.1_CoreB .config</code> #直接使用天嵌已经给的默认配置文件</li></ul><h2 id="kernel-裁剪"><a href="#kernel-裁剪" class="headerlink" title="kernel 裁剪"></a>kernel 裁剪</h2><ul><li><p><code>make menuconfig</code></p><ul><li>如果是第一次使用的话，可能会出现错误</li><li>根据错误，需要下载<code>ncurses</code>，先执行<code>sudo apt-get install libncurses5-dev</code>来下载，然后再<code>make menuconfig</code></li></ul></li><li><p>Device Drivers —&gt;</p><ul><li>Multimedia support —&gt;<ul><li>Video capture adapters —&gt;<ul><li>[*] Samsung Camera Interface (FIMC) driver // 移除摄像头驱动<ul><li>[ ] camera ov3640</li><li>[ ] camera ov9650</li><li>[ ] camera tvp5150</li><li>[ ] camera saa7113</li></ul></li><li>[*] Samsung TV Driver<ul><li>[ ] HDMI CEC driver support // 移除HDMI遥控驱动</li><li>[*] HDMI HPD driver support</li></ul></li></ul></li></ul></li><li>HID Devices<ul><li>[ ] USB Human Interface Device (full HID) support // 移除鼠标驱动</li></ul></li><li>Networking support<ul><li>[ ] Bluetooth subsystem support // 移除蓝牙驱动</li></ul></li></ul></li><li><p>File systems —&gt;</p><ul><li>[*] Network File Systems —&gt;<ul><li>&lt;*&gt; NFS client support // 添加NFS驱动<ul><li>[*] NFS client support for NFS version 3<ul><li>[*] NFS client support for the NFSv3 ACL protocol extension</li></ul></li><li>[*] NFS client support for NFS version 4 (EXPERIMENTAL)<ul><li>[ ] NFS client support for NFSv4.1 (DEVELOPER ONLY)</li></ul></li><li>[*] Root file system on NFS</li></ul></li></ul></li></ul></li></ul><h1 id="RootFS"><a href="#RootFS" class="headerlink" title="RootFS"></a>RootFS</h1><h2 id="获取源码-2"><a href="#获取源码-2" class="headerlink" title="获取源码"></a>获取源码</h2><ul><li><em><code>开发板光盘/Linux资源/Linux源码包/rootfs_linux_v1.6_CoreB_src_20140415.tar.bz2</code></em></li><li>复制到Ubuntu <em><code>/opt/</code></em> 目录下</li><li>解压<code>tar -jxvf rootfs_linux_v1.6_CoreB_src_20140415.tar.bz2</code></li></ul><h2 id="源码检查-2"><a href="#源码检查-2" class="headerlink" title="源码检查"></a>源码检查</h2><ul><li>检查Makefile所配置的交叉编译链、是否为arm架构</li><li>设置安装目录为 <em><code>/opt/Rootfs_TQ210</code></em></li></ul><h2 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h2><ul><li><code>make</code></li></ul><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><ul><li><code>make install</code></li></ul><hr><h1 id="Web服务器移植"><a href="#Web服务器移植" class="headerlink" title="Web服务器移植"></a>Web服务器移植</h1><h2 id="移植BOA-0-94-13"><a href="#移植BOA-0-94-13" class="headerlink" title="移植BOA-0.94.13"></a>移植BOA-0.94.13</h2><h3 id="获取源码-3"><a href="#获取源码-3" class="headerlink" title="获取源码"></a>获取源码</h3><ul><li><code>cd /opt</code></li><li><code>wget https://nchc.dl.sourceforge.net/project/boa/boa/0.94.13/boa-0.94.13.tar.gz</code></li><li><code>tar -zxvf boa-0.94.13.tar.gz</code></li></ul><h3 id="编译前配置-2"><a href="#编译前配置-2" class="headerlink" title="编译前配置"></a>编译前配置</h3><ul><li><code>cd src</code></li><li><code>./configure</code></li><li><code>vi Makefile</code><ul><li>将<code>CC</code>和<code>CPP</code>分别修改为<code>CC=arm-linux-gcc</code>和<code>CPP=arm-linux-g++ -E</code></li></ul></li><li><p><code>vi boa.c</code><br>在行225到227，将其注释掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (setuid(0) != -1) &#123;</div><div class="line">        DIE(&quot;icky Linux kernel bug!&quot;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p><code>vi compat.h</code></p></li><li>把120行修改为<code>#define TIMEZONE_OFFSEST(foo) foo-&gt;tm_gmtoff</code></li></ul><h3 id="编译-2"><a href="#编译-2" class="headerlink" title="编译"></a>编译</h3><ul><li><code>make</code><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4></li><li>可能出现错误<code>make: yacc: Command not found</code><ul><li><code>sudo apt-get install -y byacc</code></li></ul></li><li>可能出现错误<code>make: lex: Command not found</code><ul><li><code>sudo apt-get install -y flex</code><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4></li></ul></li><li><code>arm-linux-strip boa</code></li></ul><h2 id="移植cgic库"><a href="#移植cgic库" class="headerlink" title="移植cgic库"></a>移植cgic库</h2><h3 id="获取源码-4"><a href="#获取源码-4" class="headerlink" title="获取源码"></a>获取源码</h3><ul><li><code>cd /opt</code></li><li><code>wget https://boutell.com/cgic/cgic205.tar.gz</code></li><li><code>tar -zxvf cgic205.tar.gz</code></li></ul><h3 id="编译前配置-3"><a href="#编译前配置-3" class="headerlink" title="编译前配置"></a>编译前配置</h3><ul><li><code>vi Makefile</code><br>以下为修改内容<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CC=arm-linux-gcc</div><div class="line">AR=arm-linux-ar</div><div class="line">RANLIB=arm-linux-ranlib</div><div class="line"></div><div class="line">cp libcgic.a /usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/armv4t/lib   # 这两行根据自己所安装</div><div class="line">cp cgic.h /usr/local/arm/arm-2009q3/arm-none-linux-gnueabi/libc/usr/include     # 交叉编译工具链位置改动</div><div class="line"></div><div class="line">$(CC) $(CFLAGS) cgictest.o -o cgictest.cgi $(LIBS)</div><div class="line"></div><div class="line">$(CC) $(CFLAGS) capture.o -o capture $(LIBS)</div></pre></td></tr></table></figure></li></ul><h3 id="编译-3"><a href="#编译-3" class="headerlink" title="编译"></a>编译</h3><ul><li><code>make</code></li></ul><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><ul><li><code>arm-linux-strip capture</code></li></ul><h2 id="配置Web服务器"><a href="#配置Web服务器" class="headerlink" title="配置Web服务器"></a>配置Web服务器</h2><h3 id="配置BOA"><a href="#配置BOA" class="headerlink" title="配置BOA"></a>配置BOA</h3><ul><li><code>cd /opt/roorfs_TQ210</code></li><li><code>mkdir web etc/boa</code> # 在根文件系统新建web/、etc/boa/目录</li><li><code>cp /opt/boa-0.94.13/src/boa rootfs_TQ210/sbin</code></li><li><code>cp /opt/boa-0.94.13/boa.conf rootfs_TQ210/etc/boa</code></li><li>修改<code>boa.conf</code>文件<code>vi etc/boa/boa.conf</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">Port 80</div><div class="line"></div><div class="line">#Listen 192.168.0.105</div><div class="line"></div><div class="line">User root</div><div class="line">Group root</div><div class="line"></div><div class="line">#ServerAdmin root@localhost</div><div class="line"></div><div class="line">#ErrorLog /dev/null</div><div class="line">ErrorLog /dev/console</div><div class="line"></div><div class="line">AccessLog /dev/null</div><div class="line"></div><div class="line">#UseLocaltime</div><div class="line"></div><div class="line">#VerboseCGILogs</div><div class="line"></div><div class="line">#ServerName www.your.org.here</div><div class="line">ServerName jmlin_Server</div><div class="line"></div><div class="line">#VirtualHost</div><div class="line"></div><div class="line">DocumentRoot /web</div><div class="line"></div><div class="line">#UserDir public_html</div><div class="line"></div><div class="line">DirectoryIndex JMLin.html</div><div class="line"></div><div class="line">#DirectoryMaker /usr/lib/boa/boa_indexer</div><div class="line"></div><div class="line"># DirectoryCache /var/spool/boa/dircache</div><div class="line"></div><div class="line">KeepAliveMax 1000</div><div class="line"></div><div class="line">KeepAliveTimeout 10</div><div class="line"></div><div class="line">MimeTypes /etc/mime.types</div><div class="line"></div><div class="line">DefaultType text/plain</div><div class="line"></div><div class="line">CGIPath /bin</div><div class="line"></div><div class="line">AddType application/x-httpd-cgi cgi</div><div class="line"></div><div class="line">#Alias /doc /usr/doc</div><div class="line"></div><div class="line">#ScriptAlias /cgi-bin/ /usr/lib/cgi-bin/</div></pre></td></tr></table></figure><ul><li><code>cp /etc/mime.types /opt/rootfs_TQ210/etc</code></li></ul><h3 id="配置cgic库"><a href="#配置cgic库" class="headerlink" title="配置cgic库"></a>配置cgic库</h3><ul><li>建立<code>cgi-bin</code>目录 <code>mkdir /opt/rootfs_TQ210/web/cig-bin</code></li><li><code>cp /opt/cgic205/capture /opt/rootfs_TQ210/web/cgi-bin/</code></li><li><code>cp /opt/cgic205/cgictest.cgi /opt/rootfs_TQ210/web/cgi-bin/</code></li></ul><h2 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h2><h3 id="静态网页测试"><a href="#静态网页测试" class="headerlink" title="静态网页测试"></a>静态网页测试</h3><ul><li>在PC段网页浏览器输入地址：<code>192.168.0.105</code><img src="http://p1crnqdyo.bkt.clouddn.com/images/mini嵌入式web服务器搭建\静态网页测试.png"></li></ul><h3 id="CGI脚本测试"><a href="#CGI脚本测试" class="headerlink" title="CGI脚本测试"></a>CGI脚本测试</h3><ul><li><p>在PC段网页浏览器输入地址：<code>http://192.168.0.105/cgi-bin/cgictest.cgi</code></p><img src="http://p1crnqdyo.bkt.clouddn.com/images/mini嵌入式web服务器搭建\CGICTEST.png"></li><li><p>在PC段网页浏览器输入地址：<code>http://192.168.0.105/cgi-bin/helloweb.cgi</code></p><img src="http://p1crnqdyo.bkt.clouddn.com/images/mini嵌入式web服务器搭建\HELLOWEB.png"></li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="ARM_Linux" scheme="https://blog.jmlin.top/categories/ARM-Linux/"/>
    
    
      <category term="Uboot" scheme="https://blog.jmlin.top/tags/Uboot/"/>
    
      <category term="NFS" scheme="https://blog.jmlin.top/tags/NFS/"/>
    
      <category term="Kernel" scheme="https://blog.jmlin.top/tags/Kernel/"/>
    
      <category term="Rootfs" scheme="https://blog.jmlin.top/tags/Rootfs/"/>
    
      <category term="BOA" scheme="https://blog.jmlin.top/tags/BOA/"/>
    
  </entry>
  
  <entry>
    <title>交叉编译工具链环境搭建</title>
    <link href="https://blog.jmlin.top/posts/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"/>
    <id>https://blog.jmlin.top/posts/交叉编译工具链环境搭建.html</id>
    <published>2017-12-28T09:30:43.000Z</published>
    <updated>2017-12-28T10:15:27.776Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h1><ul><li><code>mkdir /usr/local/arm/</code> 创建一个新文件夹，用于存放编译链工具</li><li><code>mv /mnt/hgfs/Winshare/arm-2009q3.tar.bz2 /usr/local/arm/</code>把你下载到的编译工具链压缩包移动到上面的文件夹,每个人的共享文件夹名字不一样，自己要根据实际改动</li><li><code>cd /usr/local/arm/</code></li><li><code>tar -jxvf arm-2009q3.tar.bz2</code></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><code>mv /mnt/hgfs/Winshare/mk-arm-linux.sh /usr/local/arm/arm-2009q3/bin</code> 根据自己的共享目录名字改动</li><li><code>cd /usr/local/arm/arm-2009q3/bin</code></li><li><code>vi make-arm-linux.sh</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">ln arm-none-linux-gnueabi-addr2line -s arm-linux-addr2line</div><div class="line">ln arm-none-linux-gnueabi-ar -s arm-linux-ar</div><div class="line">ln arm-none-linux-gnueabi-as -s arm-linux-as</div><div class="line">ln arm-none-linux-gnueabi-c++ -s arm-linux-c++</div><div class="line">ln arm-none-linux-gnueabi-c++filt -s arm-linux-c++filt</div><div class="line">ln arm-none-linux-gnueabi-cpp -s arm-linux-cpp</div><div class="line">ln arm-none-linux-gnueabi-g++ -s arm-linux-g++</div><div class="line">ln arm-none-linux-gnueabi-gcc -s arm-linux-gcc</div><div class="line">ln arm-none-linux-gnueabi-gcc-4.4.1 -s arm-linux-gcc-4.4.1</div><div class="line">ln arm-none-linux-gnueabi-gcov -s arm-linux-gcov</div><div class="line">ln arm-none-linux-gnueabi-gdb -s arm-linux-gdb</div><div class="line">ln arm-none-linux-gnueabi-gdbtui -s arm-linux-gdbtui</div><div class="line">ln arm-none-linux-gnueabi-gprof -s arm-linux-gprof</div><div class="line">ln arm-none-linux-gnueabi-ld -s arm-linux-ld</div><div class="line">ln arm-none-linux-gnueabi-nm -s arm-linux-nm</div><div class="line">ln arm-none-linux-gnueabi-objcopy -s arm-linux-objcopy</div><div class="line">ln arm-none-linux-gnueabi-objdump -s arm-linux-objdump</div><div class="line">ln arm-none-linux-gnueabi-ranlib -s arm-linux-ranlib</div><div class="line">ln arm-none-linux-gnueabi-readelf -s arm-linux-readelf</div><div class="line">ln arm-none-linux-gnueabi-size -s arm-linux-size</div><div class="line">ln arm-none-linux-gnueabi-sprite -s arm-linux-sprite</div><div class="line">ln arm-none-linux-gnueabi-strings -s arm-linux-strings</div><div class="line">ln arm-none-linux-gnueabi-strip -s arm-linux-strip</div></pre></td></tr></table></figure><ul><li><code>source make-arm-linux.sh</code></li></ul><h1 id="导入环境变量"><a href="#导入环境变量" class="headerlink" title="导入环境变量"></a>导入环境变量</h1><ul><li><code>gedit ~/.bashrc</code>打开这个文件，在最下面添加以下一行<ul><li><code>export PATH=/usr/local/arm/arm-2009q3/bin:$PATH</code></li></ul></li><li><code>source ~/.bashrc</code></li></ul><h1 id="64位兼容32位"><a href="#64位兼容32位" class="headerlink" title="64位兼容32位"></a>64位兼容32位</h1><ul><li>如果Ubuntu是64位的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo dpkg --add-architecture i386</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386</div><div class="line">sudo ./adb</div></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li>在任意路径下敲<code>arm-linux-gcc -v</code></li><li>返回信息中含有<code>gcc version 4.4.1</code></li><li>表示已经安装成功了</li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="https://blog.jmlin.top/categories/Ubuntu/"/>
    
    
      <category term="交叉编译" scheme="https://blog.jmlin.top/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>NFS服务器搭建</title>
    <link href="https://blog.jmlin.top/posts/NFS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA.html"/>
    <id>https://blog.jmlin.top/posts/NFS服务器搭建.html</id>
    <published>2017-12-28T06:55:35.000Z</published>
    <updated>2017-12-28T10:09:53.686Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><blockquote><p>基于Ubuntu14.04环境</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><code>sudo apt-get install nfs-kernel-server -y</code></li></ul><h1 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h1><ul><li><code>service rpcbind restart</code></li><li><code>service nfs-kernel-server restart</code></li></ul><h1 id="建立文件目录"><a href="#建立文件目录" class="headerlink" title="建立文件目录"></a>建立文件目录</h1><ul><li><code>mkdir /root/rootfs</code> # 建立根文件目录</li><li><code>chmod 777 -R /root/rootfs</code></li><li><code>mkdir /opt</code> #建立访问目录，位置不固定</li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul><li><code>sudo vi /etc/exports</code><ul><li><code>/root/rootfs *(rw,sync,no_root_squash,no_subtree_check)</code> #在文本最后加上<blockquote><p><em>/root/rootfs</em>目录是与nfs服务客户端共享的目录，*代表允许所有的网段访问<br>rw：挂载此目录的客户端对该共享目录具有读写权限<br>sync：资料同步写入内存和硬盘<br>no_root_squash：客户机用root访问该共享文件夹时，不映射root用户(root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户)<br>no_subtree_check：不检查父目录的权限</p></blockquote></li></ul></li></ul><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><ul><li><code>sudo exportfs -r</code> #更新文件</li><li><code>sudo showmount localhost -e</code> #下面是显示信息<ul><li><code>Export list for Ubuntu2jmlin:</code></li><li><code>/root/rootfs *</code></li></ul></li></ul><h1 id="本地挂载"><a href="#本地挂载" class="headerlink" title="本地挂载"></a>本地挂载</h1><ul><li><code>mount -t nfs -o nolock localhost:/root/rootfs /opt</code> #挂载rootfs目录到<em><code>/opt</code></em>目录下</li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="https://blog.jmlin.top/categories/Ubuntu/"/>
    
    
      <category term="NFS" scheme="https://blog.jmlin.top/tags/NFS/"/>
    
  </entry>
  
  <entry>
    <title>VPS搭建</title>
    <link href="https://blog.jmlin.top/posts/VPS%E6%90%AD%E5%BB%BA.html"/>
    <id>https://blog.jmlin.top/posts/VPS搭建.html</id>
    <published>2017-12-21T13:14:18.000Z</published>
    <updated>2017-12-22T08:39:40.667Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>实验室的海外服务器还有10来天就过期了，趁有点时间就玩一玩！<br><a id="more"></a></p><blockquote><p>前言：今天去<a href="https://www.vultr.com/?ref=7283845" target="_blank" rel="external">Vultr</a>部署了一个虚拟专用服务器(下面以VPS代指)，一开始系统分配的IP已经被GFW墙了，可是我还抱着一丝轻蔑的态度，想要用远程终端通过代理来登录，折腾了2个小时后觉得不太靠谱，还是把VPS给删除掉，让系统再从新分配一个不同IP的VPS给我。然后马上来这里<a href="http://m.tool.chinaz.com/ping/" target="_blank" rel="external">ping</a>测试一下有没有被墙。幸运的是，我第二次就可以了，不需要通过代理就能用putty来登录VPS。弱弱地吐槽一句，Vultr的网页终端交互能力好弱啊！</p></blockquote><ul><li>所部署的VPS参数如下<img src="http://p1crnqdyo.bkt.clouddn.com/images/VPS_config.png"> 用了Ubuntu14.04挺久的了，所以玩生不如玩熟！！！</li></ul><h1 id="一些更新"><a href="#一些更新" class="headerlink" title="一些更新"></a>一些更新</h1><ul><li><code>apt-get update &amp;&amp; apt-get upgrade</code></li><li><code>apt-get install gcc g++</code> # 更新编译器</li><li><code>apt-get install aptitude</code></li></ul><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>系统原生配置的是<code>vi</code>，我习惯用vim就下载一个<code>vim</code>,接着再安装vim的插件</p><ul><li><code>apt-get install vim</code></li><li><code>wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x</code></li></ul><h1 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h1><ul><li><p>这个我就不多做解释了，懂的人懂就好！（奸笑ing）</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</div><div class="line">chmod +x shadowsocksR.sh</div><div class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</div></pre></td></tr></table></figure></li><li><p>一开始要设置密码，之后的都使用默认配置</p></li></ul><h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./shadowsocksR.sh uninstall         # 卸载</div><div class="line">/etc/init.d/shadowsocks start       # 启动</div><div class="line">/etc/init.d/shadowsocks stop        # 停止</div><div class="line">/etc/init.d/shadowsocks restart     # 重启</div><div class="line">/etc/init.d/shadowsocks status      # 状态</div></pre></td></tr></table></figure><h2 id="文件配置路径"><a href="#文件配置路径" class="headerlink" title="文件配置路径"></a>文件配置路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/etc/shadowsocks.json               # 配置文件路径</div><div class="line">/var/log/shadowsocks.log            # 日志文件路径</div><div class="line">/usr/local/shadowsocks              # 代码安装目录</div></pre></td></tr></table></figure><h1 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h1><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><ul><li><code>apt-get install mysql-server mysql-client libmysqlclient-dev libmysql-java</code></li><li>弹出蓝色框框，输入两次密码</li></ul><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ul><li><code>mysql -u root -p</code></li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul><li><code>apt-get install git -y</code></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><code>git config --global user.email &quot;eclaboratory@163.com&quot;</code></li><li><code>git config --global user.name &quot;EC-Lab&quot;</code></li><li><code>git config --global credential.helper store</code> # 用于保存用户数据</li></ul><h1 id="博客环境搭建"><a href="#博客环境搭建" class="headerlink" title="博客环境搭建"></a>博客环境搭建</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ul><li><code>apt-get install npm</code></li><li><code>apg-get install nginx -y</code></li><li><code>npm install hexo-cli hexo-server -g</code></li></ul><blockquote><p>之后继续补充！</p></blockquote><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;实验室的海外服务器还有10来天就过期了，趁有点时间就玩一玩！&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://blog.jmlin.top/categories/Geek/"/>
    
    
      <category term="VPS" scheme="https://blog.jmlin.top/tags/VPS/"/>
    
      <category term="Vultr" scheme="https://blog.jmlin.top/tags/Vultr/"/>
    
  </entry>
  
  <entry>
    <title>Vim之高手进阶篇</title>
    <link href="https://blog.jmlin.top/posts/Vim%E4%B9%8B%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E7%AF%87.html"/>
    <id>https://blog.jmlin.top/posts/Vim之高手进阶篇.html</id>
    <published>2017-12-21T13:03:46.000Z</published>
    <updated>2018-01-28T08:23:46.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>距离上一次发博客也是有一段时间了！<br><a id="more"></a></p><hr><h2 id="在命令模式下移动光标"><a href="#在命令模式下移动光标" class="headerlink" title="在命令模式下移动光标"></a>在命令模式下移动光标</h2><pre><code class="vim">                        H(屏幕首行开头)
                        gg(文章首行开头)
<span class="number">0</span>(行首)                                                 $(行末)
<span class="keyword">b</span>(前一个单词开头)                                        <span class="keyword">w</span>(后一个单词开头)
                                                        <span class="keyword">e</span>(后一个单词末尾)
                        G(文章末行开头)
</code></pre><h2 id="从命令模式进入插入模式"><a href="#从命令模式进入插入模式" class="headerlink" title="从命令模式进入插入模式"></a>从命令模式进入插入模式</h2><pre><code>o       &quot; 在当前光标所在行下面插入一行
O       &quot; 在当前光标所在行上面插入一行
</code></pre><h2 id="分屏模式"><a href="#分屏模式" class="headerlink" title="分屏模式"></a>分屏模式</h2><ul><li>适用于多文件处理</li></ul><h3 id="横向分屏"><a href="#横向分屏" class="headerlink" title="横向分屏"></a>横向分屏</h3><pre><code>:sp otherfilename   &quot; split
</code></pre><h3 id="垂直分屏"><a href="#垂直分屏" class="headerlink" title="垂直分屏"></a>垂直分屏</h3><pre><code>:vsp otherfilename  &quot; vertically split
</code></pre><h3 id="切换Viewport"><a href="#切换Viewport" class="headerlink" title="切换Viewport"></a>切换Viewport</h3><table><thead><tr><th style="text-align:left">按键</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">Ctrl + w -&gt; h</td><td style="text-align:left">移动光标到左边的viewport</td></tr><tr><td style="text-align:left">Ctrl + w -&gt; j</td><td style="text-align:left">移动光标到下边的viewport</td></tr><tr><td style="text-align:left">Ctrl + w -&gt; k</td><td style="text-align:left">移动光标到上边的viewport</td></tr><tr><td style="text-align:left">Ctrl + w -&gt; l</td><td style="text-align:left">移动光标到右边的viewport</td></tr><tr><td style="text-align:left">Ctrl + w -&gt; +</td><td style="text-align:left">扩大当前viewport</td></tr><tr><td style="text-align:left">Ctrl + w -&gt; -</td><td style="text-align:left">缩小当前viewport</td></tr><tr><td style="text-align:left">Ctrl + w -&gt; =</td><td style="text-align:left">重新均匀分配各个viewport的占比</td></tr><tr><td style="text-align:left">Ctrl + w -&gt; r</td><td style="text-align:left">调换各个viewport的位置。用R的话是反向调换</td></tr><tr><td style="text-align:left">Ctrl + w -&gt; q 或c</td><td style="text-align:left">关闭当前viewport</td></tr><tr><td style="text-align:left">Ctrl + o 或 :only</td><td style="text-align:left">只保留当前所在viewport</td></tr></tbody></table><h2 id="字符搜索"><a href="#字符搜索" class="headerlink" title="字符搜索"></a>字符搜索</h2><pre><code>/                   &quot; 顺序查找(n下一个、N上一个)
?                   &quot; 逆向查找
%                   &quot; 配对括号查找
</code></pre><h2 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h2><pre><code>:s/old/new          &quot; 只改当前所在行的第一个
:s/old/new/g        &quot; 只改当前所在行的所有
:#,#s/old/new/g     &quot; #，#表示若干行中首位两行的行号
:%s/old/new/g       &quot; 替换整个文件中的每个匹配符
:%s/old/new/gc      &quot; 替换整个文件中的每个匹配符， 但会提示是否进行替换
</code></pre><h2 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h2><pre><code>:r filename         &quot; 在光标后插入一个文件的内容
</code></pre><h2 id="在vim中执行外部shell命令"><a href="#在vim中执行外部shell命令" class="headerlink" title="在vim中执行外部shell命令"></a>在vim中执行外部shell命令</h2><pre><code>:! shell_command
:w FILENAME                 &quot; 可将当前编辑文件保存FILENAME文件中
v motion :w FILENAME        &quot; 可将当前编辑文件中可视模式下选中的内容保存到FILENAME文件中
:read FILENAME              &quot; 可提取磁盘文件FILENAME并将其插入到当前文件的光标位置后面
:read ! wc %                &quot; 可将文件包含的行数、单词数和字符数输出到当前文件的光标位置后面
:2read ! wc %               &quot; 插入到第二行，使用`$`在最后一行插入，`0`在第一行前面插入
</code></pre><h2 id="保存当前所有打开的文件及其状态"><a href="#保存当前所有打开的文件及其状态" class="headerlink" title="保存当前所有打开的文件及其状态"></a>保存当前所有打开的文件及其状态</h2><pre><code>:mksession ~/.vim/sessions/your_session_name.vim
</code></pre><h2 id="还原上次会话"><a href="#还原上次会话" class="headerlink" title="还原上次会话"></a>还原上次会话</h2><ul><li>法一：<code>:source ~/.vim/sessions/your_session_name.vim</code></li><li>法二：<code>vim -S ~/.vim/sessions/your_session_name.vim</code></li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;距离上一次发博客也是有一段时间了！&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://blog.jmlin.top/categories/Geek/"/>
    
    
      <category term="vim" scheme="https://blog.jmlin.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi 3B上手</title>
    <link href="https://blog.jmlin.top/posts/Raspberry-Pi3%E4%B8%8A%E6%89%8B.html"/>
    <id>https://blog.jmlin.top/posts/Raspberry-Pi3上手.html</id>
    <published>2017-11-26T10:41:47.000Z</published>
    <updated>2017-11-27T07:16:17.377Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>前段时间买了个树莓派3，但一直在忙其它东西，就把它荒废了！今天有时间，折腾就一下<br><a id="more"></a></p><blockquote><p><strong>注:</strong> <em>Raspberry系统为Raspbian 9.1 (Stretch)，如果是其它系统注意操作时的差异</em></p></blockquote><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><ul><li>如果不知道自己的系统版本的话，可以敲<br>lsb_release -a</li></ul><h2 id="Log-in"><a href="#Log-in" class="headerlink" title="Log in"></a>Log in</h2><ul><li>第一次登陆，默认用户名为pi,密码为raspberry</li><li>若要登陆root，可以改密码<br>sudo passwd root</li></ul><h2 id="更换镜像源"><a href="#更换镜像源" class="headerlink" title="更换镜像源"></a>更换镜像源</h2><pre><code>sudo vi /etc/apt/sources.list       
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib</div><div class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib</div></pre></td></tr></table></figure><pre><code>sudo apt-get update
sudo apt-get upgrade
</code></pre><h2 id="安装输入法"><a href="#安装输入法" class="headerlink" title="安装输入法"></a>安装输入法</h2><pre><code>sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin
</code></pre><h2 id="更新Vim"><a href="#更新Vim" class="headerlink" title="更新Vim"></a>更新Vim</h2><pre><code>apt-get remove vim-common
apt-get install vim
cd ~                        // 切换到当前用户根目录
vi .vimrc                   // 进入文件编辑
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set autoindent              &quot; 自动缩进</div><div class="line">set cindent</div><div class="line">set tabstop=4               &quot; Tab宽度</div><div class="line">set softtabstop=4           &quot; 同一缩进为4</div><div class="line">set shiftwidth=4        </div><div class="line">set expandtab               &quot; 使用空格代替制表符</div><div class="line">set nu                      &quot; 显示行号</div></pre></td></tr></table></figure><pre><code>source .vimrc
</code></pre><h2 id="配置WIFI链接文件"><a href="#配置WIFI链接文件" class="headerlink" title="配置WIFI链接文件"></a>配置WIFI链接文件</h2><pre><code>vi /etc/wpa_supplicant/wpa_supplicant.conf
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">country=CN</div><div class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev         # 当前使用interface的socket文件</div><div class="line">update_config=1</div><div class="line">ap_scan=2           # 默认值是1，表示优先链接可见WIFI，受优先级影响</div><div class="line">                    # 2，表示按照network定义的顺序链接，不受优先级影响</div><div class="line">network=&#123;</div><div class="line">ssid=&quot;Your Router&quot;</div><div class="line">psk=&quot;Your Passwd&quot;</div><div class="line">key_mgmt=WPA-PSK    # 加密选项</div><div class="line">priority=6         # 链接优先级 越大越链接</div><div class="line">&#125;</div><div class="line"></div><div class="line">network=&#123;</div><div class="line">ssid=&quot;Your Router&quot;</div><div class="line">psk=&quot;Your Passwd&quot;</div><div class="line">key_mgmt=WPA-PSK</div><div class="line">priority=5</div><div class="line">scan_ssid=1         # 连接隐藏WIFI选项</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="设置无线网卡静态IP"><a href="#设置无线网卡静态IP" class="headerlink" title="设置无线网卡静态IP"></a>设置无线网卡静态IP</h2><pre><code>ifconfig wlan0          # 记录ether后面的一组数据(如：e8:27:39:sd:ed:66)，后面会用到
vi /etc/dhcpcd.conf
</code></pre><ul><li>在文件后面添加内容，下面的IP地址要根据自己所连接WIFI的IP地址改动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface e8:27:39:sd:ed:66 </div><div class="line">static ip_address=192.168.0.3/24 </div><div class="line">static routers=192.168.0.1 </div><div class="line">static domain_name_servers=192.168.0.2 8.8.8.8</div></pre></td></tr></table></figure><pre><code>reboot
</code></pre><h2 id="root登录ssh"><a href="#root登录ssh" class="headerlink" title="root登录ssh"></a>root登录ssh</h2><pre><code>vi /etc/ssh/sshd_config
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PermitRootLogin prohibit-password</div><div class="line">改为</div><div class="line">PermitRootLogin yes</div></pre></td></tr></table></figure><h2 id="防止ssh连接因超时闲置断开"><a href="#防止ssh连接因超时闲置断开" class="headerlink" title="防止ssh连接因超时闲置断开"></a>防止ssh连接因超时闲置断开</h2><pre><code>vi /etc/ssh/sshd_config
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClientAliveInterval 60</div></pre></td></tr></table></figure><pre><code>/etc/init.d/ssh restart
</code></pre><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;前段时间买了个树莓派3，但一直在忙其它东西，就把它荒废了！今天有时间，折腾就一下&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://blog.jmlin.top/categories/Geek/"/>
    
    
      <category term="树莓派3" scheme="https://blog.jmlin.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE3/"/>
    
  </entry>
  
  <entry>
    <title>Uboot前期准备</title>
    <link href="https://blog.jmlin.top/posts/Uboot%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87.html"/>
    <id>https://blog.jmlin.top/posts/Uboot前期准备.html</id>
    <published>2017-10-11T08:33:26.000Z</published>
    <updated>2017-10-11T10:13:16.271Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>考虑到大家之前没有学习嵌入式相关的基础知识，我下面会先从构建代码环境讲起，如果之后大家觉得感兴趣的，我也会写其他东西给大家看！如果大家之后有什么疑问可以直接来找我。<br><a id="more"></a></p><blockquote><p><strong>注：</strong> 以下操作均在Windows平台</p></blockquote><h1 id="Uboot源码文件"><a href="#Uboot源码文件" class="headerlink" title="Uboot源码文件"></a>Uboot源码文件</h1><h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><ul><li>拿到老师给的光盘镜像之后，进入<strong>bootloader</strong>文件</li><li>可以看到<strong>uboot_TQ210_1.3.4_V1.7.tar.bz2</strong>，分别解压两次会得到<strong>opt</strong>这个文件夹，在解压第二次的时候解压器会报出一些错误，可以忽略它（因为里面有Linux平台下的link类型文件与Windows不兼容）</li><li>按路径 <em>opt\EmbedSky\TQ210\uboot_TQ210_1.3.4</em> 依次进入到 <strong>uboot_TQ210_1.3.4</strong> 文件中，此目录在之后的代码分析中，我们称之为uboot的根目录</li></ul><h1 id="Source-Insight-4-0添加uboot源码工程"><a href="#Source-Insight-4-0添加uboot源码工程" class="headerlink" title="Source Insight 4.0添加uboot源码工程"></a>Source Insight 4.0添加uboot源码工程</h1><h2 id="软件安装及其破解"><a href="#软件安装及其破解" class="headerlink" title="软件安装及其破解"></a>软件安装及其破解</h2><ul><li><p>下面是Source Insight 4.0的软件下载链接：</p><blockquote><p>链接：<a href="http://pan.baidu.com/s/1geJWo9d" target="_blank" rel="external">http://pan.baidu.com/s/1geJWo9d</a> 密码：j9qu</p></blockquote></li><li><p>阅读那个 <strong>readme.txt</strong> 文件来破解</p></li></ul><h2 id="添加uboot源码工程"><a href="#添加uboot源码工程" class="headerlink" title="添加uboot源码工程"></a>添加uboot源码工程</h2><ul><li>现在uboot根目录下创建一个文件夹 <strong>SI_Project</strong> ，名字随便起都行，用于存放等下Source Insight创建工程的文件</li><li>打开Source Insight软件，在菜单栏点击Project-&gt; New Project</li><li>标号1是输入将要创建的工程名Uboot1.3.4（自己设置），标号2是选择你电脑uboot的根目录所在的文件夹，然后点击OK<br><img src="\images\Uboot前期准备\1.png" alt=""></li><li>标号1是找到刚才在uboot的根目录所创建的文件夹，我刚才创建了文件夹 <strong>SI_Project</strong>，然后点击OK<br><img src="\images\Uboot前期准备\2.png" alt=""></li><li>在Directory栏选择uboot根目录，然后在右边点击 Add ALL<br><img src="\images\Uboot前期准备\3.png" alt=""></li><li>把第二个勾上，意思是递归添加子目录文件，然后点击OK<br><img src="\images\Uboot前期准备\4.png" alt=""></li><li>等待一下，就可以点击右上角的Close按钮</li><li>点击标号1右侧打开文件目录，点击标号2，在标号3找到uboot根目录，可以看到右侧的文件就是源码文件及其文件夹<br><img src="\images\Uboot前期准备\5.png" alt=""></li></ul><h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><ul><li>因为之后需要浏览.S文件的汇编代码，所以需要在source insight中进行文件类型的关联</li><li>依次在菜单栏点击Options-&gt;File Type Options，在出现的窗口左边选择C Source File，在File filterd下添加 *.S，最后点击Close<br><img src="\images\Uboot前期准备\6.png" alt=""></li></ul><h1 id="Uboot根目录文件介绍"><a href="#Uboot根目录文件介绍" class="headerlink" title="Uboot根目录文件介绍"></a>Uboot根目录文件介绍</h1><ul><li><strong>arm_config.mk</strong> : 后缀为.mk，是一个Makefile文件，将来在某个Makefile中会调用它</li><li><strong>3个Changelog文件</strong> : 修改记录文件，该文件记录了这个uboot项目的版本变迁以及每个版本较上一个版本修改的记录。</li><li><strong>config.mk</strong> : 性质同arm_config.mk</li><li><strong>COPYING</strong> : 版权声明，uboot本身是GPL许可证的</li><li><strong>CREDITS</strong> : 鸣谢，记录了对uboot有贡献的人</li><li><strong>image_split</strong> : 一个脚本</li><li><strong>MAINTAINERS</strong> : 维护者，当前参与维护uboot源码的社区工作者</li><li><strong>MAKEALL</strong> :　一个脚本</li><li><strong>Makefile</strong> : 用于编译整个uboot</li><li><strong>mk</strong> : 快速编译的脚本，即先清理后配置再编译</li><li><strong>mkconfig</strong> ： uboot配置阶段的只要配置脚本，uboot的可移植性很大程度就是靠这个配置脚本在维护</li><li><strong>mkmovi</strong> ： 一个脚本，和inand/SD卡启动有关</li><li><strong>README</strong> : 使用说明书</li><li><strong>rules.mk</strong> : uboot中Makefile使用的规则</li></ul><h1 id="Uboot根文件夹介绍"><a href="#Uboot根文件夹介绍" class="headerlink" title="Uboot根文件夹介绍"></a>Uboot根文件夹介绍</h1><ul><li><strong>api</strong> : 硬件无关功能函数，uboot移植时不用管</li><li><strong>api_examples</strong> : API相关的测试示例代码</li><li><strong>board</strong> : 存放各种开发板相关的配置文件</li><li><strong>common</strong> : 用于存放一些与具体硬件无关的普遍适用的一些代码。譬如控制台实现、crc校验。但是更多的主要是两类：一类是cmd开头的，是用来实现uboot的命令系统的；另一类是env开头的，是用来实现环境变量的</li><li><strong>cpu</strong> ： 与SOC相关的，里面存放的代码都是SOC相关初始化和控制代码（如：CPU的、中断的、串口的等内部外设，包括起始代码start.S）</li><li><strong>disk</strong> : 磁盘有关</li><li><strong>doc</strong> : 文档目录，英文原档，帮助理解uboot</li><li><strong>drivers</strong> ： 存放Linux源代码中扣出来原封不动的Linux设备驱动，用于uboot的运行，主要是开发板上一些必须用到的驱动</li><li><strong>examples</strong> : 示例代码</li><li><strong>fs</strong> ： filesystem文件系统，从Linux源代码中移植过来的，用于管理flash等资源</li><li><strong>include</strong> ： 头文件目录</li><li><strong>lib开头的文件夹</strong> ： 架构相关的库文件 lib_arm(arm架构使用的一些库文件)、lib_generic（所有架构通用的库文件）</li><li><strong>libfdt</strong> ： 设备树有关的，使用设备树来进行启动传参，进行硬件信息的描述</li><li><strong>nand_spl</strong> : nand相关代码</li><li><strong>net</strong> : 网络相关的代码</li><li><strong>onenand开头</strong> ： onenand相关的代码</li><li><strong>tools</strong> : 一些工具类的代码</li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结。</p><p>欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;考虑到大家之前没有学习嵌入式相关的基础知识，我下面会先从构建代码环境讲起，如果之后大家觉得感兴趣的，我也会写其他东西给大家看！如果大家之后有什么疑问可以直接来找我。&lt;br&gt;
    
    </summary>
    
      <category term="Uboot" scheme="https://blog.jmlin.top/categories/Uboot/"/>
    
    
      <category term="Uboot" scheme="https://blog.jmlin.top/tags/Uboot/"/>
    
  </entry>
  
  <entry>
    <title>话说存储类关键字</title>
    <link href="https://blog.jmlin.top/posts/%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB%E5%85%B3%E9%94%AE%E5%AD%97.html"/>
    <id>https://blog.jmlin.top/posts/话说存储类关键字.html</id>
    <published>2017-08-28T02:23:46.000Z</published>
    <updated>2017-09-15T12:05:43.690Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="存储类关键字（用于修饰变量）"><a href="#存储类关键字（用于修饰变量）" class="headerlink" title="存储类关键字（用于修饰变量）"></a>存储类关键字（用于修饰变量）</h1><h2 id="auto-自动变量"><a href="#auto-自动变量" class="headerlink" title="auto(自动变量)"></a>auto(自动变量)</h2><ol><li>auto即平时的局部变量关键字，可以省略，故定义局部变量时都没有写</li><li>分配在内存中的栈上</li></ol><h2 id="register-寄存器变量"><a href="#register-寄存器变量" class="headerlink" title="register(寄存器变量)"></a>register(寄存器变量)</h2><ul><li>这个不是很常用</li></ul><ol><li>编译器会将其所修饰的变量<strong>尽量</strong>分配在寄存器中（使其变量的读写效率会变高）</li><li>由于寄存器数量有限，关键字所修饰的变量不一定都放在寄存器内</li></ol><h2 id="static-静态变量"><a href="#static-静态变量" class="headerlink" title="static(静态变量)"></a>static(静态变量)</h2><ul><li>修饰变量<ol><li>修饰全局变量</li><li>修饰局部变量</li></ol></li><li>修饰函数</li></ul><table><thead><tr><th style="text-align:center">修饰类别</th><th style="text-align:center">形成</th><th style="text-align:center">分配位置</th><th style="text-align:center">生命周期</th><th style="text-align:center">链接属性</th></tr></thead><tbody><tr><td style="text-align:center">局部变量</td><td style="text-align:center">静态局部变量</td><td style="text-align:center">数据段/BSS段</td><td style="text-align:center">代码块作用域</td><td style="text-align:center">无链接</td></tr><tr><td style="text-align:center">全局变量</td><td style="text-align:center">静态全局变量</td><td style="text-align:center">数据段/BSS段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">内链接</td></tr><tr><td style="text-align:center">函数</td><td style="text-align:center">静态函数</td><td style="text-align:center">在其声明文件</td><td style="text-align:center">文件作用域</td><td style="text-align:center">内链接</td></tr></tbody></table><h2 id="extern-外部变量"><a href="#extern-外部变量" class="headerlink" title="extern(外部变量)"></a>extern(外部变量)</h2><ul><li>修饰全局变量，用于文件作用域以外访问</li></ul><h2 id="const-只读变量"><a href="#const-只读变量" class="headerlink" title="const(只读变量)"></a>const(只读变量)</h2><ol><li>其所修饰的变量存储在只读变量区，在C中仍然是变量（C++中，是只读常量）</li><li>编译器通常将const保存在符号表中而非分配存储空间，从而节省了空间，提高了效率（例子：函数传参声明为const指针–另外一个就是防止该指针在函数体内被意外修改）</li></ol><table><thead><tr><th style="text-align:left">就近原则</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">const int a;</td><td style="text-align:left">a是常整型数，a不可变</td></tr><tr><td style="text-align:left">const int *a;</td><td style="text-align:left">a是指向一个常整型数的指针，a所指内容不可变</td></tr><tr><td style="text-align:left">int *const a;</td><td style="text-align:left">a是指向一个整型数的常指针，a不可变</td></tr><tr><td style="text-align:left">const int* const a;</td><td style="text-align:left">a是指向一个常整型数的常指针，a及其所指内容都不可变</td></tr></tbody></table><h3 id="修改const修饰的变量-在GCC环境中"><a href="#修改const修饰的变量-在GCC环境中" class="headerlink" title="修改const修饰的变量(在GCC环境中)"></a>修改const修饰的变量(在GCC环境中)</h3><p>在GCC中，const是通过编译器在编译的时候执行检查来确保实现的(即改const类型变量是编译错误，而非运行时错误)<br>GCC编译器把const类型的变量放在了数据段，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，故只要骗过编译器，const变量就可以修改了。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> *p;</div><div class="line">p = (<span class="keyword">int</span> *)&amp;a;</div><div class="line">*p = <span class="number">6</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"a = %d. \n"</span>, a);</div></pre></td></tr></table></figure><p></p><h2 id="volatile-易变变量"><a href="#volatile-易变变量" class="headerlink" title="volatile(易变变量)"></a>volatile(易变变量)</h2><ul><li>用以修饰一个可以被编译器之外改变的变量，告诉编译器不对改变量的访问进行优化<blockquote><p>编译器之内：当前程序上下文的控制流（即当前代码）<br>编译器之外：中断ISR中引用的变量、多线程中共用的变量、硬件会更改的变量。（编译器在编译时无法预知的更改）</p></blockquote></li></ul><h2 id="typedef-自定义数据类型变量"><a href="#typedef-自定义数据类型变量" class="headerlink" title="typedef(自定义数据类型变量)"></a>typedef(自定义数据类型变量)</h2><p>自定义数据类型（不要与#define相混淆）<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *Pint;    <span class="keyword">const</span> Pint p;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *Pint;    Pint <span class="keyword">const</span> p;</div></pre></td></tr></table></figure><p></p><ul><li>以上两个皆相当于 int *const p; 即p皆为常指针<br>很多初学者都很难去记住上面的两个关系，是因为又与#define相混淆了，还没有完全理解typedef这个关键字<br>原理如下：</li><li>编译器在解析的时候会忽略数据类型，直接修饰p，因此以上两个式子都可以看为 <strong>Pint const p;</strong></li><li>如果实在想不通，就想想 <strong>const int i;</strong> 和<strong>int const i;</strong> 为什么是相同的</li></ul><h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><ul><li>只用于修饰指针；其告知编译器，所有修改该指针所指向内容的操作全部是基于该指针的，即不存在其他进行修改操作的途径<br>看不懂，是不是？其实它的作用就是为了帮助编译器进行更好的代码优化。</li></ul><blockquote><p>该关键字用得少，慎用</p></blockquote><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://blog.jmlin.top/categories/C/"/>
    
    
      <category term="存储类" scheme="https://blog.jmlin.top/tags/%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
    
      <category term="关键字" scheme="https://blog.jmlin.top/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>话说存储类</title>
    <link href="https://blog.jmlin.top/posts/%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB.html"/>
    <id>https://blog.jmlin.top/posts/话说存储类.html</id>
    <published>2017-08-23T02:16:26.000Z</published>
    <updated>2017-08-23T12:06:52.067Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="存储类-Storage-Class"><a href="#存储类-Storage-Class" class="headerlink" title="存储类(Storage Class)"></a>存储类(Storage Class)</h1><p>简单来说，存储类就是C语言中存储变量的地方的类型<br>分为动态存储区，静态存储区</p><h2 id="动态存储区"><a href="#动态存储区" class="headerlink" title="动态存储区"></a>动态存储区</h2><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h3><ul><li>其增长方向：自顶向下增长</li><li>有内存空间的限制<h4 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h4></li></ul><ol><li>函数形参，在调用函数时给形参分配空间</li><li>函数内的自动变量（即普通变量）</li><li>函数调用时的现场保护和返回地址(即函数调用语句的下一句可执行语句)</li></ol><ul><li>在函数调用开始时分配存储空间，函数结束时释放存储空间</li><li>函数调用结束时，局部变量先出栈，接着是形参，最后栈指针指向最开始存储的地址来进行下一条指令</li></ul><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><ul><li>程序员自定义存储空间</li><li>使用后，需要手动释放内存，不然会造成内存泄露</li></ul><h2 id="静态存储区"><a href="#静态存储区" class="headerlink" title="静态存储区"></a>静态存储区</h2><h3 id="data段"><a href="#data段" class="headerlink" title=".data段"></a>.data段</h3><ul><li>存放非零全局变量、静态局部变量</li></ul><h3 id="bss段-Block-Started-by-Symbol"><a href="#bss段-Block-Started-by-Symbol" class="headerlink" title=".bss段(Block Started by Symbol)"></a>.bss段(Block Started by Symbol)</h3><ul><li>存放未初始化的全局变量、静态局部变量</li><li>运行时，由系统初始化，即清零。一般要自己写</li></ul><h3 id="ROData-文本常量区"><a href="#ROData-文本常量区" class="headerlink" title=".ROData(文本常量区)"></a>.ROData(文本常量区)</h3><ul><li>存放字符串常量<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p=<span class="string">"linux"</span>;                <span class="comment">// 定义了一个分配在栈上占4字节的指针指向了一个分配在文本常量区上占6字节的字符串</span></div></pre></td></tr></table></figure></li></ul><h3 id="text段-代码区"><a href="#text段-代码区" class="headerlink" title=".text段(代码区)"></a>.text段(代码区)</h3><ul><li>cup执行的机器指令部分(函数体的二进制代码)</li><li>属性只读，为了防止程序由于意外事故而修改自身指令</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域即变量或函数起作用的范围</p><ul><li>文件作用域</li><li>代码作用域</li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul><li>永久</li><li>临时</li></ul><h1 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h1><p>链接属性有以下3种：</p><ul><li>外链接</li><li>内链接</li><li>无链接<blockquote><p>宏定义 和 inline内联函数 链接属性为 无链接</p></blockquote></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储类</th><th style="text-align:center">作用域</th><th style="text-align:center">生命周期</th><th style="text-align:center">链接属性</th></tr></thead><tbody><tr><td style="text-align:center">普通全局变量</td><td style="text-align:center">.data段/.BSS段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">永久</td><td style="text-align:center">外链接</td></tr><tr><td style="text-align:center">静态全局变量</td><td style="text-align:center">.data段/.BSS段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">永久</td><td style="text-align:center">内链接</td></tr><tr><td style="text-align:center">普通局部变量</td><td style="text-align:center">栈</td><td style="text-align:center">代码作用域</td><td style="text-align:center">临时</td><td style="text-align:center">无链接</td></tr><tr><td style="text-align:center">静态局部变量</td><td style="text-align:center">.data段/.BSS段</td><td style="text-align:center">代码作用域</td><td style="text-align:center">永久</td><td style="text-align:center">无链接</td></tr><tr><td style="text-align:center">普通函数</td><td style="text-align:center">.text段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">永久</td><td style="text-align:center">外链接</td></tr><tr><td style="text-align:center">静态函数</td><td style="text-align:center">.text段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">永久</td><td style="text-align:center">内链接</td></tr></tbody></table><h2 id="堆与栈的比较"><a href="#堆与栈的比较" class="headerlink" title="堆与栈的比较"></a>堆与栈的比较</h2><hr><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">Stack</th><th style="text-align:center">Heap</th></tr></thead><tbody><tr><td style="text-align:center">生长方向</td><td style="text-align:center">向地址减小的方向增长</td><td style="text-align:center">向地址增大的方向增长</td></tr><tr><td style="text-align:center">分配方式</td><td style="text-align:center">动态分配与静态分配</td><td style="text-align:center">动态分配</td></tr><tr><td style="text-align:center">碎片问题</td><td style="text-align:center">无此问题</td><td style="text-align:center">过多使用会造成内存不足</td></tr><tr><td style="text-align:center">申请后系统响应</td><td style="text-align:center">无可用空间报异常提示栈溢出</td><td style="text-align:center">系统分配申请的内存到空闲地址链表中</td></tr><tr><td style="text-align:center">分配效率</td><td style="text-align:center">相对高</td><td style="text-align:center">相对低</td></tr><tr><td style="text-align:center">申请大小</td><td style="text-align:center">系统预先规定好大小</td><td style="text-align:center">系统可用内存</td></tr><tr><td style="text-align:center">申请效率</td><td style="text-align:center">相对快</td><td style="text-align:center">相对慢，容易产生内容碎片</td></tr><tr><td style="text-align:center">存储内容</td><td style="text-align:center">看上面</td><td style="text-align:center">一般在堆的头部用1字节存放堆的大小，其他程序员安排</td></tr><tr><td style="text-align:center">存取效率</td><td style="text-align:center">相对快,char s[]=”Hello”;在运行时赋值;数组比指针要快一些</td><td style="text-align:center">相对慢;char *s=”Hello”;在编译时确定</td></tr></tbody></table><p>最后附上一张内存分布的图片<br><img src="\images\内存分布.png" alt="内存分布"></p><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://blog.jmlin.top/categories/C/"/>
    
    
      <category term="存储类" scheme="https://blog.jmlin.top/tags/%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
    
      <category term="作用域" scheme="https://blog.jmlin.top/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="生命周期" scheme="https://blog.jmlin.top/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="链接属性" scheme="https://blog.jmlin.top/tags/%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Vim之基础入门篇</title>
    <link href="https://blog.jmlin.top/posts/Vim%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87.html"/>
    <id>https://blog.jmlin.top/posts/Vim之基础入门篇.html</id>
    <published>2017-08-20T12:00:56.000Z</published>
    <updated>2017-08-22T04:25:39.243Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>很多人都对vim这货有所敬畏，其实只要多动手，vim是很容易上手的。用了vim大半年了，今天就写个基础入门篇，之后有空再加个高手进阶篇<br><a id="more"></a></p><h1 id="在命令模式下移动光标"><a href="#在命令模式下移动光标" class="headerlink" title="在命令模式下移动光标"></a>在命令模式下移动光标</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                        <span class="keyword">k</span>(上)</div><div class="line">                                </div><div class="line">h(左)                                               <span class="keyword">l</span>(右)</div><div class="line">                        </div><div class="line">                        <span class="keyword">j</span>(下)</div></pre></td></tr></table></figure><h1 id="从命令模式进入插入模式"><a href="#从命令模式进入插入模式" class="headerlink" title="从命令模式进入插入模式"></a>从命令模式进入插入模式</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">a</span>       // 光标后插入</div><div class="line">i       // 光标前插入</div></pre></td></tr></table></figure><h1 id="从插入模式进入命令模式"><a href="#从插入模式进入命令模式" class="headerlink" title="从插入模式进入命令模式"></a>从插入模式进入命令模式</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Esc</div></pre></td></tr></table></figure><h1 id="在命令模式下操作"><a href="#在命令模式下操作" class="headerlink" title="在命令模式下操作"></a>在命令模式下操作</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yy      // 复制光标所在的一行</div></pre></td></tr></table></figure><h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">p</span>       // 粘贴到光标后</div><div class="line"><span class="keyword">P</span>       // 粘贴到光标前</div></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">x</span>       // 删除光标后的一个字母</div></pre></td></tr></table></figure><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd      // 剪切光标所在的一行</div></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">u</span>       // 撤销上一次操作</div><div class="line">U       // 撤销所在行的所以操作</div></pre></td></tr></table></figure><h1 id="从命令模式进入底线命令模式"><a href="#从命令模式进入底线命令模式" class="headerlink" title="从命令模式进入底线命令模式"></a>从命令模式进入底线命令模式</h1><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="keyword">w</span></div></pre></td></tr></table></figure><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:q          // 如果所编辑的文件有更改，则退出失败</div></pre></td></tr></table></figure><h2 id="保存并退出"><a href="#保存并退出" class="headerlink" title="保存并退出"></a>保存并退出</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="keyword">wq</span></div></pre></td></tr></table></figure><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;很多人都对vim这货有所敬畏，其实只要多动手，vim是很容易上手的。用了vim大半年了，今天就写个基础入门篇，之后有空再加个高手进阶篇&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://blog.jmlin.top/categories/Geek/"/>
    
    
      <category term="vim" scheme="https://blog.jmlin.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>浅谈指针</title>
    <link href="https://blog.jmlin.top/posts/%E8%AF%9D%E8%AF%B4%E6%8C%87%E9%92%88.html"/>
    <id>https://blog.jmlin.top/posts/话说指针.html</id>
    <published>2017-08-20T06:05:08.000Z</published>
    <updated>2017-08-23T02:11:15.566Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="一级指针"><a href="#一级指针" class="headerlink" title="一级指针"></a>一级指针</h1><p>指针其实就是存放内存地址的变量，其长度在32位系统上固定为4字节。</p><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><ul><li>数组的存储内容是指针<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p[];</div></pre></td></tr></table></figure></li></ul><h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><ul><li>指向一个数组的指针<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*p)[];</div></pre></td></tr></table></figure></li></ul><h1 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h1><ul><li>函数的返回值类型是一个指针类型<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pf</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">/* or */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> *<span class="title">pf</span><span class="params">()</span></span>;</div><div class="line"><span class="function">pf <span class="title">function</span><span class="params">()</span></span>;              <span class="comment">// 定义实例</span></div></pre></td></tr></table></figure></li></ul><p>所以指针函数用于修饰函数返回值</p><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><ul><li>指向一个函数的指针(函数名 与 &amp;函数名 都表示函数运行的首地址)<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*fp)();</div><div class="line"><span class="comment">/* or */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*fp)</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">char</span>)</span></span>;</div><div class="line">fp function;                <span class="comment">// 定义实例</span></div></pre></td></tr></table></figure></li></ul><h1 id="二重指针"><a href="#二重指针" class="headerlink" title="二重指针"></a>二重指针</h1><ul><li>指向一个int*类型的指针<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> **p;</div></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">实例</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">int a;</td><td style="text-align:center">&amp;a是一个int *型变量</td></tr><tr><td style="text-align:center">int *p;</td><td style="text-align:center">指针p指向一个int型变量</td></tr><tr><td style="text-align:center">int **p;</td><td style="text-align:center">指针p指向一个int *型变量</td></tr></tbody></table><hr><p><table><br><tr><br><th rowspan="2">int a[3]</th><br><th>a</th><br><th>a</th><br><th>a+1</th><br><th>&amp;a</th><br><th>&amp;a+1</th><br></tr><br><tr><br><td>int <em>类型</em></td><br><td>数组首元素首地址</td><br><td>(int)a + 1sizeof(int), 地址加4byte即a[1]</td><br><td>数组首地址</td><br><td>(int)a + 1*sizeof(int[3]), 地址加12byte即a[3]</td><br></tr></table></p><h2><a href="#" class="headerlink"></a></h2><h1 id="话说大端小端"><a href="#话说大端小端" class="headerlink" title="话说大端小端"></a>话说大端小端</h1><ul><li>大端：数据的高字节存储在低地址中</li><li>小端：数据的低字节存储在低地址中</li></ul><h2 id="代码判断"><a href="#代码判断" class="headerlink" title="代码判断"></a>代码判断</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> myunion</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">char</span> b;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BigorSmall</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">union</span> myunion u1;</div><div class="line">    u1.a = <span class="number">1</span>;                </div><div class="line">    <span class="keyword">return</span> u1.b;                <span class="comment">// 地址0的那个字节内是1（小端）或者0（大端）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">BigorSmall</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> b = *((<span class="keyword">char</span> *)(&amp;a));       </div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="指针都是4字节，为什么还要定义指针类型？"><a href="#指针都是4字节，为什么还要定义指针类型？" class="headerlink" title="指针都是4字节，为什么还要定义指针类型？"></a>指针都是4字节，为什么还要定义指针类型？</h1><p>定义指针类型的好处是：定义一个指针时，编译器为指针所指向的内容定义好大小，无需程序员去管理</p><h1 id="代码中的变量在内存的情况"><a href="#代码中的变量在内存的情况" class="headerlink" title="代码中的变量在内存的情况"></a>代码中的变量在内存的情况</h1><blockquote><p>计算机的内存地址分配原则：<br>内存寻址由大到小，优先分配内存地址较大的空间给变量（从下往上），先定义的变量，分配的地址越大<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">char</span> c = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> *p = &amp;c;                <span class="comment">// 编译器不会报错，但会有警告，因为指针类型不匹配</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d .\n"</span>,*p);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p></blockquote><p><img src="\images\变量在内存的分布情况.png" alt="代码中的变量在内存的情况"></p><ul><li>指针读取数据是箭头从下往上读取，该代码运行结果为513</li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://blog.jmlin.top/categories/C/"/>
    
    
      <category term="指针" scheme="https://blog.jmlin.top/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="大端小端" scheme="https://blog.jmlin.top/tags/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>话说内存对齐</title>
    <link href="https://blog.jmlin.top/posts/%E8%AF%9D%E8%AF%B4%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html"/>
    <id>https://blog.jmlin.top/posts/话说内存对齐.html</id>
    <published>2017-08-20T03:09:09.000Z</published>
    <updated>2017-08-23T07:26:21.552Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>颓废了一个多星期，感觉还是要写个博客压压惊！！！<br><a id="more"></a></p><h1 id="为什么会有内存对齐？"><a href="#为什么会有内存对齐？" class="headerlink" title="为什么会有内存对齐？"></a>为什么会有内存对齐？</h1><p>为了访问未对齐的内存，处理器需要作两次内存访问；而，对齐访问仅需要一次访问。</p><h1 id="对齐参数"><a href="#对齐参数" class="headerlink" title="对齐参数"></a>对齐参数</h1><p>32位系统中，默认4字节对齐（32位系统CPU字长是4字节）</p><ul><li>在Windows(32)/VC6.0下各种数据类型的变量的自身对齐参数就是该数据类型变量所占字节数的大小</li><li>在Linux(32)/GCC下double类型下的对齐参数为4<ul><li>Linux(32)/GCC下如果该数据类型的长度没有超过CPU的字长，则以该数据类型变量的长度作为自身对齐参数</li><li>如果超过了CPU字长，则自身对齐参数为CPU字长</li></ul></li></ul><h1 id="字节对齐原则"><a href="#字节对齐原则" class="headerlink" title="字节对齐原则"></a>字节对齐原则</h1><ul><li>结构体每个成员相对结构体首地址的偏移量(offset)是<em>对齐参数</em>(此对齐参数是取每个变量自身对齐参数和系统对齐参数两者中较小的一个)的整数倍，如果有需要会在每个成员之间填充字节<ul><li>编译器在为结构体成员开辟空间时，首先检查预开辟空间的地址相对于结构体首地址的偏移量是否为对齐参数的整数倍，若是，则存放该成员，否则，反之</li></ul></li><li>结构体变量所占空间的大小是对齐参数大小的整数倍，如有需要会在最后一个成员末尾填充若干字节使得所占空间是<em>对齐参数</em> (对结构体中所有变量的对齐参数的最大值和系统默认对齐参数<strong>#pragma pack(n)</strong>比较，较小者作为对齐参数)的整数倍</li></ul><blockquote><p>static修饰的变量所占空间没有被算入，因为其存储在.bss段/.data段</p></blockquote><h1 id="内存对齐的关键字"><a href="#内存对齐的关键字" class="headerlink" title="内存对齐的关键字"></a>内存对齐的关键字</h1><p>GCC推荐的对齐指令<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__attribute__((packed))     <span class="comment">// 一字节对齐使用时，直接接放在进行内存对齐的类型定义后面，其作用范围为使用该类型定义的变量</span></div><div class="line"></div><div class="line">__attribute__((aligned(n))) <span class="comment">// 用法同上，使整个结构体进行n字节的对齐(n为2的幂次方)</span></div></pre></td></tr></table></figure><p></p><p>GCC支持但不推荐的对齐指令<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)     <span class="comment">// 放在自定义字节对齐的数据结构开头，指定编译器对齐参数为n字节</span></span></div><div class="line">定义结构体</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()      <span class="comment">// 放在自定义字节对齐的数据结构结尾，取消指定对齐参数，恢复缺省参数</span></span></div></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;颓废了一个多星期，感觉还是要写个博客压压惊！！！&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://blog.jmlin.top/categories/C/"/>
    
    
      <category term="嵌入式C" scheme="https://blog.jmlin.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FC/"/>
    
  </entry>
  
  <entry>
    <title>Uboot下烧录Linux内核镜像</title>
    <link href="https://blog.jmlin.top/posts/Uboot%E4%B8%8B%E7%83%A7%E5%BD%95Linux%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F.html"/>
    <id>https://blog.jmlin.top/posts/Uboot下烧录Linux内核镜像.html</id>
    <published>2017-08-05T06:37:40.000Z</published>
    <updated>2017-08-22T02:06:01.415Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>本文的操作平台是S5PV210.<br><a id="more"></a></p><h2 id="启动介质-SD卡-iNand-Nand-NorFlash等-烧录镜像"><a href="#启动介质-SD卡-iNand-Nand-NorFlash等-烧录镜像" class="headerlink" title="启动介质(SD卡/iNand/Nand/NorFlash等)烧录镜像"></a>启动介质(SD卡/iNand/Nand/NorFlash等)烧录镜像</h2><ul><li>进入Uboot命令行<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">movi <span class="built_in">read</span> kernel 30008000           // 从启动介质的kernel分区去读取内核镜像到DDR地址为0x30008000处</div><div class="line">bootm 30008000                      // 启动内核</div></pre></td></tr></table></figure></li></ul><h2 id="tftp烧录镜像"><a href="#tftp烧录镜像" class="headerlink" title="tftp烧录镜像"></a>tftp烧录镜像</h2><h3 id="虚拟机Ubuntu"><a href="#虚拟机Ubuntu" class="headerlink" title="虚拟机Ubuntu"></a>虚拟机Ubuntu</h3><ul><li><a href="http://jmlin.club/%E9%85%8D%E7%BD%AETFTP.html" target="_blank" rel="external">配置tftp服务器</a></li><li>设置Ubuntu静态IP(192.168.1.141)</li><li>将要烧录的镜像放到Ubuntu的tftp文件夹（/tftpboot）中<h3 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h3></li><li><p>进入Uboot命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> ipaddr 192.168.1.20</div><div class="line"><span class="built_in">set</span> gatewayip 192.168.1.1</div><div class="line"><span class="built_in">set</span> serverip 192.168.1.141      // 设置为tftp服务器所在平台的IP</div></pre></td></tr></table></figure></li><li><p>测试连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping 192.168.1.141</div></pre></td></tr></table></figure></li></ul><h3 id="烧录镜像"><a href="#烧录镜像" class="headerlink" title="烧录镜像"></a>烧录镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tftp 0x30008000 zImage-qt           // 将服务器下的zImage-qt镜像下载到DDR地址为0x30008000处</div><div class="line">bootm 0x30008000                    // 启动内核</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本文的操作平台是S5PV210.&lt;br&gt;
    
    </summary>
    
      <category term="Uboot" scheme="https://blog.jmlin.top/categories/Uboot/"/>
    
    
      <category term="Uboot" scheme="https://blog.jmlin.top/tags/Uboot/"/>
    
  </entry>
  
  <entry>
    <title>配置TFTP</title>
    <link href="https://blog.jmlin.top/posts/%E9%85%8D%E7%BD%AETFTP.html"/>
    <id>https://blog.jmlin.top/posts/配置TFTP.html</id>
    <published>2017-08-05T06:21:46.000Z</published>
    <updated>2017-08-22T01:58:57.898Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>Uboot启动内核镜像，除了在SD卡、Nand等raw分区中启动外，还可以通过tftp从远端服务器获取镜像。<br>下面是配置tftp的过程<br><a id="more"></a></p><h1 id="安装TFTP客户端、服务程序和xinetd"><a href="#安装TFTP客户端、服务程序和xinetd" class="headerlink" title="安装TFTP客户端、服务程序和xinetd"></a>安装TFTP客户端、服务程序和xinetd</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tftp-hpa tftpd-hpa</div><div class="line">sudo apt-get install xinetd</div></pre></td></tr></table></figure><h1 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h1><h2 id="配置-etc-xinetd-conf"><a href="#配置-etc-xinetd-conf" class="headerlink" title="配置/etc/xinetd.conf"></a>配置/etc/xinetd.conf</h2><p>若没有，则创建，然后修改，下同<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Simple configuration file for xinetd</div><div class="line">##</div><div class="line">Some defaults, and include /etc/xinetd.d/</div><div class="line">defaults</div><div class="line">&#123;#</div><div class="line">Please note that you need a log_type line to be able to use log_on_success</div><div class="line"># and log_on_failure. The default is the following :</div><div class="line"># log_type = SYSLOG daemon info</div><div class="line">&#125;</div><div class="line">includedir /etc/xinetd.d</div></pre></td></tr></table></figure><p></p><h2 id="配置-etc-default-tftpd-hpa"><a href="#配置-etc-default-tftpd-hpa" class="headerlink" title="配置/etc/default/tftpd-hpa"></a>配置/etc/default/tftpd-hpa</h2><p>将内容改为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># /etc/default/tftpd-hpa</div><div class="line">TFTP_USERNAME=&quot;tftp&quot;</div><div class="line">TFTP_DIRECTORY=&quot;/tftpboot&quot;</div><div class="line">TFTP_ADDRESS=&quot;0.0.0.0:69&quot;</div><div class="line">TFTP_OPTIONS=&quot;-l -c -s&quot;</div></pre></td></tr></table></figure><p></p><h2 id="配置-etc-xinetd-d-tftp"><a href="#配置-etc-xinetd-d-tftp" class="headerlink" title="配置/etc/xinetd.d/tftp"></a>配置/etc/xinetd.d/tftp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">service tftp</div><div class="line">&#123;</div><div class="line">socket_type = dgram</div><div class="line">wait = yes</div><div class="line">disable = no</div><div class="line">user = root</div><div class="line">protocol = udp</div><div class="line">server = /usr/sbin/in.tftpd</div><div class="line">server_args = -s /tftpboot</div><div class="line">#log_on_success += PID HOST DURATION</div><div class="line">#log_on_failure += HOST</div><div class="line">per_source = 11</div><div class="line">cps =100 2</div><div class="line">flags =IPv4</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>创建一个服务器存放文件的文件夹并设置最高权限<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /tftpboot</div><div class="line">sudo chmod 777 /tftpboot</div></pre></td></tr></table></figure><p></p><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2><p>每次修改完配置文件都需要重启服务<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo service tftpd-hpa restart</div><div class="line">sudo /etc/init.d/xinetd reload</div><div class="line">sudo /etc/init.d/xinetd restart</div></pre></td></tr></table></figure><p></p><h1 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h1><ol><li>在/tftpboot 中新建一个文件file</li><li><p>进入另一个文件夹中<br>进入本地tftp命令行下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo tftp localhost</div><div class="line">// 可输入<span class="built_in">help</span>查看命令和命令作用</div></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get file    // 下载文件到当前文件夹 </div><div class="line">put file    // 上传文件到tftp服务器</div><div class="line">q           // 退出tftp命令行</div></pre></td></tr></table></figure></li></ol><h1 id="非本地"><a href="#非本地" class="headerlink" title="非本地"></a>非本地</h1><ol><li>关闭防火墙（sudo ufw disable）或 卸载防火墙（sudo apt -get remove iptables）</li><li>sudo tftp 目标ip地址</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Uboot启动内核镜像，除了在SD卡、Nand等raw分区中启动外，还可以通过tftp从远端服务器获取镜像。&lt;br&gt;下面是配置tftp的过程&lt;br&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="https://blog.jmlin.top/categories/Ubuntu/"/>
    
    
      <category term="TFTP" scheme="https://blog.jmlin.top/tags/TFTP/"/>
    
      <category term="Ubuntu" scheme="https://blog.jmlin.top/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Uboot启动两个阶段</title>
    <link href="https://blog.jmlin.top/posts/Uboot%E5%90%AF%E5%8A%A8%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5.html"/>
    <id>https://blog.jmlin.top/posts/Uboot启动两个阶段.html</id>
    <published>2017-08-05T02:58:51.000Z</published>
    <updated>2017-10-02T13:59:28.999Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="Uboot启动两级阶段"><a href="#Uboot启动两级阶段" class="headerlink" title="Uboot启动两级阶段"></a>Uboot启动两级阶段</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><ul><li>流程：</li></ul><div id="flowchart-0" class="flow-chart"></div><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><blockquote><p>对开发板级别的硬件、软件数据结构进行初始化</p></blockquote><ul><li>代码分析<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">start_armboot       <span class="comment">// 开始arm的启动</span></div><div class="line">    <span class="comment">// Uboot启动地址0x33e00000  Uboot大小2M     堆大小912KB         栈大小512KB     存放全局数据的结构体</span></div><div class="line">    gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>);     </div><div class="line">    gd = (<span class="keyword">gd_t</span>*)gd_base;            <span class="comment">// 将结构体指针gd实例化（分配空间）</span></div><div class="line">    init_sequence();</div><div class="line">        cpu_init();                 <span class="comment">// 空的，在汇编阶段已经初始化过</span></div><div class="line">        board_init();               <span class="comment">// 开发板</span></div><div class="line">            dm9000_pre_init();      <span class="comment">// 网卡初始化</span></div><div class="line">            gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE;             <span class="comment">// 机器码</span></div><div class="line">            gd-&gt;bd-&gt;bi_boot_params = (PHYS_SDRAM_1+<span class="number">0x100</span>);  <span class="comment">// 内存传参（启动参数）</span></div><div class="line">        interrupt_init();           <span class="comment">// 定时器4，用于计时</span></div><div class="line">        env_init();                 <span class="comment">// 环境变量初始化</span></div><div class="line">        init_baudrate();            <span class="comment">// 软件层gd数据结构波特率初始化     </span></div><div class="line">        serial_init();              <span class="comment">// 空的，在汇编阶段已经初始化过</span></div><div class="line">        console_init_f();           <span class="comment">// 控制台第一步初始化</span></div><div class="line">        display_banner();           <span class="comment">// 打印Uboot版本号</span></div><div class="line">        print_cpuinfo();            <span class="comment">// 打印SOC时钟频率信息</span></div><div class="line">        checkboard();               <span class="comment">// 检验开发板名字</span></div><div class="line">        dram_init();                <span class="comment">// 软件层gd数据结构DDR信息初始化</span></div><div class="line">        display_dram_config();      <span class="comment">// 打印板上DDR内存大小</span></div><div class="line">    mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE);    <span class="comment">// 初始化Uboot所维护的堆内存</span></div><div class="line">    mmc_initialize(gd-&gt;bd);         <span class="comment">// 初始化iNand/SD卡 或 SOC上的控制器</span></div><div class="line">    env_relocate ();                <span class="comment">// 环境变量重定位</span></div><div class="line">    gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr (<span class="string">"ipaddr"</span>);      <span class="comment">// 初始化软件层gd数据结构IP地址</span></div><div class="line">    gd-&gt;bd-&gt;bi_enetaddr             <span class="comment">// 初始化软件层gd数据结构以太网地址</span></div><div class="line">    devices_init ();                <span class="comment">// 参数传递，没有实现驱动初始化</span></div><div class="line">    jumptable_init ();              <span class="comment">// 跳转表</span></div><div class="line">    console_init_r ();              <span class="comment">// 控制台第二步初始化</span></div><div class="line">    enable_interrupts ();           <span class="comment">// 空的</span></div><div class="line">    loadaddr、bootfile               <span class="comment">// 内核启动环境变量读出初始化全局变量</span></div><div class="line">    board_late_init ();             <span class="comment">// 空的</span></div><div class="line">    eth_initialize(gd-&gt;bd);         <span class="comment">// 空的</span></div><div class="line">    x210_preboot_init();            <span class="comment">// LCD初始化和显示开机logo</span></div><div class="line">    check_menu_update_from_sd()     <span class="comment">// 检查自动更新</span></div><div class="line">    main_loop()                     <span class="comment">// 主循环</span></div></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">第一阶段</th><th style="text-align:center">第二阶段</th></tr></thead><tbody><tr><td style="text-align:center">语言</td><td style="text-align:center">汇编阶段</td><td style="text-align:center">C阶段</td></tr><tr><td style="text-align:center">代码所在区域</td><td style="text-align:center">SRAM</td><td style="text-align:center">DRAM</td></tr><tr><td style="text-align:center">初始化</td><td style="text-align:center">SoC内部</td><td style="text-align:center">SoC外部Board内部</td></tr></tbody></table><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display:none">st=>start: Uboot入口
e=>end: 第二阶段
io=>inputoutput: 
step1=>operation: ENTRY(_start)
step2=>operation: 构建异常向量表
step3=>operation: 禁止中断,进入ARM状态,SVC模式
step4=>operation: 设置L2、L1cache和MMU
step5=>operation: 识别并暂存启动介质选择
step6=>operation: 第一次设置栈(SRAM)并调用lowlevel_init
step7=>operation: 检查复位状态
step8=>operation: 关看门狗
step9=>operation: 供电锁存
step10=>operation: 判断运行地址决定是否初始化时钟和DDR
step11=>operation: system_clock_init(时钟初始化)
step12=>operation: mem_ctrl_asm_init(DDR初始化)
step13=>operation: uart_asm_init(串口初始化并打印'O')
step14=>operation: pop {pc}     (打印'K')
step15=>operation: 第二次设置栈(DDR)
step16=>operation: 判断Uboot是否进行Relocate
step17=>operation: movi_bl2_copy
step18=>operation: 使能域访问
step19=>operation: 设置TTB(转换表基地址)
step20=>operation: 使能MMU单元
step21=>operation: 第三次设置栈(DDR)
step22=>operation: 清理BSS段
step23=>operation: _start_armboot

st(right)->step1->step2->step3
step3->step4->step5->step6
step6->step7->step8->step9
step9->step10->step11->step12
step12->step13->step14->step15
step15->step16->step17->step18->step19->step20
step20->step21->step22->step23(right)->e</textarea><textarea id="flowchart-0-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)</script></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="Uboot" scheme="https://blog.jmlin.top/categories/Uboot/"/>
    
    
      <category term="Uboot" scheme="https://blog.jmlin.top/tags/Uboot/"/>
    
  </entry>
  
  <entry>
    <title>Uboot主目录下的Makefile分析</title>
    <link href="https://blog.jmlin.top/posts/Uboot%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84Makefile%E5%88%86%E6%9E%90.html"/>
    <id>https://blog.jmlin.top/posts/Uboot主目录下的Makefile分析.html</id>
    <published>2017-07-31T09:07:24.000Z</published>
    <updated>2017-08-22T02:06:51.140Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --><p>本文是针对Uboot1.3.4 for x210来分析的，学习总结之余，也供大家参详！！！<br><a id="more"></a></p><h2 id="uboot-version确定（24-29）"><a href="#uboot-version确定（24-29）" class="headerlink" title="uboot version确定（24~29）"></a>uboot version确定（24~29）</h2><ul><li>VERSION:主版本号</li><li>PATCHLEVEL：次版本号</li><li>SUBLEVEL：再次版本号</li><li>EXTRAVERSION:另外附加的版本信息<blockquote><p>include/version_autogenerated.h文件是编译过程中自动生成的一个文件，里面的内容就是我们在Makefile中配置的uboot的版本号</p></blockquote></li></ul><h2 id="HOSTARCH和HOSTOS（31-41）"><a href="#HOSTARCH和HOSTOS（31-41）" class="headerlink" title="HOSTARCH和HOSTOS（31~41）"></a>HOSTARCH和HOSTOS（31~41）</h2><ul><li>直接在shell中执行uname -m 得到的就是电脑CPU的版本号</li><li>获取 HOSTARCH（CPU架构） HOSTOS（主机系统）</li></ul><h2 id="静默编译（50-54）"><a href="#静默编译（50-54）" class="headerlink" title="静默编译（50~54）"></a>静默编译（50~54）</h2><ul><li>编译时哦make -s ，-s会作为MAKEFLAGS传给Makefile，因此XECHO变量=echo，即输出空信息</li></ul><h2 id="单独输出文件夹编译（78-93）"><a href="#单独输出文件夹编译（78-93）" class="headerlink" title="单独输出文件夹编译（78~93）"></a>单独输出文件夹编译（78~93）</h2><ol><li>make O=输出目录</li><li>export BUILD_DIR=输出目录，然后make</li><li>若以上两者都指定了，O=输出目录具有更高的优先级</li></ol><h2 id="确定OBJTREE、SRCTREE、TOPDIR"><a href="#确定OBJTREE、SRCTREE、TOPDIR" class="headerlink" title="确定OBJTREE、SRCTREE、TOPDIR"></a>确定OBJTREE、SRCTREE、TOPDIR</h2><ul><li>OBJTREE: 存放编译出.o文件目录的根目录，在默认编译下，OBJTREE等于当前目录</li><li>SRCTREE: 源码目录，源代码的根目录，当前目录</li><li>TOPDIR: 源码目录</li></ul><h2 id="定义MKCONFIG变量（101）"><a href="#定义MKCONFIG变量（101）" class="headerlink" title="定义MKCONFIG变量（101）"></a>定义MKCONFIG变量（101）</h2><ul><li>其值为源码根目录下mkconfig脚本文件，是uboot配置阶段配置脚本</li></ul><h2 id="include-obj-include-config-mk-133"><a href="#include-obj-include-config-mk-133" class="headerlink" title="include $(obj)include.config.mk(133)"></a>include $(obj)include.config.mk(133)</h2><ul><li>include/config.mk不是源码自带的，是配置过程（make x210_sd_config）生成的<br>其内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ARCH   = arm</div><div class="line">CPU    = s5pc11x</div><div class="line">BOARD  = x210</div><div class="line">VENDOR = samsung</div><div class="line">SOC    = s5pc110</div></pre></td></tr></table></figure></li></ul><h2 id="调用MKCONFIG脚本传参（2589）"><a href="#调用MKCONFIG脚本传参（2589）" class="headerlink" title="调用MKCONFIG脚本传参（2589）"></a>调用MKCONFIG脚本传参（2589）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x210_sd_config : unconfig                                                                                                               #依赖为unconfig</div><div class="line">        @$(MKCONFIG) $(@:_config=) arm s5pc11xx 210 samsung s5pc110                               #传入参数有6个，$(@:_config=)变为x210_sd</div><div class="line">        @echo &quot;TEXT_BASE = 0xc3e00000&quot; &gt; $(obj)board/samsung/x210/config.mk                    #创建config.mk文件并添加内容</div></pre></td></tr></table></figure><ul><li>上面代码中的依赖 unconfig其定义在(473) 实现重复配置无报错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">unconfig:</div><div class="line">        @rm -f $(obj)include/config.h $(obj)include/config.mk \</div><div class="line">                $(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \</div><div class="line">                $(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep \</div><div class="line">                $(obj)board/$(VENDOR)/$(BOARD)/config.mk</div></pre></td></tr></table></figure><h2 id="ARCH-CROSS-COMPILE"><a href="#ARCH-CROSS-COMPILE" class="headerlink" title="ARCH CROSS_COMPILE"></a>ARCH CROSS_COMPILE</h2><ul><li>ARCH（133） 定义当前编译的目标CPU的架构</li><li>CROSS_COMPILE（136~180） 是定义交叉编译工具链的前缀（因为不同芯片所支持的工具链前缀都不一样，而后缀是一样的，这样定义增强程序可移植性）</li><li>可以在编译时用make CROSS_COMPILE=xxx来实现编译传参覆盖Makefile里面的设置</li></ul><h2 id="include-TOPDIR-config-mk（185）"><a href="#include-TOPDIR-config-mk（185）" class="headerlink" title="include $(TOPDIR)/config.mk（185）"></a>include $(TOPDIR)/config.mk（185）</h2><ul><li>运行其他配置，即进入config.mk文件</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Sep 27 2018 11:07:39 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本文是针对Uboot1.3.4 for x210来分析的，学习总结之余，也供大家参详！！！&lt;br&gt;
    
    </summary>
    
      <category term="Uboot" scheme="https://blog.jmlin.top/categories/Uboot/"/>
    
    
      <category term="Uboot" scheme="https://blog.jmlin.top/tags/Uboot/"/>
    
  </entry>
  
</feed>
