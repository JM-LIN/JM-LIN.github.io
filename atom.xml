<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JM.Lin&#39;s Blogs</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.jmlin.club/"/>
  <updated>2017-12-22T10:09:44.666Z</updated>
  <id>https://www.jmlin.club/</id>
  
  <author>
    <name>JM.Lin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于TQ210的学习小过程</title>
    <link href="https://www.jmlin.club/posts/%E5%9F%BA%E4%BA%8ETQ210%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%BF%87%E7%A8%8B.html"/>
    <id>https://www.jmlin.club/posts/基于TQ210的学习小过程.html</id>
    <published>2017-12-22T09:16:44.000Z</published>
    <updated>2017-12-22T10:09:44.666Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><blockquote><p>因为开发环境的差异，以下的操作可能会有点出入，所以要学会自己去修改，网上也会有相应的提示</p></blockquote><h1 id="Uboot修改"><a href="#Uboot修改" class="headerlink" title="Uboot修改"></a>Uboot修改</h1><blockquote><p><font color="#0099ff" size="5" face="黑体">基于Uboot1.3.4<font></font></font></p></blockquote><h2 id="初步检查"><a href="#初步检查" class="headerlink" title="初步检查"></a>初步检查</h2><h3 id="1-检查交叉编译工具链"><a href="#1-检查交叉编译工具链" class="headerlink" title="1.检查交叉编译工具链"></a>1.检查交叉编译工具链</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi Makefile</div></pre></td></tr></table></figure><p>查看CROSS_COMPILE是否正确</p><ul><li>其实也可以在编译的时候加上编译链传入参数例如<code>make -j8 CROSS_COMPILE=arm-linux-</code></li></ul><h3 id="2-编译源码并烧录"><a href="#2-编译源码并烧录" class="headerlink" title="2.编译源码并烧录"></a>2.编译源码并烧录</h3><ul><li>查看Makefile，查找开发板配置信息</li><li>本开发板型号：s5pc11x</li><li><p>会看到smdkv210single_config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make smdkv210single_config</div><div class="line">make</div></pre></td></tr></table></figure></li><li><p>进入烧录目录(sd_fusing)检查文件参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">file mkbl1</div></pre></td></tr></table></figure></li></ul><p>其参数应为Intel 80386<br>若不是，则重新编译本目录文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make clean &amp;&amp; make</div></pre></td></tr></table></figure><p></p><h3 id="烧录"><a href="#烧录" class="headerlink" title="烧录"></a>烧录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./sd_fusing.sh /dev/sdb(根据实际情况改动)</div></pre></td></tr></table></figure><h2 id="后续移植"><a href="#后续移植" class="headerlink" title="后续移植"></a>后续移植</h2><h3 id="0-修改配置信息"><a href="#0-修改配置信息" class="headerlink" title="0.修改配置信息"></a>0.修改配置信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define CONFIG_IDENT_STRING &quot; for SMDKV210 Transplanted by JM.Lin&quot;</div></pre></td></tr></table></figure><h3 id="1-杂项"><a href="#1-杂项" class="headerlink" title="1.杂项"></a>1.杂项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">start.S</div><div class="line">    ↓</div><div class="line">bl PMIC_InitIp      // 将其屏蔽，没有此功能</div></pre></td></tr></table></figure><h3 id="2-内存初始化"><a href="#2-内存初始化" class="headerlink" title="2.内存初始化"></a>2.内存初始化</h3><blockquote><p>设置两个内存的地址连续储存<br>即把内存1的起始地址从0x20000000变为0x30000000</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">↓ [smdkv210single.h]</div><div class="line">#define SDRAM_BANK_SIZE         0x10000000              // 本机有两个为256MB大的内存</div><div class="line">    ↓</div><div class="line">#define PHYS_SDRAM_1            MEMORY_BASE_ADDRESS     // 第一块的物理内存地址设置为0x30000000</div><div class="line">        ↓</div><div class="line">#define PHYS_SDRAM_2            0x40000000              // 第二块的物理内存地址设置为0x40000000</div><div class="line">            ↓                                               // 设置MEMCONFIG_0寄存器</div><div class="line">#define DMC0_MEMCONFIG_0    0x30F01323                  // 30为地址放到0x30000000地址，F0表示地址范围0-0x0FFFFFFF,256MB</div><div class="line">                ↓</div><div class="line">#ifdef CONFIG_ENABLE_MMU                                // 设置Uboot虚拟映射起始地址</div><div class="line">#define CFG_UBOOT_BASE      0xc3e00000</div><div class="line">#else</div><div class="line">#define CFG_UBOOT_BASE      0x33e00000                  // 不使能MMU时，用到，由0x23e00000更改</div><div class="line">#endif</div><div class="line">                    ↓</div><div class="line">#define virt_to_phys(x) virt_to_phy_smdkc110(x)         // 虚拟地址到物理地址的转换</div><div class="line">                        ↓ [smdkc110.c]</div><div class="line">return (addr - 0xc0000000 + 0x30000000);                // 实现虚拟地址0xc0000000映射到0x30000000</div><div class="line">                            ↓ [lowlevel_init.S]</div><div class="line">.set __base,0x300               // 下面是c0000000-d0000000这段虚拟地址表设置，映射到20000000-30000000这段物理地址上</div><div class="line">.rept 0xD00 - 0xC00</div></pre></td></tr></table></figure><h3 id="3-MMC配置"><a href="#3-MMC配置" class="headerlink" title="3.MMC配置"></a>3.MMC配置</h3><ul><li><p>法1：<br>根据uboot启动回显信息分别搜索unrecognised和EXT_CSD，对比找到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">mmc.c</div><div class="line">↓</div><div class="line">if (ext_csd_struct &gt; 5) &#123;               // 更改版本号5变为8，因为调试信息中为version7，当version小于7时，才不会跳入这里</div><div class="line">        printf(&quot;unrecognised EXT_CSD structure &quot;</div><div class="line">            &quot;version %d\n&quot;, ext_csd_struct);</div><div class="line">        err = -1;</div><div class="line">        goto out;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></li><li><p>法2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mmc.c</div><div class="line">↓</div><div class="line">int mmc_initialize(bd_t *bis)</div><div class="line">    ↓</div><div class="line">mmc = find_mmc_device(1);   // 在启动uboot时，寻找MMC设备，0为机子内部的inand，1为SD2的卡槽</div></pre></td></tr></table></figure></li></ul><h3 id="4-USART通信"><a href="#4-USART通信" class="headerlink" title="4.USART通信"></a>4.USART通信</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define CONFIG_SERIAL3          1   /* we use UART2 on SMDKC110  定义板子的串口通信端口*/</div></pre></td></tr></table></figure><h3 id="5-网卡DM9000"><a href="#5-网卡DM9000" class="headerlink" title="5.网卡DM9000"></a>5.网卡DM9000</h3><p>程序：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">init_sequence       board.c     </div><div class="line">↓</div><div class="line">board_init          smdkc110.c</div><div class="line">    ↓</div><div class="line">dm9000_pre_init</div><div class="line">SROM_BW_REG &amp;= ~(0xf &lt;&lt; 4);                             // 查原理图可知，使用了Bank1</div><div class="line">SROM_BW_REG |= (1&lt;&lt;7) | (1&lt;&lt;6) | (1&lt;&lt;5) | (1&lt;&lt;4);</div><div class="line"></div><div class="line">SROM_BC1_REG = ((0&lt;&lt;28)|(1&lt;&lt;24)|(5&lt;&lt;16)|(1&lt;&lt;12)|(4&lt;&lt;8)|(6&lt;&lt;4)|(0&lt;&lt;0));      // 使用了SROM_CS1</div><div class="line"></div><div class="line">tmp &amp;=~(0xf&lt;&lt;4);            // 引脚复用，选择SROM_CSn[1]作为复用功能</div><div class="line">tmp |=(2&lt;&lt;4);</div></pre></td></tr></table></figure><p></p><p>数据：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">smdkv210single.h</div><div class="line">↓</div><div class="line">#define CONFIG_DM9000_BASE      (0x88000300)        // 使用了SROMC_Bank1</div><div class="line">    ↓</div><div class="line">#define DM9000_DATA         (CONFIG_DM9000_BASE+4)  // ADDR2接上了CMD，4表示二进制的0b100，代表ADDR2位高电平</div></pre></td></tr></table></figure><p></p><h1 id="Linux-kernel移植"><a href="#Linux-kernel移植" class="headerlink" title="Linux kernel移植"></a>Linux kernel移植</h1><h2 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h2><ul><li>将光盘kernel文件<code>*Linux资源\Linux源码包\3.0.8\Kernel_3.0.8_TQ210_for_Linux_v2.2.tar.bz2*</code>复制到你的交叉编译环境(我的是虚拟机Ubuntu)</li><li>将文件解压 <code>tar -jxvf Kernel_3.0.8_TQ210_for_Linux_v2.2.tar.bz2</code></li></ul><h2 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h2><h3 id="清理内核编译文件"><a href="#清理内核编译文件" class="headerlink" title="清理内核编译文件"></a>清理内核编译文件</h3><ul><li><code>make distclean</code></li></ul><h3 id="配置生成默认文件"><a href="#配置生成默认文件" class="headerlink" title="配置生成默认文件"></a>配置生成默认文件</h3><ul><li><code>cp config_for_TQ210_Linux_v2.1_CoreB .config</code> #直接使用天嵌已经给的默认配置文件</li></ul><h3 id="kernel-裁剪"><a href="#kernel-裁剪" class="headerlink" title="kernel 裁剪"></a>kernel 裁剪</h3><ul><li><p><code>make menuconfig</code></p><ul><li>如果是第一次使用的话，可能会出现错误</li><li>根据错误，需要下载<code>ncurses</code>，先执行<code>sudo apt-get install libncurses5-dev</code>来下载，然后再<code>make menuconfig</code></li></ul></li><li><p>Device Drivers</p><ul><li>Multimedia support<ul><li>Video capture adapters<ul><li>[x] Samsung Camera Interface (FIMC) driver // 移除摄像头驱动<ul><li>[ ] camera ov3640</li><li>[ ] camera ov9650</li><li>[ ] camera tvp5150</li><li>[ ] camera saa7113</li></ul></li><li>[x] Samsung TV Driver<ul><li>[ ] HDMI CEC driver support // 移除HDMI遥控驱动</li><li>[x] HDMI HPD driver support</li></ul></li></ul></li></ul></li><li>HID Devices<ul><li>[ ] USB Human Interface Device (full HID) support // 移除鼠标驱动</li></ul></li><li>Networking support<ul><li>[ ] Bluetooth subsystem support // 移除蓝牙驱动</li></ul></li></ul></li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VPS搭建</title>
    <link href="https://www.jmlin.club/posts/VPS%E6%90%AD%E5%BB%BA.html"/>
    <id>https://www.jmlin.club/posts/VPS搭建.html</id>
    <published>2017-12-21T13:14:18.000Z</published>
    <updated>2017-12-22T08:39:40.667Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>实验室的海外服务器还有10来天就过期了，趁有点时间就玩一玩！<br><a id="more"></a></p><blockquote><p>前言：今天去<a href="https://www.vultr.com/?ref=7283845" target="_blank" rel="external">Vultr</a>部署了一个虚拟专用服务器(下面以VPS代指)，一开始系统分配的IP已经被GFW墙了，可是我还抱着一丝轻蔑的态度，想要用远程终端通过代理来登录，折腾了2个小时后觉得不太靠谱，还是把VPS给删除掉，让系统再从新分配一个不同IP的VPS给我。然后马上来这里<a href="http://m.tool.chinaz.com/ping/" target="_blank" rel="external">ping</a>测试一下有没有被墙。幸运的是，我第二次就可以了，不需要通过代理就能用putty来登录VPS。弱弱地吐槽一句，Vultr的网页终端交互能力好弱啊！</p></blockquote><ul><li>所部署的VPS参数如下<img src="http://p1crnqdyo.bkt.clouddn.com/images/VPS_config.png"> 用了Ubuntu14.04挺久的了，所以玩生不如玩熟！！！</li></ul><h1 id="一些更新"><a href="#一些更新" class="headerlink" title="一些更新"></a>一些更新</h1><ul><li><code>apt-get update &amp;&amp; apt-get upgrade</code></li><li><code>apt-get install gcc g++</code> # 更新编译器</li><li><code>apt-get install aptitude</code></li></ul><h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>系统原生配置的是<code>vi</code>，我习惯用vim就下载一个<code>vim</code>,接着再安装vim的插件</p><ul><li><code>apt-get install vim</code></li><li><code>wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -x</code></li></ul><h1 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h1><ul><li><p>这个我就不多做解释了，懂的人懂就好！（奸笑ing）</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh</div><div class="line">chmod +x shadowsocksR.sh</div><div class="line">./shadowsocksR.sh 2&gt;&amp;1 | tee shadowsocksR.log</div></pre></td></tr></table></figure></li><li><p>一开始要设置密码，之后的都使用默认配置</p></li></ul><h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./shadowsocksR.sh uninstall         # 卸载</div><div class="line">/etc/init.d/shadowsocks start       # 启动</div><div class="line">/etc/init.d/shadowsocks stop        # 停止</div><div class="line">/etc/init.d/shadowsocks restart     # 重启</div><div class="line">/etc/init.d/shadowsocks status      # 状态</div></pre></td></tr></table></figure><h2 id="文件配置路径"><a href="#文件配置路径" class="headerlink" title="文件配置路径"></a>文件配置路径</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">/etc/shadowsocks.json               # 配置文件路径</div><div class="line">/var/log/shadowsocks.log            # 日志文件路径</div><div class="line">/usr/local/shadowsocks              # 代码安装目录</div></pre></td></tr></table></figure><h1 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h1><h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><ul><li><code>apt-get install mysql-server mysql-client libmysqlclient-dev libmysql-java</code></li><li>弹出蓝色框框，输入两次密码</li></ul><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><ul><li><code>mysql -u root -p</code></li></ul><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><ul><li><code>apt-get install git -y</code></li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li><code>git config --global user.email &quot;eclaboratory@163.com&quot;</code></li><li><code>git config --global user.name &quot;EC-Lab&quot;</code></li><li><code>git config --global credential.helper store</code> # 用于保存用户数据</li></ul><h1 id="博客环境搭建"><a href="#博客环境搭建" class="headerlink" title="博客环境搭建"></a>博客环境搭建</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ul><li><code>apt-get install npm</code></li><li><code>apg-get install nginx -y</code></li><li><code>npm install hexo-cli hexo-server -g</code></li></ul><blockquote><p>之后继续补充！</p></blockquote><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;实验室的海外服务器还有10来天就过期了，趁有点时间就玩一玩！&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://www.jmlin.club/categories/Geek/"/>
    
    
      <category term="VPS" scheme="https://www.jmlin.club/tags/VPS/"/>
    
      <category term="Vultr" scheme="https://www.jmlin.club/tags/Vultr/"/>
    
  </entry>
  
  <entry>
    <title>Vim之高手进阶篇</title>
    <link href="https://www.jmlin.club/posts/Vim%E4%B9%8B%E9%AB%98%E6%89%8B%E8%BF%9B%E9%98%B6%E7%AF%87.html"/>
    <id>https://www.jmlin.club/posts/Vim之高手进阶篇.html</id>
    <published>2017-12-21T13:03:46.000Z</published>
    <updated>2017-12-22T08:33:37.931Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>距离上一次发博客也是有一段时间了！<br><a id="more"></a></p><hr><h2 id="在命令模式下移动光标"><a href="#在命令模式下移动光标" class="headerlink" title="在命令模式下移动光标"></a>在命令模式下移动光标</h2><pre><code class="vim">                        H(屏幕首行开头)
                        gg(文章首行开头)
<span class="number">0</span>(行首)                                                 $(行末)
<span class="keyword">b</span>(前一个单词开头)                                        <span class="keyword">w</span>(后一个单词开头)
                                                        <span class="keyword">e</span>(后一个单词末尾)
                        G(文章末行开头)
</code></pre><h2 id="从命令模式进入插入模式"><a href="#从命令模式进入插入模式" class="headerlink" title="从命令模式进入插入模式"></a>从命令模式进入插入模式</h2><pre><code>o       &quot; 在当前光标所在行下面插入一行
O       &quot; 在当前光标所在行上面插入一行
</code></pre><h2 id="分屏模式"><a href="#分屏模式" class="headerlink" title="分屏模式"></a>分屏模式</h2><ul><li>适用于多文件处理<h3 id="横向分屏"><a href="#横向分屏" class="headerlink" title="横向分屏"></a>横向分屏</h3>:sp otherfilename “ split<h3 id="垂直分屏"><a href="#垂直分屏" class="headerlink" title="垂直分屏"></a>垂直分屏</h3>:vsp otherfilename “ vertically split<h3 id="切换Viewport"><a href="#切换Viewport" class="headerlink" title="切换Viewport"></a>切换Viewport</h3>| 按键 | 作用 |<br>| :——– | :——– |<br>| Ctrl + w -&gt; h | 移动光标到左边的viewport|<br>| Ctrl + w -&gt; j | 移动光标到下边的viewport|<br>| Ctrl + w -&gt; k | 移动光标到上边的viewport|<br>| Ctrl + w -&gt; l | 移动光标到右边的viewport|<br>| Ctrl + w -&gt; + | 扩大当前viewport|<br>| Ctrl + w -&gt; - | 缩小当前viewport|<br>| Ctrl + w -&gt; = | 重新均匀分配各个viewport的占比|<br>| Ctrl + w -&gt; r | 调换各个viewport的位置。用R的话是反向调换|<br>| Ctrl + w -&gt; q 或c | 关闭当前viewport|<br>| Ctrl + o 或 :only | 只保留当前所在viewport|</li></ul><h2 id="字符搜索"><a href="#字符搜索" class="headerlink" title="字符搜索"></a>字符搜索</h2><pre><code>/                   &quot; 顺序查找(n下一个、N上一个)
?                   &quot; 逆向查找
%                   &quot; 配对括号查找
</code></pre><h2 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h2><pre><code>:s/old/new          &quot; 只改当前所在行的第一个
:s/old/new/g        &quot; 只改当前所在行的所有
:#,#s/old/new/g     &quot; #，#表示若干行中首位两行的行号
:%s/old/new/g       &quot; 替换整个文件中的每个匹配符
:%s/old/new/gc      &quot; 替换整个文件中的每个匹配符， 但会提示是否进行替换
</code></pre><h2 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h2><pre><code>:r filename         &quot; 在光标后插入一个文件的内容
</code></pre><h2 id="在vim中执行外部shell命令"><a href="#在vim中执行外部shell命令" class="headerlink" title="在vim中执行外部shell命令"></a>在vim中执行外部shell命令</h2><pre><code>:! shell_command
:w FILENAME                 &quot; 可将当前编辑文件保存FILENAME文件中
v motion :w FILENAME        &quot; 可将当前编辑文件中可视模式下选中的内容保存到FILENAME文件中
:read FILENAME              &quot; 可提取磁盘文件FILENAME并将其插入到当前文件的光标位置后面
:read ! wc %                &quot; 可将文件包含的行数、单词数和字符数输出到当前文件的光标位置后面
:2read ! wc %               &quot; 插入到第二行，使用`$`在最后一行插入，`0`在第一行前面插入
</code></pre><h2 id="保存当前所有打开的文件及其状态"><a href="#保存当前所有打开的文件及其状态" class="headerlink" title="保存当前所有打开的文件及其状态"></a>保存当前所有打开的文件及其状态</h2><pre><code>:mksession ~/.vim/sessions/your_session_name.vim
</code></pre><h2 id="还原上次会话"><a href="#还原上次会话" class="headerlink" title="还原上次会话"></a>还原上次会话</h2><ul><li>法一：<code>:source ~/.vim/sessions/your_session_name.vim</code></li><li>法二：<code>vim -S ~/.vim/sessions/your_session_name.vim</code></li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;距离上一次发博客也是有一段时间了！&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://www.jmlin.club/categories/Geek/"/>
    
    
      <category term="vim" scheme="https://www.jmlin.club/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi 3B上手</title>
    <link href="https://www.jmlin.club/posts/Raspberry-Pi3%E4%B8%8A%E6%89%8B.html"/>
    <id>https://www.jmlin.club/posts/Raspberry-Pi3上手.html</id>
    <published>2017-11-26T10:41:47.000Z</published>
    <updated>2017-11-27T07:16:17.377Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>前段时间买了个树莓派3，但一直在忙其它东西，就把它荒废了！今天有时间，折腾就一下<br><a id="more"></a></p><blockquote><p><strong>注:</strong> <em>Raspberry系统为Raspbian 9.1 (Stretch)，如果是其它系统注意操作时的差异</em></p></blockquote><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><ul><li>如果不知道自己的系统版本的话，可以敲<br>lsb_release -a</li></ul><h2 id="Log-in"><a href="#Log-in" class="headerlink" title="Log in"></a>Log in</h2><ul><li>第一次登陆，默认用户名为pi,密码为raspberry</li><li>若要登陆root，可以改密码<br>sudo passwd root</li></ul><h2 id="更换镜像源"><a href="#更换镜像源" class="headerlink" title="更换镜像源"></a>更换镜像源</h2><pre><code>sudo vi /etc/apt/sources.list       
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib</div><div class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main non-free contrib</div></pre></td></tr></table></figure><pre><code>sudo apt-get update
sudo apt-get upgrade
</code></pre><h2 id="安装输入法"><a href="#安装输入法" class="headerlink" title="安装输入法"></a>安装输入法</h2><pre><code>sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin
</code></pre><h2 id="更新Vim"><a href="#更新Vim" class="headerlink" title="更新Vim"></a>更新Vim</h2><pre><code>apt-get remove vim-common
apt-get install vim
cd ~                        // 切换到当前用户根目录
vi .vimrc                   // 进入文件编辑
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">set autoindent              &quot; 自动缩进</div><div class="line">set cindent</div><div class="line">set tabstop=4               &quot; Tab宽度</div><div class="line">set softtabstop=4           &quot; 同一缩进为4</div><div class="line">set shiftwidth=4        </div><div class="line">set expandtab               &quot; 使用空格代替制表符</div><div class="line">set nu                      &quot; 显示行号</div></pre></td></tr></table></figure><pre><code>source .vimrc
</code></pre><h2 id="配置WIFI链接文件"><a href="#配置WIFI链接文件" class="headerlink" title="配置WIFI链接文件"></a>配置WIFI链接文件</h2><pre><code>vi /etc/wpa_supplicant/wpa_supplicant.conf
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">country=CN</div><div class="line">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev         # 当前使用interface的socket文件</div><div class="line">update_config=1</div><div class="line">ap_scan=2           # 默认值是1，表示优先链接可见WIFI，受优先级影响</div><div class="line">                    # 2，表示按照network定义的顺序链接，不受优先级影响</div><div class="line">network=&#123;</div><div class="line">ssid=&quot;Your Router&quot;</div><div class="line">psk=&quot;Your Passwd&quot;</div><div class="line">key_mgmt=WPA-PSK    # 加密选项</div><div class="line">priority=6         # 链接优先级 越大越链接</div><div class="line">&#125;</div><div class="line"></div><div class="line">network=&#123;</div><div class="line">ssid=&quot;Your Router&quot;</div><div class="line">psk=&quot;Your Passwd&quot;</div><div class="line">key_mgmt=WPA-PSK</div><div class="line">priority=5</div><div class="line">scan_ssid=1         # 连接隐藏WIFI选项</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="设置无线网卡静态IP"><a href="#设置无线网卡静态IP" class="headerlink" title="设置无线网卡静态IP"></a>设置无线网卡静态IP</h2><pre><code>ifconfig wlan0          # 记录ether后面的一组数据(如：e8:27:39:sd:ed:66)，后面会用到
vi /etc/dhcpcd.conf
</code></pre><ul><li>在文件后面添加内容，下面的IP地址要根据自己所连接WIFI的IP地址改动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface e8:27:39:sd:ed:66 </div><div class="line">static ip_address=192.168.0.3/24 </div><div class="line">static routers=192.168.0.1 </div><div class="line">static domain_name_servers=192.168.0.2 8.8.8.8</div></pre></td></tr></table></figure><pre><code>reboot
</code></pre><h2 id="root登录ssh"><a href="#root登录ssh" class="headerlink" title="root登录ssh"></a>root登录ssh</h2><pre><code>vi /etc/ssh/sshd_config
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">PermitRootLogin prohibit-password</div><div class="line">改为</div><div class="line">PermitRootLogin yes</div></pre></td></tr></table></figure><h2 id="防止ssh连接因超时闲置断开"><a href="#防止ssh连接因超时闲置断开" class="headerlink" title="防止ssh连接因超时闲置断开"></a>防止ssh连接因超时闲置断开</h2><pre><code>vi /etc/ssh/sshd_config
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClientAliveInterval 60</div></pre></td></tr></table></figure><pre><code>/etc/init.d/ssh restart
</code></pre><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;前段时间买了个树莓派3，但一直在忙其它东西，就把它荒废了！今天有时间，折腾就一下&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://www.jmlin.club/categories/Geek/"/>
    
    
      <category term="树莓派3" scheme="https://www.jmlin.club/tags/%E6%A0%91%E8%8E%93%E6%B4%BE3/"/>
    
  </entry>
  
  <entry>
    <title>Uboot前期准备</title>
    <link href="https://www.jmlin.club/posts/Uboot%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87.html"/>
    <id>https://www.jmlin.club/posts/Uboot前期准备.html</id>
    <published>2017-10-11T08:33:26.000Z</published>
    <updated>2017-10-11T10:13:16.270Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>考虑到大家之前没有学习嵌入式相关的基础知识，我下面会先从构建代码环境讲起，如果之后大家觉得感兴趣的，我也会写其他东西给大家看！如果大家之后有什么疑问可以直接来找我。<br><a id="more"></a></p><blockquote><p><strong>注：</strong> 以下操作均在Windows平台</p></blockquote><h1 id="Uboot源码文件"><a href="#Uboot源码文件" class="headerlink" title="Uboot源码文件"></a>Uboot源码文件</h1><h2 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h2><ul><li>拿到老师给的光盘镜像之后，进入<strong>bootloader</strong>文件</li><li>可以看到<strong>uboot_TQ210_1.3.4_V1.7.tar.bz2</strong>，分别解压两次会得到<strong>opt</strong>这个文件夹，在解压第二次的时候解压器会报出一些错误，可以忽略它（因为里面有Linux平台下的link类型文件与Windows不兼容）</li><li>按路径 <em>opt\EmbedSky\TQ210\uboot_TQ210_1.3.4</em> 依次进入到 <strong>uboot_TQ210_1.3.4</strong> 文件中，此目录在之后的代码分析中，我们称之为uboot的根目录</li></ul><h1 id="Source-Insight-4-0添加uboot源码工程"><a href="#Source-Insight-4-0添加uboot源码工程" class="headerlink" title="Source Insight 4.0添加uboot源码工程"></a>Source Insight 4.0添加uboot源码工程</h1><h2 id="软件安装及其破解"><a href="#软件安装及其破解" class="headerlink" title="软件安装及其破解"></a>软件安装及其破解</h2><ul><li><p>下面是Source Insight 4.0的软件下载链接：</p><blockquote><p>链接：<a href="http://pan.baidu.com/s/1geJWo9d" target="_blank" rel="external">http://pan.baidu.com/s/1geJWo9d</a> 密码：j9qu</p></blockquote></li><li><p>阅读那个 <strong>readme.txt</strong> 文件来破解</p></li></ul><h2 id="添加uboot源码工程"><a href="#添加uboot源码工程" class="headerlink" title="添加uboot源码工程"></a>添加uboot源码工程</h2><ul><li>现在uboot根目录下创建一个文件夹 <strong>SI_Project</strong> ，名字随便起都行，用于存放等下Source Insight创建工程的文件</li><li>打开Source Insight软件，在菜单栏点击Project-&gt; New Project</li><li>标号1是输入将要创建的工程名Uboot1.3.4（自己设置），标号2是选择你电脑uboot的根目录所在的文件夹，然后点击OK<br><img src="\images\Uboot前期准备\1.png" alt=""></li><li>标号1是找到刚才在uboot的根目录所创建的文件夹，我刚才创建了文件夹 <strong>SI_Project</strong>，然后点击OK<br><img src="\images\Uboot前期准备\2.png" alt=""></li><li>在Directory栏选择uboot根目录，然后在右边点击 Add ALL<br><img src="\images\Uboot前期准备\3.png" alt=""></li><li>把第二个勾上，意思是递归添加子目录文件，然后点击OK<br><img src="\images\Uboot前期准备\4.png" alt=""></li><li>等待一下，就可以点击右上角的Close按钮</li><li>点击标号1右侧打开文件目录，点击标号2，在标号3找到uboot根目录，可以看到右侧的文件就是源码文件及其文件夹<br><img src="\images\Uboot前期准备\5.png" alt=""></li></ul><h2 id="一些设置"><a href="#一些设置" class="headerlink" title="一些设置"></a>一些设置</h2><ul><li>因为之后需要浏览.S文件的汇编代码，所以需要在source insight中进行文件类型的关联</li><li>依次在菜单栏点击Options-&gt;File Type Options，在出现的窗口左边选择C Source File，在File filterd下添加 *.S，最后点击Close<br><img src="\images\Uboot前期准备\6.png" alt=""></li></ul><h1 id="Uboot根目录文件介绍"><a href="#Uboot根目录文件介绍" class="headerlink" title="Uboot根目录文件介绍"></a>Uboot根目录文件介绍</h1><ul><li><strong>arm_config.mk</strong> : 后缀为.mk，是一个Makefile文件，将来在某个Makefile中会调用它</li><li><strong>3个Changelog文件</strong> : 修改记录文件，该文件记录了这个uboot项目的版本变迁以及每个版本较上一个版本修改的记录。</li><li><strong>config.mk</strong> : 性质同arm_config.mk</li><li><strong>COPYING</strong> : 版权声明，uboot本身是GPL许可证的</li><li><strong>CREDITS</strong> : 鸣谢，记录了对uboot有贡献的人</li><li><strong>image_split</strong> : 一个脚本</li><li><strong>MAINTAINERS</strong> : 维护者，当前参与维护uboot源码的社区工作者</li><li><strong>MAKEALL</strong> :　一个脚本</li><li><strong>Makefile</strong> : 用于编译整个uboot</li><li><strong>mk</strong> : 快速编译的脚本，即先清理后配置再编译</li><li><strong>mkconfig</strong> ： uboot配置阶段的只要配置脚本，uboot的可移植性很大程度就是靠这个配置脚本在维护</li><li><strong>mkmovi</strong> ： 一个脚本，和inand/SD卡启动有关</li><li><strong>README</strong> : 使用说明书</li><li><strong>rules.mk</strong> : uboot中Makefile使用的规则</li></ul><h1 id="Uboot根文件夹介绍"><a href="#Uboot根文件夹介绍" class="headerlink" title="Uboot根文件夹介绍"></a>Uboot根文件夹介绍</h1><ul><li><strong>api</strong> : 硬件无关功能函数，uboot移植时不用管</li><li><strong>api_examples</strong> : API相关的测试示例代码</li><li><strong>board</strong> : 存放各种开发板相关的配置文件</li><li><strong>common</strong> : 用于存放一些与具体硬件无关的普遍适用的一些代码。譬如控制台实现、crc校验。但是更多的主要是两类：一类是cmd开头的，是用来实现uboot的命令系统的；另一类是env开头的，是用来实现环境变量的</li><li><strong>cpu</strong> ： 与SOC相关的，里面存放的代码都是SOC相关初始化和控制代码（如：CPU的、中断的、串口的等内部外设，包括起始代码start.S）</li><li><strong>disk</strong> : 磁盘有关</li><li><strong>doc</strong> : 文档目录，英文原档，帮助理解uboot</li><li><strong>drivers</strong> ： 存放Linux源代码中扣出来原封不动的Linux设备驱动，用于uboot的运行，主要是开发板上一些必须用到的驱动</li><li><strong>examples</strong> : 示例代码</li><li><strong>fs</strong> ： filesystem文件系统，从Linux源代码中移植过来的，用于管理flash等资源</li><li><strong>include</strong> ： 头文件目录</li><li><strong>lib开头的文件夹</strong> ： 架构相关的库文件 lib_arm(arm架构使用的一些库文件)、lib_generic（所有架构通用的库文件）</li><li><strong>libfdt</strong> ： 设备树有关的，使用设备树来进行启动传参，进行硬件信息的描述</li><li><strong>nand_spl</strong> : nand相关代码</li><li><strong>net</strong> : 网络相关的代码</li><li><strong>onenand开头</strong> ： onenand相关的代码</li><li><strong>tools</strong> : 一些工具类的代码</li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结。</p><p>欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;考虑到大家之前没有学习嵌入式相关的基础知识，我下面会先从构建代码环境讲起，如果之后大家觉得感兴趣的，我也会写其他东西给大家看！如果大家之后有什么疑问可以直接来找我。&lt;br&gt;
    
    </summary>
    
      <category term="Uboot" scheme="https://www.jmlin.club/categories/Uboot/"/>
    
    
      <category term="Uboot" scheme="https://www.jmlin.club/tags/Uboot/"/>
    
  </entry>
  
  <entry>
    <title>话说存储类关键字</title>
    <link href="https://www.jmlin.club/posts/%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB%E5%85%B3%E9%94%AE%E5%AD%97.html"/>
    <id>https://www.jmlin.club/posts/话说存储类关键字.html</id>
    <published>2017-08-28T02:23:46.000Z</published>
    <updated>2017-09-15T12:05:43.690Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="存储类关键字（用于修饰变量）"><a href="#存储类关键字（用于修饰变量）" class="headerlink" title="存储类关键字（用于修饰变量）"></a>存储类关键字（用于修饰变量）</h1><h2 id="auto-自动变量"><a href="#auto-自动变量" class="headerlink" title="auto(自动变量)"></a>auto(自动变量)</h2><ol><li>auto即平时的局部变量关键字，可以省略，故定义局部变量时都没有写</li><li>分配在内存中的栈上</li></ol><h2 id="register-寄存器变量"><a href="#register-寄存器变量" class="headerlink" title="register(寄存器变量)"></a>register(寄存器变量)</h2><ul><li>这个不是很常用</li></ul><ol><li>编译器会将其所修饰的变量<strong>尽量</strong>分配在寄存器中（使其变量的读写效率会变高）</li><li>由于寄存器数量有限，关键字所修饰的变量不一定都放在寄存器内</li></ol><h2 id="static-静态变量"><a href="#static-静态变量" class="headerlink" title="static(静态变量)"></a>static(静态变量)</h2><ul><li>修饰变量<ol><li>修饰全局变量</li><li>修饰局部变量</li></ol></li><li>修饰函数</li></ul><table><thead><tr><th style="text-align:center">修饰类别</th><th style="text-align:center">形成</th><th style="text-align:center">分配位置</th><th style="text-align:center">生命周期</th><th style="text-align:center">链接属性</th></tr></thead><tbody><tr><td style="text-align:center">局部变量</td><td style="text-align:center">静态局部变量</td><td style="text-align:center">数据段/BSS段</td><td style="text-align:center">代码块作用域</td><td style="text-align:center">无链接</td></tr><tr><td style="text-align:center">全局变量</td><td style="text-align:center">静态全局变量</td><td style="text-align:center">数据段/BSS段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">内链接</td></tr><tr><td style="text-align:center">函数</td><td style="text-align:center">静态函数</td><td style="text-align:center">在其声明文件</td><td style="text-align:center">文件作用域</td><td style="text-align:center">内链接</td></tr></tbody></table><h2 id="extern-外部变量"><a href="#extern-外部变量" class="headerlink" title="extern(外部变量)"></a>extern(外部变量)</h2><ul><li>修饰全局变量，用于文件作用域以外访问</li></ul><h2 id="const-只读变量"><a href="#const-只读变量" class="headerlink" title="const(只读变量)"></a>const(只读变量)</h2><ol><li>其所修饰的变量存储在只读变量区，在C中仍然是变量（C++中，是只读常量）</li><li>编译器通常将const保存在符号表中而非分配存储空间，从而节省了空间，提高了效率（例子：函数传参声明为const指针–另外一个就是防止该指针在函数体内被意外修改）</li></ol><table><thead><tr><th style="text-align:left">就近原则</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">const int a;</td><td style="text-align:left">a是常整型数，a不可变</td></tr><tr><td style="text-align:left">const int *a;</td><td style="text-align:left">a是指向一个常整型数的指针，a所指内容不可变</td></tr><tr><td style="text-align:left">int *const a;</td><td style="text-align:left">a是指向一个整型数的常指针，a不可变</td></tr><tr><td style="text-align:left">const int* const a;</td><td style="text-align:left">a是指向一个常整型数的常指针，a及其所指内容都不可变</td></tr></tbody></table><h3 id="修改const修饰的变量-在GCC环境中"><a href="#修改const修饰的变量-在GCC环境中" class="headerlink" title="修改const修饰的变量(在GCC环境中)"></a>修改const修饰的变量(在GCC环境中)</h3><p>在GCC中，const是通过编译器在编译的时候执行检查来确保实现的(即改const类型变量是编译错误，而非运行时错误)<br>GCC编译器把const类型的变量放在了数据段，只是通过编译器认定这个变量是const的，运行时并没有标记const标志，故只要骗过编译器，const变量就可以修改了。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> *p;</div><div class="line">p = (<span class="keyword">int</span> *)&amp;a;</div><div class="line">*p = <span class="number">6</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"a = %d. \n"</span>, a);</div></pre></td></tr></table></figure><p></p><h2 id="volatile-易变变量"><a href="#volatile-易变变量" class="headerlink" title="volatile(易变变量)"></a>volatile(易变变量)</h2><ul><li>用以修饰一个可以被编译器之外改变的变量，告诉编译器不对改变量的访问进行优化<blockquote><p>编译器之内：当前程序上下文的控制流（即当前代码）<br>编译器之外：中断ISR中引用的变量、多线程中共用的变量、硬件会更改的变量。（编译器在编译时无法预知的更改）</p></blockquote></li></ul><h2 id="typedef-自定义数据类型变量"><a href="#typedef-自定义数据类型变量" class="headerlink" title="typedef(自定义数据类型变量)"></a>typedef(自定义数据类型变量)</h2><p>自定义数据类型（不要与#define相混淆）<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *Pint;    <span class="keyword">const</span> Pint p;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *Pint;    Pint <span class="keyword">const</span> p;</div></pre></td></tr></table></figure><p></p><ul><li>以上两个皆相当于 int *const p; 即p皆为常指针<br>很多初学者都很难去记住上面的两个关系，是因为又与#define相混淆了，还没有完全理解typedef这个关键字<br>原理如下：</li><li>编译器在解析的时候会忽略数据类型，直接修饰p，因此以上两个式子都可以看为 <strong>Pint const p;</strong></li><li>如果实在想不通，就想想 <strong>const int i;</strong> 和<strong>int const i;</strong> 为什么是相同的</li></ul><h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a>restrict</h2><ul><li>只用于修饰指针；其告知编译器，所有修改该指针所指向内容的操作全部是基于该指针的，即不存在其他进行修改操作的途径<br>看不懂，是不是？其实它的作用就是为了帮助编译器进行更好的代码优化。</li></ul><blockquote><p>该关键字用得少，慎用</p></blockquote><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.jmlin.club/categories/C/"/>
    
    
      <category term="存储类" scheme="https://www.jmlin.club/tags/%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
    
      <category term="关键字" scheme="https://www.jmlin.club/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>话说存储类</title>
    <link href="https://www.jmlin.club/posts/%E8%AF%9D%E8%AF%B4%E5%AD%98%E5%82%A8%E7%B1%BB.html"/>
    <id>https://www.jmlin.club/posts/话说存储类.html</id>
    <published>2017-08-23T02:16:26.000Z</published>
    <updated>2017-08-23T12:06:52.067Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="存储类-Storage-Class"><a href="#存储类-Storage-Class" class="headerlink" title="存储类(Storage Class)"></a>存储类(Storage Class)</h1><p>简单来说，存储类就是C语言中存储变量的地方的类型<br>分为动态存储区，静态存储区</p><h2 id="动态存储区"><a href="#动态存储区" class="headerlink" title="动态存储区"></a>动态存储区</h2><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h3><ul><li>其增长方向：自顶向下增长</li><li>有内存空间的限制<h4 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h4></li></ul><ol><li>函数形参，在调用函数时给形参分配空间</li><li>函数内的自动变量（即普通变量）</li><li>函数调用时的现场保护和返回地址(即函数调用语句的下一句可执行语句)</li></ol><ul><li>在函数调用开始时分配存储空间，函数结束时释放存储空间</li><li>函数调用结束时，局部变量先出栈，接着是形参，最后栈指针指向最开始存储的地址来进行下一条指令</li></ul><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><ul><li>程序员自定义存储空间</li><li>使用后，需要手动释放内存，不然会造成内存泄露</li></ul><h2 id="静态存储区"><a href="#静态存储区" class="headerlink" title="静态存储区"></a>静态存储区</h2><h3 id="data段"><a href="#data段" class="headerlink" title=".data段"></a>.data段</h3><ul><li>存放非零全局变量、静态局部变量</li></ul><h3 id="bss段-Block-Started-by-Symbol"><a href="#bss段-Block-Started-by-Symbol" class="headerlink" title=".bss段(Block Started by Symbol)"></a>.bss段(Block Started by Symbol)</h3><ul><li>存放未初始化的全局变量、静态局部变量</li><li>运行时，由系统初始化，即清零。一般要自己写</li></ul><h3 id="ROData-文本常量区"><a href="#ROData-文本常量区" class="headerlink" title=".ROData(文本常量区)"></a>.ROData(文本常量区)</h3><ul><li>存放字符串常量<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p=<span class="string">"linux"</span>;                <span class="comment">// 定义了一个分配在栈上占4字节的指针指向了一个分配在文本常量区上占6字节的字符串</span></div></pre></td></tr></table></figure></li></ul><h3 id="text段-代码区"><a href="#text段-代码区" class="headerlink" title=".text段(代码区)"></a>.text段(代码区)</h3><ul><li>cup执行的机器指令部分(函数体的二进制代码)</li><li>属性只读，为了防止程序由于意外事故而修改自身指令</li></ul><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>作用域即变量或函数起作用的范围</p><ul><li>文件作用域</li><li>代码作用域</li></ul><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><ul><li>永久</li><li>临时</li></ul><h1 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h1><p>链接属性有以下3种：</p><ul><li>外链接</li><li>内链接</li><li>无链接<blockquote><p>宏定义 和 inline内联函数 链接属性为 无链接</p></blockquote></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储类</th><th style="text-align:center">作用域</th><th style="text-align:center">生命周期</th><th style="text-align:center">链接属性</th></tr></thead><tbody><tr><td style="text-align:center">普通全局变量</td><td style="text-align:center">.data段/.BSS段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">永久</td><td style="text-align:center">外链接</td></tr><tr><td style="text-align:center">静态全局变量</td><td style="text-align:center">.data段/.BSS段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">永久</td><td style="text-align:center">内链接</td></tr><tr><td style="text-align:center">普通局部变量</td><td style="text-align:center">栈</td><td style="text-align:center">代码作用域</td><td style="text-align:center">临时</td><td style="text-align:center">无链接</td></tr><tr><td style="text-align:center">静态局部变量</td><td style="text-align:center">.data段/.BSS段</td><td style="text-align:center">代码作用域</td><td style="text-align:center">永久</td><td style="text-align:center">无链接</td></tr><tr><td style="text-align:center">普通函数</td><td style="text-align:center">.text段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">永久</td><td style="text-align:center">外链接</td></tr><tr><td style="text-align:center">静态函数</td><td style="text-align:center">.text段</td><td style="text-align:center">文件作用域</td><td style="text-align:center">永久</td><td style="text-align:center">内链接</td></tr></tbody></table><h2 id="堆与栈的比较"><a href="#堆与栈的比较" class="headerlink" title="堆与栈的比较"></a>堆与栈的比较</h2><hr><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">Stack</th><th style="text-align:center">Heap</th></tr></thead><tbody><tr><td style="text-align:center">生长方向</td><td style="text-align:center">向地址减小的方向增长</td><td style="text-align:center">向地址增大的方向增长</td></tr><tr><td style="text-align:center">分配方式</td><td style="text-align:center">动态分配与静态分配</td><td style="text-align:center">动态分配</td></tr><tr><td style="text-align:center">碎片问题</td><td style="text-align:center">无此问题</td><td style="text-align:center">过多使用会造成内存不足</td></tr><tr><td style="text-align:center">申请后系统响应</td><td style="text-align:center">无可用空间报异常提示栈溢出</td><td style="text-align:center">系统分配申请的内存到空闲地址链表中</td></tr><tr><td style="text-align:center">分配效率</td><td style="text-align:center">相对高</td><td style="text-align:center">相对低</td></tr><tr><td style="text-align:center">申请大小</td><td style="text-align:center">系统预先规定好大小</td><td style="text-align:center">系统可用内存</td></tr><tr><td style="text-align:center">申请效率</td><td style="text-align:center">相对快</td><td style="text-align:center">相对慢，容易产生内容碎片</td></tr><tr><td style="text-align:center">存储内容</td><td style="text-align:center">看上面</td><td style="text-align:center">一般在堆的头部用1字节存放堆的大小，其他程序员安排</td></tr><tr><td style="text-align:center">存取效率</td><td style="text-align:center">相对快,char s[]=”Hello”;在运行时赋值;数组比指针要快一些</td><td style="text-align:center">相对慢;char *s=”Hello”;在编译时确定</td></tr></tbody></table><p>最后附上一张内存分布的图片<br><img src="\images\内存分布.png" alt="内存分布"></p><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.jmlin.club/categories/C/"/>
    
    
      <category term="存储类" scheme="https://www.jmlin.club/tags/%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
    
      <category term="作用域" scheme="https://www.jmlin.club/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
      <category term="生命周期" scheme="https://www.jmlin.club/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
      <category term="链接属性" scheme="https://www.jmlin.club/tags/%E9%93%BE%E6%8E%A5%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Vim之基础入门篇</title>
    <link href="https://www.jmlin.club/posts/Vim%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87.html"/>
    <id>https://www.jmlin.club/posts/Vim之基础入门篇.html</id>
    <published>2017-08-20T12:00:56.000Z</published>
    <updated>2017-08-22T04:25:39.242Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>很多人都对vim这货有所敬畏，其实只要多动手，vim是很容易上手的。用了vim大半年了，今天就写个基础入门篇，之后有空再加个高手进阶篇<br><a id="more"></a></p><h1 id="在命令模式下移动光标"><a href="#在命令模式下移动光标" class="headerlink" title="在命令模式下移动光标"></a>在命令模式下移动光标</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">                        <span class="keyword">k</span>(上)</div><div class="line">                                </div><div class="line">h(左)                                               <span class="keyword">l</span>(右)</div><div class="line">                        </div><div class="line">                        <span class="keyword">j</span>(下)</div></pre></td></tr></table></figure><h1 id="从命令模式进入插入模式"><a href="#从命令模式进入插入模式" class="headerlink" title="从命令模式进入插入模式"></a>从命令模式进入插入模式</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">a</span>       // 光标后插入</div><div class="line">i       // 光标前插入</div></pre></td></tr></table></figure><h1 id="从插入模式进入命令模式"><a href="#从插入模式进入命令模式" class="headerlink" title="从插入模式进入命令模式"></a>从插入模式进入命令模式</h1><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Esc</div></pre></td></tr></table></figure><h1 id="在命令模式下操作"><a href="#在命令模式下操作" class="headerlink" title="在命令模式下操作"></a>在命令模式下操作</h1><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yy      // 复制光标所在的一行</div></pre></td></tr></table></figure><h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">p</span>       // 粘贴到光标后</div><div class="line"><span class="keyword">P</span>       // 粘贴到光标前</div></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">x</span>       // 删除光标后的一个字母</div></pre></td></tr></table></figure><h2 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dd      // 剪切光标所在的一行</div></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">u</span>       // 撤销上一次操作</div><div class="line">U       // 撤销所在行的所以操作</div></pre></td></tr></table></figure><h1 id="从命令模式进入底线命令模式"><a href="#从命令模式进入底线命令模式" class="headerlink" title="从命令模式进入底线命令模式"></a>从命令模式进入底线命令模式</h1><h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="keyword">w</span></div></pre></td></tr></table></figure><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:q          // 如果所编辑的文件有更改，则退出失败</div></pre></td></tr></table></figure><h2 id="保存并退出"><a href="#保存并退出" class="headerlink" title="保存并退出"></a>保存并退出</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="keyword">wq</span></div></pre></td></tr></table></figure><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;很多人都对vim这货有所敬畏，其实只要多动手，vim是很容易上手的。用了vim大半年了，今天就写个基础入门篇，之后有空再加个高手进阶篇&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://www.jmlin.club/categories/Geek/"/>
    
    
      <category term="vim" scheme="https://www.jmlin.club/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>浅谈指针</title>
    <link href="https://www.jmlin.club/posts/%E8%AF%9D%E8%AF%B4%E6%8C%87%E9%92%88.html"/>
    <id>https://www.jmlin.club/posts/话说指针.html</id>
    <published>2017-08-20T06:05:08.000Z</published>
    <updated>2017-08-23T02:11:15.566Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="一级指针"><a href="#一级指针" class="headerlink" title="一级指针"></a>一级指针</h1><p>指针其实就是存放内存地址的变量，其长度在32位系统上固定为4字节。</p><h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><ul><li>数组的存储内容是指针<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> *p[];</div></pre></td></tr></table></figure></li></ul><h1 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h1><ul><li>指向一个数组的指针<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (*p)[];</div></pre></td></tr></table></figure></li></ul><h1 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h1><ul><li>函数的返回值类型是一个指针类型<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">pf</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">/* or */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">void</span> *<span class="title">pf</span><span class="params">()</span></span>;</div><div class="line"><span class="function">pf <span class="title">function</span><span class="params">()</span></span>;              <span class="comment">// 定义实例</span></div></pre></td></tr></table></figure></li></ul><p>所以指针函数用于修饰函数返回值</p><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><ul><li>指向一个函数的指针(函数名 与 &amp;函数名 都表示函数运行的首地址)<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (*fp)();</div><div class="line"><span class="comment">/* or */</span></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*fp)</span><span class="params">(<span class="keyword">int</span> ,<span class="keyword">char</span>)</span></span>;</div><div class="line">fp function;                <span class="comment">// 定义实例</span></div></pre></td></tr></table></figure></li></ul><h1 id="二重指针"><a href="#二重指针" class="headerlink" title="二重指针"></a>二重指针</h1><ul><li>指向一个int*类型的指针<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> **p;</div></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">实例</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">int a;</td><td style="text-align:center">&amp;a是一个int *型变量</td></tr><tr><td style="text-align:center">int *p;</td><td style="text-align:center">指针p指向一个int型变量</td></tr><tr><td style="text-align:center">int **p;</td><td style="text-align:center">指针p指向一个int *型变量</td></tr></tbody></table><hr><p><table><br><tr><br><th rowspan="2">int a[3]</th><br><th>a</th><br><th>a</th><br><th>a+1</th><br><th>&amp;a</th><br><th>&amp;a+1</th><br></tr><br><tr><br><td>int <em>类型</em></td><br><td>数组首元素首地址</td><br><td>(int)a + 1sizeof(int), 地址加4byte即a[1]</td><br><td>数组首地址</td><br><td>(int)a + 1*sizeof(int[3]), 地址加12byte即a[3]</td><br></tr></table></p><h2><a href="#" class="headerlink"></a></h2><h1 id="话说大端小端"><a href="#话说大端小端" class="headerlink" title="话说大端小端"></a>话说大端小端</h1><ul><li>大端：数据的高字节存储在低地址中</li><li>小端：数据的低字节存储在低地址中</li></ul><h2 id="代码判断"><a href="#代码判断" class="headerlink" title="代码判断"></a>代码判断</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">union</span> myunion</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">char</span> b;</div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">BigorSmall</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">union</span> myunion u1;</div><div class="line">    u1.a = <span class="number">1</span>;                </div><div class="line">    <span class="keyword">return</span> u1.b;                <span class="comment">// 地址0的那个字节内是1（小端）或者0（大端）</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">BigorSmall</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> b = *((<span class="keyword">char</span> *)(&amp;a));       </div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h1 id="指针都是4字节，为什么还要定义指针类型？"><a href="#指针都是4字节，为什么还要定义指针类型？" class="headerlink" title="指针都是4字节，为什么还要定义指针类型？"></a>指针都是4字节，为什么还要定义指针类型？</h1><p>定义指针类型的好处是：定义一个指针时，编译器为指针所指向的内容定义好大小，无需程序员去管理</p><h1 id="代码中的变量在内存的情况"><a href="#代码中的变量在内存的情况" class="headerlink" title="代码中的变量在内存的情况"></a>代码中的变量在内存的情况</h1><blockquote><p>计算机的内存地址分配原则：<br>内存寻址由大到小，优先分配内存地址较大的空间给变量（从下往上），先定义的变量，分配的地址越大<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</div><div class="line">    <span class="keyword">char</span> c = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> *p = &amp;c;                <span class="comment">// 编译器不会报错，但会有警告，因为指针类型不匹配</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d .\n"</span>,*p);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p></p></blockquote><p><img src="\images\变量在内存的分布情况.png" alt="代码中的变量在内存的情况"></p><ul><li>指针读取数据是箭头从下往上读取，该代码运行结果为513</li></ul><p><strong>注</strong>：本文内容部分来自互联网整理，部分来自个人经验总结；本文将持续收集更新，欢迎留言补充！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.jmlin.club/categories/C/"/>
    
    
      <category term="指针" scheme="https://www.jmlin.club/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="大端小端" scheme="https://www.jmlin.club/tags/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>话说内存对齐</title>
    <link href="https://www.jmlin.club/posts/%E8%AF%9D%E8%AF%B4%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90.html"/>
    <id>https://www.jmlin.club/posts/话说内存对齐.html</id>
    <published>2017-08-20T03:09:09.000Z</published>
    <updated>2017-08-23T07:26:21.551Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>颓废了一个多星期，感觉还是要写个博客压压惊！！！<br><a id="more"></a></p><h1 id="为什么会有内存对齐？"><a href="#为什么会有内存对齐？" class="headerlink" title="为什么会有内存对齐？"></a>为什么会有内存对齐？</h1><p>为了访问未对齐的内存，处理器需要作两次内存访问；而，对齐访问仅需要一次访问。</p><h1 id="对齐参数"><a href="#对齐参数" class="headerlink" title="对齐参数"></a>对齐参数</h1><p>32位系统中，默认4字节对齐（32位系统CPU字长是4字节）</p><ul><li>在Windows(32)/VC6.0下各种数据类型的变量的自身对齐参数就是该数据类型变量所占字节数的大小</li><li>在Linux(32)/GCC下double类型下的对齐参数为4<ul><li>Linux(32)/GCC下如果该数据类型的长度没有超过CPU的字长，则以该数据类型变量的长度作为自身对齐参数</li><li>如果超过了CPU字长，则自身对齐参数为CPU字长</li></ul></li></ul><h1 id="字节对齐原则"><a href="#字节对齐原则" class="headerlink" title="字节对齐原则"></a>字节对齐原则</h1><ul><li>结构体每个成员相对结构体首地址的偏移量(offset)是<em>对齐参数</em>(此对齐参数是取每个变量自身对齐参数和系统对齐参数两者中较小的一个)的整数倍，如果有需要会在每个成员之间填充字节<ul><li>编译器在为结构体成员开辟空间时，首先检查预开辟空间的地址相对于结构体首地址的偏移量是否为对齐参数的整数倍，若是，则存放该成员，否则，反之</li></ul></li><li>结构体变量所占空间的大小是对齐参数大小的整数倍，如有需要会在最后一个成员末尾填充若干字节使得所占空间是<em>对齐参数</em> (对结构体中所有变量的对齐参数的最大值和系统默认对齐参数<strong>#pragma pack(n)</strong>比较，较小者作为对齐参数)的整数倍</li></ul><blockquote><p>static修饰的变量所占空间没有被算入，因为其存储在.bss段/.data段</p></blockquote><h1 id="内存对齐的关键字"><a href="#内存对齐的关键字" class="headerlink" title="内存对齐的关键字"></a>内存对齐的关键字</h1><p>GCC推荐的对齐指令<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">__attribute__((packed))     <span class="comment">// 一字节对齐使用时，直接接放在进行内存对齐的类型定义后面，其作用范围为使用该类型定义的变量</span></div><div class="line"></div><div class="line">__attribute__((aligned(n))) <span class="comment">// 用法同上，使整个结构体进行n字节的对齐(n为2的幂次方)</span></div></pre></td></tr></table></figure><p></p><p>GCC支持但不推荐的对齐指令<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(n)     <span class="comment">// 放在自定义字节对齐的数据结构开头，指定编译器对齐参数为n字节</span></span></div><div class="line">定义结构体</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()      <span class="comment">// 放在自定义字节对齐的数据结构结尾，取消指定对齐参数，恢复缺省参数</span></span></div></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;颓废了一个多星期，感觉还是要写个博客压压惊！！！&lt;br&gt;
    
    </summary>
    
      <category term="C" scheme="https://www.jmlin.club/categories/C/"/>
    
    
      <category term="嵌入式C" scheme="https://www.jmlin.club/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FC/"/>
    
  </entry>
  
  <entry>
    <title>Uboot下烧录Linux内核镜像</title>
    <link href="https://www.jmlin.club/posts/Uboot%E4%B8%8B%E7%83%A7%E5%BD%95Linux%E5%86%85%E6%A0%B8%E9%95%9C%E5%83%8F.html"/>
    <id>https://www.jmlin.club/posts/Uboot下烧录Linux内核镜像.html</id>
    <published>2017-08-05T06:37:40.000Z</published>
    <updated>2017-08-22T02:06:01.415Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>本文的操作平台是S5PV210.<br><a id="more"></a></p><h2 id="启动介质-SD卡-iNand-Nand-NorFlash等-烧录镜像"><a href="#启动介质-SD卡-iNand-Nand-NorFlash等-烧录镜像" class="headerlink" title="启动介质(SD卡/iNand/Nand/NorFlash等)烧录镜像"></a>启动介质(SD卡/iNand/Nand/NorFlash等)烧录镜像</h2><ul><li>进入Uboot命令行<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">movi <span class="built_in">read</span> kernel 30008000           // 从启动介质的kernel分区去读取内核镜像到DDR地址为0x30008000处</div><div class="line">bootm 30008000                      // 启动内核</div></pre></td></tr></table></figure></li></ul><h2 id="tftp烧录镜像"><a href="#tftp烧录镜像" class="headerlink" title="tftp烧录镜像"></a>tftp烧录镜像</h2><h3 id="虚拟机Ubuntu"><a href="#虚拟机Ubuntu" class="headerlink" title="虚拟机Ubuntu"></a>虚拟机Ubuntu</h3><ul><li><a href="http://jmlin.club/%E9%85%8D%E7%BD%AETFTP.html" target="_blank" rel="external">配置tftp服务器</a></li><li>设置Ubuntu静态IP(192.168.1.141)</li><li>将要烧录的镜像放到Ubuntu的tftp文件夹（/tftpboot）中<h3 id="开发板"><a href="#开发板" class="headerlink" title="开发板"></a>开发板</h3></li><li><p>进入Uboot命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">set</span> ipaddr 192.168.1.20</div><div class="line"><span class="built_in">set</span> gatewayip 192.168.1.1</div><div class="line"><span class="built_in">set</span> serverip 192.168.1.141      // 设置为tftp服务器所在平台的IP</div></pre></td></tr></table></figure></li><li><p>测试连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ping 192.168.1.141</div></pre></td></tr></table></figure></li></ul><h3 id="烧录镜像"><a href="#烧录镜像" class="headerlink" title="烧录镜像"></a>烧录镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tftp 0x30008000 zImage-qt           // 将服务器下的zImage-qt镜像下载到DDR地址为0x30008000处</div><div class="line">bootm 0x30008000                    // 启动内核</div></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本文的操作平台是S5PV210.&lt;br&gt;
    
    </summary>
    
      <category term="Uboot" scheme="https://www.jmlin.club/categories/Uboot/"/>
    
    
      <category term="Uboot" scheme="https://www.jmlin.club/tags/Uboot/"/>
    
  </entry>
  
  <entry>
    <title>配置TFTP</title>
    <link href="https://www.jmlin.club/posts/%E9%85%8D%E7%BD%AETFTP.html"/>
    <id>https://www.jmlin.club/posts/配置TFTP.html</id>
    <published>2017-08-05T06:21:46.000Z</published>
    <updated>2017-08-22T01:58:57.898Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>Uboot启动内核镜像，除了在SD卡、Nand等raw分区中启动外，还可以通过tftp从远端服务器获取镜像。<br>下面是配置tftp的过程<br><a id="more"></a></p><h1 id="安装TFTP客户端、服务程序和xinetd"><a href="#安装TFTP客户端、服务程序和xinetd" class="headerlink" title="安装TFTP客户端、服务程序和xinetd"></a>安装TFTP客户端、服务程序和xinetd</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install tftp-hpa tftpd-hpa</div><div class="line">sudo apt-get install xinetd</div></pre></td></tr></table></figure><h1 id="文件配置"><a href="#文件配置" class="headerlink" title="文件配置"></a>文件配置</h1><h2 id="配置-etc-xinetd-conf"><a href="#配置-etc-xinetd-conf" class="headerlink" title="配置/etc/xinetd.conf"></a>配置/etc/xinetd.conf</h2><p>若没有，则创建，然后修改，下同<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Simple configuration file for xinetd</div><div class="line">##</div><div class="line">Some defaults, and include /etc/xinetd.d/</div><div class="line">defaults</div><div class="line">&#123;#</div><div class="line">Please note that you need a log_type line to be able to use log_on_success</div><div class="line"># and log_on_failure. The default is the following :</div><div class="line"># log_type = SYSLOG daemon info</div><div class="line">&#125;</div><div class="line">includedir /etc/xinetd.d</div></pre></td></tr></table></figure><p></p><h2 id="配置-etc-default-tftpd-hpa"><a href="#配置-etc-default-tftpd-hpa" class="headerlink" title="配置/etc/default/tftpd-hpa"></a>配置/etc/default/tftpd-hpa</h2><p>将内容改为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># /etc/default/tftpd-hpa</div><div class="line">TFTP_USERNAME=&quot;tftp&quot;</div><div class="line">TFTP_DIRECTORY=&quot;/tftpboot&quot;</div><div class="line">TFTP_ADDRESS=&quot;0.0.0.0:69&quot;</div><div class="line">TFTP_OPTIONS=&quot;-l -c -s&quot;</div></pre></td></tr></table></figure><p></p><h2 id="配置-etc-xinetd-d-tftp"><a href="#配置-etc-xinetd-d-tftp" class="headerlink" title="配置/etc/xinetd.d/tftp"></a>配置/etc/xinetd.d/tftp</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">service tftp</div><div class="line">&#123;</div><div class="line">socket_type = dgram</div><div class="line">wait = yes</div><div class="line">disable = no</div><div class="line">user = root</div><div class="line">protocol = udp</div><div class="line">server = /usr/sbin/in.tftpd</div><div class="line">server_args = -s /tftpboot</div><div class="line">#log_on_success += PID HOST DURATION</div><div class="line">#log_on_failure += HOST</div><div class="line">per_source = 11</div><div class="line">cps =100 2</div><div class="line">flags =IPv4</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><p>创建一个服务器存放文件的文件夹并设置最高权限<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /tftpboot</div><div class="line">sudo chmod 777 /tftpboot</div></pre></td></tr></table></figure><p></p><h2 id="重启服务"><a href="#重启服务" class="headerlink" title="重启服务"></a>重启服务</h2><p>每次修改完配置文件都需要重启服务<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo service tftpd-hpa restart</div><div class="line">sudo /etc/init.d/xinetd reload</div><div class="line">sudo /etc/init.d/xinetd restart</div></pre></td></tr></table></figure><p></p><h1 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h1><ol><li>在/tftpboot 中新建一个文件file</li><li><p>进入另一个文件夹中<br>进入本地tftp命令行下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo tftp localhost</div><div class="line">// 可输入<span class="built_in">help</span>查看命令和命令作用</div></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">get file    // 下载文件到当前文件夹 </div><div class="line">put file    // 上传文件到tftp服务器</div><div class="line">q           // 退出tftp命令行</div></pre></td></tr></table></figure></li></ol><h1 id="非本地"><a href="#非本地" class="headerlink" title="非本地"></a>非本地</h1><ol><li>关闭防火墙（sudo ufw disable）或 卸载防火墙（sudo apt -get remove iptables）</li><li>sudo tftp 目标ip地址</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;Uboot启动内核镜像，除了在SD卡、Nand等raw分区中启动外，还可以通过tftp从远端服务器获取镜像。&lt;br&gt;下面是配置tftp的过程&lt;br&gt;
    
    </summary>
    
      <category term="Ubuntu" scheme="https://www.jmlin.club/categories/Ubuntu/"/>
    
    
      <category term="TFTP" scheme="https://www.jmlin.club/tags/TFTP/"/>
    
      <category term="Ubuntu" scheme="https://www.jmlin.club/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Uboot启动两个阶段</title>
    <link href="https://www.jmlin.club/posts/Uboot%E5%90%AF%E5%8A%A8%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5.html"/>
    <id>https://www.jmlin.club/posts/Uboot启动两个阶段.html</id>
    <published>2017-08-05T02:58:51.000Z</published>
    <updated>2017-10-02T13:59:28.998Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>.<br><a id="more"></a></p><h1 id="Uboot启动两级阶段"><a href="#Uboot启动两级阶段" class="headerlink" title="Uboot启动两级阶段"></a>Uboot启动两级阶段</h1><h2 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h2><ul><li>流程：</li></ul><div id="flowchart-0" class="flow-chart"></div><h2 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h2><blockquote><p>对开发板级别的硬件、软件数据结构进行初始化</p></blockquote><ul><li>代码分析<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">start_armboot       <span class="comment">// 开始arm的启动</span></div><div class="line">    <span class="comment">// Uboot启动地址0x33e00000  Uboot大小2M     堆大小912KB         栈大小512KB     存放全局数据的结构体</span></div><div class="line">    gd_base = CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">gd_t</span>);     </div><div class="line">    gd = (<span class="keyword">gd_t</span>*)gd_base;            <span class="comment">// 将结构体指针gd实例化（分配空间）</span></div><div class="line">    init_sequence();</div><div class="line">        cpu_init();                 <span class="comment">// 空的，在汇编阶段已经初始化过</span></div><div class="line">        board_init();               <span class="comment">// 开发板</span></div><div class="line">            dm9000_pre_init();      <span class="comment">// 网卡初始化</span></div><div class="line">            gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE;             <span class="comment">// 机器码</span></div><div class="line">            gd-&gt;bd-&gt;bi_boot_params = (PHYS_SDRAM_1+<span class="number">0x100</span>);  <span class="comment">// 内存传参（启动参数）</span></div><div class="line">        interrupt_init();           <span class="comment">// 定时器4，用于计时</span></div><div class="line">        env_init();                 <span class="comment">// 环境变量初始化</span></div><div class="line">        init_baudrate();            <span class="comment">// 软件层gd数据结构波特率初始化     </span></div><div class="line">        serial_init();              <span class="comment">// 空的，在汇编阶段已经初始化过</span></div><div class="line">        console_init_f();           <span class="comment">// 控制台第一步初始化</span></div><div class="line">        display_banner();           <span class="comment">// 打印Uboot版本号</span></div><div class="line">        print_cpuinfo();            <span class="comment">// 打印SOC时钟频率信息</span></div><div class="line">        checkboard();               <span class="comment">// 检验开发板名字</span></div><div class="line">        dram_init();                <span class="comment">// 软件层gd数据结构DDR信息初始化</span></div><div class="line">        display_dram_config();      <span class="comment">// 打印板上DDR内存大小</span></div><div class="line">    mem_malloc_init (CFG_UBOOT_BASE + CFG_UBOOT_SIZE - CFG_MALLOC_LEN - CFG_STACK_SIZE);    <span class="comment">// 初始化Uboot所维护的堆内存</span></div><div class="line">    mmc_initialize(gd-&gt;bd);         <span class="comment">// 初始化iNand/SD卡 或 SOC上的控制器</span></div><div class="line">    env_relocate ();                <span class="comment">// 环境变量重定位</span></div><div class="line">    gd-&gt;bd-&gt;bi_ip_addr = getenv_IPaddr (<span class="string">"ipaddr"</span>);      <span class="comment">// 初始化软件层gd数据结构IP地址</span></div><div class="line">    gd-&gt;bd-&gt;bi_enetaddr             <span class="comment">// 初始化软件层gd数据结构以太网地址</span></div><div class="line">    devices_init ();                <span class="comment">// 参数传递，没有实现驱动初始化</span></div><div class="line">    jumptable_init ();              <span class="comment">// 跳转表</span></div><div class="line">    console_init_r ();              <span class="comment">// 控制台第二步初始化</span></div><div class="line">    enable_interrupts ();           <span class="comment">// 空的</span></div><div class="line">    loadaddr、bootfile               <span class="comment">// 内核启动环境变量读出初始化全局变量</span></div><div class="line">    board_late_init ();             <span class="comment">// 空的</span></div><div class="line">    eth_initialize(gd-&gt;bd);         <span class="comment">// 空的</span></div><div class="line">    x210_preboot_init();            <span class="comment">// LCD初始化和显示开机logo</span></div><div class="line">    check_menu_update_from_sd()     <span class="comment">// 检查自动更新</span></div><div class="line">    main_loop()                     <span class="comment">// 主循环</span></div></pre></td></tr></table></figure></li></ul><table><thead><tr><th style="text-align:center">区别</th><th style="text-align:center">第一阶段</th><th style="text-align:center">第二阶段</th></tr></thead><tbody><tr><td style="text-align:center">语言</td><td style="text-align:center">汇编阶段</td><td style="text-align:center">C阶段</td></tr><tr><td style="text-align:center">代码所在区域</td><td style="text-align:center">SRAM</td><td style="text-align:center">DRAM</td></tr><tr><td style="text-align:center">初始化</td><td style="text-align:center">SoC内部</td><td style="text-align:center">SoC外部Board内部</td></tr></tbody></table><p><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display:none">st=>start: Uboot入口
e=>end: 第二阶段
io=>inputoutput: 
step1=>operation: ENTRY(_start)
step2=>operation: 构建异常向量表
step3=>operation: 禁止中断,进入ARM状态,SVC模式
step4=>operation: 设置L2、L1cache和MMU
step5=>operation: 识别并暂存启动介质选择
step6=>operation: 第一次设置栈(SRAM)并调用lowlevel_init
step7=>operation: 检查复位状态
step8=>operation: 关看门狗
step9=>operation: 供电锁存
step10=>operation: 判断运行地址决定是否初始化时钟和DDR
step11=>operation: system_clock_init(时钟初始化)
step12=>operation: mem_ctrl_asm_init(DDR初始化)
step13=>operation: uart_asm_init(串口初始化并打印'O')
step14=>operation: pop {pc}     (打印'K')
step15=>operation: 第二次设置栈(DDR)
step16=>operation: 判断Uboot是否进行Relocate
step17=>operation: movi_bl2_copy
step18=>operation: 使能域访问
step19=>operation: 设置TTB(转换表基地址)
step20=>operation: 使能MMU单元
step21=>operation: 第三次设置栈(DDR)
step22=>operation: 清理BSS段
step23=>operation: _start_armboot

st(right)->step1->step2->step3
step3->step4->step5->step6
step6->step7->step8->step9
step9->step10->step11->step12
step12->step13->step14->step15
step15->step16->step17->step18->step19->step20
step20->step21->step22->step23(right)->e</textarea><textarea id="flowchart-0-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)</script></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="Uboot" scheme="https://www.jmlin.club/categories/Uboot/"/>
    
    
      <category term="Uboot" scheme="https://www.jmlin.club/tags/Uboot/"/>
    
  </entry>
  
  <entry>
    <title>Uboot主目录下的Makefile分析</title>
    <link href="https://www.jmlin.club/posts/Uboot%E4%B8%BB%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84Makefile%E5%88%86%E6%9E%90.html"/>
    <id>https://www.jmlin.club/posts/Uboot主目录下的Makefile分析.html</id>
    <published>2017-07-31T09:07:24.000Z</published>
    <updated>2017-08-22T02:06:51.139Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>本文是针对Uboot1.3.4 for x210来分析的，学习总结之余，也供大家参详！！！<br><a id="more"></a></p><h2 id="uboot-version确定（24-29）"><a href="#uboot-version确定（24-29）" class="headerlink" title="uboot version确定（24~29）"></a>uboot version确定（24~29）</h2><ul><li>VERSION:主版本号</li><li>PATCHLEVEL：次版本号</li><li>SUBLEVEL：再次版本号</li><li>EXTRAVERSION:另外附加的版本信息<blockquote><p>include/version_autogenerated.h文件是编译过程中自动生成的一个文件，里面的内容就是我们在Makefile中配置的uboot的版本号</p></blockquote></li></ul><h2 id="HOSTARCH和HOSTOS（31-41）"><a href="#HOSTARCH和HOSTOS（31-41）" class="headerlink" title="HOSTARCH和HOSTOS（31~41）"></a>HOSTARCH和HOSTOS（31~41）</h2><ul><li>直接在shell中执行uname -m 得到的就是电脑CPU的版本号</li><li>获取 HOSTARCH（CPU架构） HOSTOS（主机系统）</li></ul><h2 id="静默编译（50-54）"><a href="#静默编译（50-54）" class="headerlink" title="静默编译（50~54）"></a>静默编译（50~54）</h2><ul><li>编译时哦make -s ，-s会作为MAKEFLAGS传给Makefile，因此XECHO变量=echo，即输出空信息</li></ul><h2 id="单独输出文件夹编译（78-93）"><a href="#单独输出文件夹编译（78-93）" class="headerlink" title="单独输出文件夹编译（78~93）"></a>单独输出文件夹编译（78~93）</h2><ol><li>make O=输出目录</li><li>export BUILD_DIR=输出目录，然后make</li><li>若以上两者都指定了，O=输出目录具有更高的优先级</li></ol><h2 id="确定OBJTREE、SRCTREE、TOPDIR"><a href="#确定OBJTREE、SRCTREE、TOPDIR" class="headerlink" title="确定OBJTREE、SRCTREE、TOPDIR"></a>确定OBJTREE、SRCTREE、TOPDIR</h2><ul><li>OBJTREE: 存放编译出.o文件目录的根目录，在默认编译下，OBJTREE等于当前目录</li><li>SRCTREE: 源码目录，源代码的根目录，当前目录</li><li>TOPDIR: 源码目录</li></ul><h2 id="定义MKCONFIG变量（101）"><a href="#定义MKCONFIG变量（101）" class="headerlink" title="定义MKCONFIG变量（101）"></a>定义MKCONFIG变量（101）</h2><ul><li>其值为源码根目录下mkconfig脚本文件，是uboot配置阶段配置脚本</li></ul><h2 id="include-obj-include-config-mk-133"><a href="#include-obj-include-config-mk-133" class="headerlink" title="include $(obj)include.config.mk(133)"></a>include $(obj)include.config.mk(133)</h2><ul><li>include/config.mk不是源码自带的，是配置过程（make x210_sd_config）生成的<br>其内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ARCH   = arm</div><div class="line">CPU    = s5pc11x</div><div class="line">BOARD  = x210</div><div class="line">VENDOR = samsung</div><div class="line">SOC    = s5pc110</div></pre></td></tr></table></figure></li></ul><h2 id="调用MKCONFIG脚本传参（2589）"><a href="#调用MKCONFIG脚本传参（2589）" class="headerlink" title="调用MKCONFIG脚本传参（2589）"></a>调用MKCONFIG脚本传参（2589）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x210_sd_config : unconfig                                                                                                               #依赖为unconfig</div><div class="line">        @$(MKCONFIG) $(@:_config=) arm s5pc11xx 210 samsung s5pc110                               #传入参数有6个，$(@:_config=)变为x210_sd</div><div class="line">        @echo &quot;TEXT_BASE = 0xc3e00000&quot; &gt; $(obj)board/samsung/x210/config.mk                    #创建config.mk文件并添加内容</div></pre></td></tr></table></figure><ul><li>上面代码中的依赖 unconfig其定义在(473) 实现重复配置无报错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">unconfig:</div><div class="line">        @rm -f $(obj)include/config.h $(obj)include/config.mk \</div><div class="line">                $(obj)board/*/config.tmp $(obj)board/*/*/config.tmp \</div><div class="line">                $(obj)include/autoconf.mk $(obj)include/autoconf.mk.dep \</div><div class="line">                $(obj)board/$(VENDOR)/$(BOARD)/config.mk</div></pre></td></tr></table></figure><h2 id="ARCH-CROSS-COMPILE"><a href="#ARCH-CROSS-COMPILE" class="headerlink" title="ARCH CROSS_COMPILE"></a>ARCH CROSS_COMPILE</h2><ul><li>ARCH（133） 定义当前编译的目标CPU的架构</li><li>CROSS_COMPILE（136~180） 是定义交叉编译工具链的前缀（因为不同芯片所支持的工具链前缀都不一样，而后缀是一样的，这样定义增强程序可移植性）</li><li>可以在编译时用make CROSS_COMPILE=xxx来实现编译传参覆盖Makefile里面的设置</li></ul><h2 id="include-TOPDIR-config-mk（185）"><a href="#include-TOPDIR-config-mk（185）" class="headerlink" title="include $(TOPDIR)/config.mk（185）"></a>include $(TOPDIR)/config.mk（185）</h2><ul><li>运行其他配置，即进入config.mk文件</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;本文是针对Uboot1.3.4 for x210来分析的，学习总结之余，也供大家参详！！！&lt;br&gt;
    
    </summary>
    
      <category term="Uboot" scheme="https://www.jmlin.club/categories/Uboot/"/>
    
    
      <category term="Uboot" scheme="https://www.jmlin.club/tags/Uboot/"/>
    
  </entry>
  
  <entry>
    <title>个人使用软件</title>
    <link href="https://www.jmlin.club/posts/Personal-Software.html"/>
    <id>https://www.jmlin.club/posts/Personal-Software.html</id>
    <published>2017-07-27T07:57:25.000Z</published>
    <updated>2017-10-02T13:32:19.498Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p>文章不定期更新</p><p></p><blockquote class="blockquote-center">工欲善其事，必先利其器</blockquote><br><a id="more"></a><p></p><ul><li><em>在网上潜水了几年，由于最近一段时间有点时间，就整理一下自己的东西。这个是软件篇啦！</em><iframe height="360" width="620" src="\images\猫.gif"></iframe></li></ul><p>不知道大家对自己电脑系统里的软件的使用度是怎样，我是一个喜欢折腾且无论娱乐、学习、工作都会刻意追求软件精简与效率的人，特别是键盘流，当然了，离大神的距离还有很长很长。这几年大多的国产软件种种的流氓行为（例如弹窗推广、恶意修改用户设置等）显然是被我所厌恶而卸载的。借着博客这个平台，今天我就总结一下自己的软件使用清单。（以下个别软件可能需要科学上网方能下载））</p><h1 id="装机必备"><a href="#装机必备" class="headerlink" title="装机必备"></a>装机必备</h1><h2 id="浏览器："><a href="#浏览器：" class="headerlink" title="浏览器："></a>浏览器：</h2><ul><li><p><a href="https://www.google.com/chrome/browser/desktop/index.html" target="_blank" rel="external">Chrome</a><br><img src="\images\Chrome.png" alt="Chrome"><br>这个就不用我多说了吧？一个软件的强大之处在于其可外接插件，Chrome也不例外，其拓展插件源庞大，但官网下载需要科学上网，不过也可以自己在官网以外的地方找资源。之后我会整理一个自己Chrome所使用的插件列表，可以的话，我也会贡献一下资源。</p></li><li><p><a href="http://www.firefox.com.cn/" target="_blank" rel="external">Firefox</a><br><img src="\images\Firefox.png" alt="Firefox"><br>Firefox的插件源同样庞大，与Chrome最大的不同是，其自由度较大，可个人定制（前提你喜欢折腾），你懂的！！！</p></li></ul><h2 id="下载器："><a href="#下载器：" class="headerlink" title="下载器："></a>下载器：</h2><ul><li><p><a href="https://www.internetdownloadmanager.com/" target="_blank" rel="external">Internet Download Manager</a><br><img src="\images\IDM.png" alt="IDM"><br>大名鼎鼎的IDM，除了不能下载电驴链接，其他都还好，我就不多说了。直接上网盘地址吧。</p><blockquote><p>链接: <a href="http://pan.baidu.com/s/1wIL8U" target="_blank" rel="external">http://pan.baidu.com/s/1wIL8U</a> 密码: egaa</p></blockquote></li><li><p><a href="http://www.52pojie.cn/thread-572566-1-1.html/" target="_blank" rel="external">迅雷极速版</a><br><img src="\images\迅雷极速版.png" alt="迅雷极速版"><br>迅雷9有多恶心，大家可能领教过了，网上也有各种的迅雷9剔除广告的补丁。可是，呵呵，我还是想用回迅雷极速版，迅雷于我而言只是一个下载器，我不需要它所提供的其他功能！</p></li><li><p><a href="http://www.52pojie.cn/thread-551597-1-1.html" target="_blank" rel="external">Resilio Sync</a><br><img src="\images\Resilio Sync.png" alt="Resilio Sync"><br>一个基于P2P技术的多平台文件共享工具，其文件共享不需要经过云端服务器，所以它不限速、不限文件大小、不需要注册账户 。不过最近一个多月以来，由于一个不可明说但人人知道的原因，导致这个软件抽风了，使很多人都失联了。不过，黑夜中总会有一点曙光的。如果你失联了，点一下<a href="http://verysync.com/soft/resilio-sync-2-5-6-patched.html" target="_blank" rel="external">这里</a>吧。在这，就再次贡献个<a href="https://syncfan.com/" target="_blank" rel="external">链接</a>吧。</p></li></ul><h2 id="PDF浏览器："><a href="#PDF浏览器：" class="headerlink" title="PDF浏览器："></a>PDF浏览器：</h2><ul><li><p><a href="https://freewarehome.tw/pc/sumatra-pdf/" target="_blank" rel="external">SumatraPDF</a><br><img src="\images\SumatraPDF.png" alt="SumatraPDF"><br>我用它的原因，主要是它体积足够迷你，且启动速度快，非常适合在平板上使用。其实如果你有注意到，在我推荐的其它软件中大部分的体积都是十分迷人的！哈哈哈</p></li><li><p><a href="http://www.foxitsoftware.tw/downloads/" target="_blank" rel="external">Foxit</a><br><img src="\images\Foxit.png" alt="Foxit"><br>在我的笔记本电脑中，我浏览PDF主要是用Foxit的，其界面还可以，不过吸引我的主要是它的侧面工具栏，十分方便！</p></li></ul><h2 id="图片浏览器："><a href="#图片浏览器：" class="headerlink" title="图片浏览器："></a>图片浏览器：</h2><ul><li><a href="http://www.irfanview.com/" target="_blank" rel="external">IrfanView</a><br><img src="\images\IrfanView.png" alt="IrfanView"><br>体积迷你，启动速度快。很多时候对图片只是想单纯的浏览，而不想要其它不必要的功能！</li></ul><h2 id="云盘："><a href="#云盘：" class="headerlink" title="云盘："></a>云盘：</h2><ul><li><p>百度网盘我就不想多说了，相信大家都知道。</p></li><li><p><a href="https://www.google.com/intl/zh-TW_ALL/drive/" target="_blank" rel="external">Google Drive</a><br><img src="\images\Google Drive.png" alt="Google Drive"><br>15G免费的云储存空间试用，不过受墙的影响，想用就自己想办法了。</p></li></ul><p>如果想不用钱又大空间存储的话，貌似只有百度云盘了。</p><h1 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h1><h2 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h2><ul><li><p><a href="http://www.iobit.com/en/advancedsystemcarepro.php/" target="_blank" rel="external">Advanced Systemcare</a><br><img src="\images\Advanced SystemCare.png" alt="Advanced SystemCare"><br>一个国外优化软件，由于伟大的￥G*F·W#，软件在大陆境内不能实现自动升级，所以需要科学上网。另外软件需要注册码，大家有条件的就支持一下正版吧。如果是学生党可以去百度贴吧那里搜刮一下注册码。在这我就贡献一下自己的注册码。</p><blockquote><p>5F90C-4A11F-1BD01-DAC74</p></blockquote></li><li><p><a href="http://www.52pojie.cn/thread-392223-1-1.html/" target="_blank" rel="external">Process Lasso</a><br><img src="\images\Process Lasso.png" alt="Process Lasso"><br>一个系统进程优先级优化软件，软件默认的设置已经帮我们优化好了，如果不是特别懂，最好不要改动里面的默认设置。</p></li><li><p><a href="https://adguard.com/en/adguard-android/overview.html" target="_blank" rel="external">Adguard</a><br><img src="\images\ADGuard.png" alt="ADGuard"><br>可以拦截很多桌面上弹出的广告，且软件支持自定义安装各种拦截插件。</p></li></ul><h2 id="杀毒："><a href="#杀毒：" class="headerlink" title="杀毒："></a>杀毒：</h2><ul><li><a href="http://www.huorong.cn/" target="_blank" rel="external">火绒</a><br><img src="\images\火绒.png" alt="火绒"><br>堪称国产良心，我喜欢它的弹窗拦截，除了比它默认拦截的弹窗之外，有其它弹窗时，按一下Alt + Shift + A(软件默认的，可以自己改)选择要剔除的弹窗，然后你就真的永远见不到那个弹窗了，废话不多说，自己试过才知道。</li></ul><h2 id="解压："><a href="#解压：" class="headerlink" title="解压："></a>解压：</h2><ul><li><a href="http://www.developershome.com/7-zip/" target="_blank" rel="external">7-Zip</a><br><img src="\images\7z.png" alt="7z"><br>体积迷人，高压缩比率，极客必备。</li></ul><h2 id="效率："><a href="#效率：" class="headerlink" title="效率："></a>效率：</h2><ul><li><p><a href="https://autohotkey.com/" target="_blank" rel="external">AutoHotKey</a><br><img src="\images\AutoHotKey.png" alt="AutoHotKey"><br>一个脚本解释语言，解释器本身体积非常小，然后自己写要运行的脚本。当然了，网上也有很多已经写好的脚本，自己可以按需求去发现。一句话就是： 只要你会用，它无所不能。在此附上一个<a href="http://www.veryhuo.com/down/html/76513.html" target="_blank" rel="external">教程</a></p></li><li><p><a href="https://github.com/Wox-launcher/Wox/" target="_blank" rel="external">Wox</a></p></li><li><p>一款快速启动的软件，速度快的，体积迷你。文件搜索配合Everything使用，效果更佳。<iframe height="700" width="650" src="\images\Wox.gif"></iframe></p></li><li><p><a href="https://www.voidtools.com/" target="_blank" rel="external">Everything</a><br><img src="\images\Everything.png" alt="Everything"><br>是一款文件搜索软件，比Windows自带的文件搜索快太多太多了。</p></li><li><p><a href="http://www.listary.com/" target="_blank" rel="external">Listary</a><br><img src="\images\Listary.png" alt="Listary"><br>其效果就等于 Wox + Everything，至于用哪个就看个人喜好吧！附上一个<a href="http://v.youku.com/v_show/id_XNTYyNDAyNDgw.html/" target="_blank" rel="external">教程</a></p></li><li><p><a href="https://sourceforge.net/projects/ccseer/" target="_blank" rel="external">Seer</a><br><img src="\images\Seer.png" alt="Seer"><br>一款文件预览软件，体积迷你，按个Space键，可以预览文件信息，其所支持的文件格式十分多，例如可以支持C、Java等编程语言文件的语法高亮预览；还有歌曲的预览、PPT、PDF等格式文件的预览，十分方便，启动速度也很快。</p></li><li><p><a href="https://justgetflux.com/" target="_blank" rel="external">F.lux</a><br><img src="\images\F.lux.png" alt="F.lux"><br>一个护眼软件，作者已经多年没有更新了。不过功能够用。我本人十分喜欢它的夜间模式，即使周围没有光线，电脑屏幕也不刺眼。</p></li><li><p><a href="https://www.gdaily.org/11578/mactypeinstaller-2016-font-mac" target="_blank" rel="external">MacType</a><br><img src="\images\MacType.png" alt="MacType"><br>把Windows不顺眼的字体风格渲染成Mac Book的字体画风。因为可以选择注册表方式加载，所以就不会拖慢电脑开机速度</p></li><li><p><a href="http://download.cnet.com/FileNote/3000-2094_4-10019651.html" target="_blank" rel="external">FileNote</a><br><img src="\images\FileNote.png" alt="FileNote"><br>当文件繁多的时候(例如自己不熟悉的软件或一些不可备注的压缩包)，经常会不知道当前的文件要来干嘛的，此时可以使用FileNote对文件的用途进行备注，下次一看就知道这个文件是用来干嘛的了。</p></li><li><p><a href="http://ditto-cp.sourceforge.net/" target="_blank" rel="external">Ditto</a><br><img src="\images\Ditto.png" alt="Ditto"><br>一个剪切板工具，可保存最近的剪切记录或实现跨电脑跨平台剪切复制，且其所剪切的记录不单单是文本，也可以是图片、HTML等。<br>网上有很多关于Ditto的使用技巧，我就不一一罗列了</p></li></ul><h1 id="学习-amp-工作篇"><a href="#学习-amp-工作篇" class="headerlink" title="学习&amp;工作篇"></a>学习&amp;工作篇</h1><h2 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h2><ul><li><p><a href="https://leanote.com/" target="_blank" rel="external">Leanote</a><br><img src="\images\Leanote.png" alt="Leanote"><br>又称蚂蚁笔记，一款集笔记、博客、协作、私有云的笔记。其实，我之前是一直在用印象笔记的，碍于其对markdown语法支持一般，所以我就转入了Leanote，再者，蚂蚁笔记的主题自己改一下还是挺好看的。不过有一点还不太好，就是蚂蚁笔记现在还不支持对文章的加密，有点小小的遗憾！</p></li><li><p><a href="https://evernote.com/intl/zh-cn/" target="_blank" rel="external">EverNote</a><br><img src="\images\EverNote.png" alt="EverNote"><br>分为国际版(EverNote)、国内版(印象笔记)，两个的数据库是不相连接的。所以如果要使用，记得区分好，我一开始使用的时候就掉到了这个坑里。哈哈哈</p></li></ul><h2 id="翻译："><a href="#翻译：" class="headerlink" title="翻译："></a>翻译：</h2><ul><li><a href="http://www.lingoes.cn/" target="_blank" rel="external">Lingoes</a><br><img src="\images\Lingoes.png" alt="Lingoes"><br>文本翻译软件，功能还算全面，支持屏幕取词，划词翻译。不要问我为什么不用有道笔记，我不会告诉你是因为它经常弹窗骚扰的！</li></ul><h2 id="SSH："><a href="#SSH：" class="headerlink" title="SSH："></a>SSH：</h2><ul><li><p><a href="http://www.putty.org/" target="_blank" rel="external">Putty</a><br><img src="\images\Putty.png" alt="Putty"><br>Windows下对Unix系统的远程控制终端，体积迷你。</p></li><li><p><a href="https://winscp.net/eng/download.php" target="_blank" rel="external">WinSCP</a><br><img src="\images\WinSCP.png" alt="WinSCP"><br>一款开源的SFTP客户端。我的用途就是远程登录云端服务器。</p></li></ul><h2 id="文本编辑器："><a href="#文本编辑器：" class="headerlink" title="文本编辑器："></a>文本编辑器：</h2><ul><li><p><a href="https://gvim.en.softonic.com/" target="_blank" rel="external">gVim</a><br><img src="\images\gVim.png" alt="gVim"><br>Windows平台下的Vim，在Linux下玩久了，回到Windows不习惯的话，可以试试它。</p></li><li><p><a href="https://www.sublimetext.com/3/" target="_blank" rel="external">Sublime Text 3</a><br><img src="\images\Sublime Text 3.png" alt="Sublime Text 3"><br>前端程序员必备，它拥有庞大的插件源，因此可以拓展许多炫酷实用的功能。反正我现在都是用它来写博客的。</p></li><li><p><a href="https://notepad-plus-plus.org/download/v7.4.2.html" target="_blank" rel="external">Notepad++</a><br><img src="\images\Notepad++.png" alt="Notepad++"><br>一个程序员自由开发文本编辑软件。</p></li></ul><h2 id="文本比较："><a href="#文本比较：" class="headerlink" title="文本比较："></a>文本比较：</h2><ul><li><a href="https://www.scootersoftware.com/" target="_blank" rel="external">Beyond Compare</a><br><img src="\images\Beyond Compare.png" alt="Beyond Compare"><br>一个文本内容比较软件，我就不多说了。</li></ul><h2 id="科学上网篇"><a href="#科学上网篇" class="headerlink" title="科学上网篇:"></a>科学上网篇:</h2><ul><li><a href="https://github.com/XX-net/XX-Net/blob/master/code/default/download.md" target="_blank" rel="external">XX-Net</a><br><img src="\images\XX-Net.png" alt="XX-Net"><br>它是GitHub上一个开源的项目，相对于其他科学上网的VPN，xx-net是十分彪悍稳定的，当然天下没有免费的午餐，不想做小白就要自己一步一步地配置，配置过程可能有点小长。所以，怕折腾者勿点<a href="https://github.com/XX-net/XX-Net/wiki/%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3" target="_blank" rel="external">教程</a></li></ul><h1 id="娱乐篇"><a href="#娱乐篇" class="headerlink" title="娱乐篇"></a>娱乐篇</h1><h2 id="视频播放器："><a href="#视频播放器：" class="headerlink" title="视频播放器："></a>视频播放器：</h2><ul><li><a href="https://potplayer.daum.net/?lang=zh_CN" target="_blank" rel="external">Potplayer</a><br><img src="\images\Potplayer.png" alt="Potplayer"><br>拥有KMPlayer的硬件加速，界面简洁且功能强大，支持格式众多。</li></ul><h2 id="音乐播放器："><a href="#音乐播放器：" class="headerlink" title="音乐播放器："></a>音乐播放器：</h2><ul><li><p><a href="http://mcool.appinn.me/" target="_blank" rel="external">Mcool</a><br><img src="\images\Mcool.png" alt="Mcool"><br>一个短小精悍的本地音乐播放器。</p></li><li><p><a href="https://music.163.com/" target="_blank" rel="external">网易云音乐</a><br><img src="\images\网易云音乐.png" alt="网易云音乐"><br>喜欢它，主要是网易云的云端歌曲推送真心不错。</p></li></ul><h2 id="桌面美化："><a href="#桌面美化：" class="headerlink" title="桌面美化："></a>桌面美化：</h2><ul><li><a href="http://huoying666.com/" target="_blank" rel="external">火萤</a><br><img src="\images\火萤.png" alt="火萤"></li></ul><p>动态桌面，工作疲累时，看一看，还是挺恰意的。</p><blockquote><p><strong>没有最好的软件，只有最适合自己的软件</strong></p></blockquote><p>以上所列举的软件是我所用过的软件，如果你有更好的软件，也可以推荐我一下！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;文章不定期更新&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;工欲善其事，必先利其器&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Geek" scheme="https://www.jmlin.club/categories/Geek/"/>
    
    
      <category term="软件" scheme="https://www.jmlin.club/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="优雅" scheme="https://www.jmlin.club/tags/%E4%BC%98%E9%9B%85/"/>
    
      <category term="极客" scheme="https://www.jmlin.club/tags/%E6%9E%81%E5%AE%A2/"/>
    
      <category term="效率" scheme="https://www.jmlin.club/tags/%E6%95%88%E7%8E%87/"/>
    
      <category term="必备" scheme="https://www.jmlin.club/tags/%E5%BF%85%E5%A4%87/"/>
    
      <category term="win10" scheme="https://www.jmlin.club/tags/win10/"/>
    
      <category term="干货" scheme="https://www.jmlin.club/tags/%E5%B9%B2%E8%B4%A7/"/>
    
      <category term="工具" scheme="https://www.jmlin.club/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>前言</title>
    <link href="https://www.jmlin.club/posts/WTF.html"/>
    <id>https://www.jmlin.club/posts/WTF.html</id>
    <published>2017-07-26T07:29:00.000Z</published>
    <updated>2017-08-21T13:41:45.388Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --><p></p><blockquote class="blockquote-center">闻道有先后，术业有专攻，如是而已</blockquote><br><a id="more"></a><br>最近有点时间，所以就花了两天的时间搭建了这个博客。有人问我，你浪费那么多时间搭建这个博客，要来干嘛用？说实话，有时候挺怕遇到这种不太开明的朋友的。搭建一个博客于我而言，是一个个人言论空间（相对网络上很多著名的言论平台，自己发的帖不会被平台随意删除）。另外，我是一个比较爱折腾（你可以说我犯贱）的人，搭建博客对我这种菜鸟而言是一个提高的机会。<br>因为最近半年多都在学习ARM Linux，所以最近一段时间会把这半年来学的东西总结一下。另外，对于51单片机、STM32、ZigBee、WiFi，后期如果有时间我也会总结一下！！！<br>当然了，时不时我还是会附送一点小干货的！！！<p></p><blockquote><p>博客刚开始搭建起来，很多细节还不是做得很好！！！见谅啊！！！</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Dec 22 2017 18:10:03 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;闻道有先后，术业有专攻，如是而已&lt;/blockquote&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
